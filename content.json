{"meta":{"title":"Hexo","subtitle":"","description":"","author":"xiaojujing","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"9、学生管理系统","slug":"9、学生管理系统","date":"2020-10-12T12:46:53.982Z","updated":"2020-10-12T12:48:07.994Z","comments":true,"path":"2020/10/12/9、学生管理系统/","link":"","permalink":"http://yoursite.com/2020/10/12/9%E3%80%81%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"9、学生管理系统这是管理系统的源代码！","text":"9、学生管理系统这是管理系统的源代码！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package day09;import org.junit.Test;import java.util.ArrayList;import java.util.Scanner;public class StudentMannager &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;初始化界面 System.out.println(&quot;欢迎来到学生管理系统！&quot;); &#x2F;&#x2F;定义学生集合，进行数据管理 ArrayList&lt;Student&gt; stus &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F;用户输入参数，选择流程控制 Scanner sc &#x3D; new Scanner(System.in); while (true) &#123; &#x2F;&#x2F;展示4个功能模块 System.out.println(&quot;1、添加学生 2、删除学生 3、修改学生信息 4、查看所有学生 5、退出&quot;); int choice &#x3D; sc.nextInt(); switch (choice) &#123; case 1: addStudent(stus); &#x2F;&#x2F;添加学生到集合 break; case 2: deleteStudent(stus); &#x2F;&#x2F;根据学号删除学生 break; case 3: updateStudent(stus); &#x2F;&#x2F;根据学号修改学生信息 break; case 4: findAllStudent(stus); &#x2F;&#x2F;遍历集合打印所有学生信息 break; default: System.exit(0); &#125; &#125; &#125; private static void updateStudent(ArrayList&lt;Student&gt; stus) &#123; Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入你要更新的学生学号：&quot;); String id &#x3D; sc.nextLine(); id &#x3D; getRightId(sc, id, !isExist(id, stus), &quot;学号不存在，请重新输入：&quot;); System.out.println(&quot;请输入你要修改的学生姓名：&quot;); String name &#x3D; sc.nextLine(); System.out.println(&quot;请输入你要修改的学生年龄：&quot;); Integer age &#x3D; sc.nextInt(); Student stu &#x3D; new Student(id, name, age); for (int i &#x3D; 0; i &lt;stus.size() ; i++) &#123; if(id.equals(stus.get(i).getId()))&#123; stus.set(i,stu); break; &#125; &#125; &#125; private static String getRightId(Scanner sc, String id, boolean b, String s) &#123; while (true) &#123; &#x2F;&#x2F;遍历集合查找学号是否存在，不存在则重新输入 if (b) &#123; System.out.println(s); id &#x3D; sc.nextLine(); continue; &#125; else &#123; break; &#125; &#125; return id; &#125; private static void findAllStudent(ArrayList&lt;Student&gt; stus) &#123; for (Student student : stus) &#123; System.out.println(student); &#125; &#125; private static void deleteStudent(ArrayList&lt;Student&gt; stus) &#123; Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入你要删除的学生学号：&quot;); String id &#x3D; sc.nextLine(); id &#x3D; getRightId(sc, id, !isExist(id,stus), &quot;学号不存在，请重新输入：&quot;); for (int i &#x3D; 0; i &lt; stus.size(); i++) &#123; if(id.equals(stus.get(i).getId()))&#123; stus.remove(i); break; &#125; &#125; &#125; private static void addStudent(ArrayList&lt;Student&gt; stus) &#123; Scanner sc &#x3D; new Scanner(System.in); System.out.println(&quot;请输入你要添加的学生学号：&quot;); String id &#x3D; sc.nextLine(); id &#x3D; getRightId(sc, id, isExist(id,stus), &quot;学号重复，请重新输入：&quot;); System.out.println(&quot;请输入你要添加的学生姓名：&quot;); String name &#x3D; sc.nextLine(); System.out.println(&quot;请输入你要添加的学生年龄：&quot;); Integer age &#x3D; sc.nextInt(); Student stu &#x3D; new Student(id, name, age); stus.add(stu); &#125; private static boolean isExist(String id, ArrayList&lt;Student&gt; stus) &#123; for (Student student : stus) &#123; if(id.equals(student.getId()))&#123; return true; &#125; &#125; return false; &#125;&#125;","categories":[],"tags":[]},{"title":"8、字符串","slug":"8、字符串","date":"2020-09-28T13:49:24.000Z","updated":"2020-10-12T12:52:34.088Z","comments":true,"path":"2020/09/28/8、字符串/","link":"","permalink":"http://yoursite.com/2020/09/28/8%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"8、字符串1、初始化​ 1、new 一个字符串，的地址都不一样 ​ 2、String s = “字符串”，放在栈内，只要内容相同则地址值相同。 ​ 3、有参构造：传入char字符数组构造、传入字节数组构造 2、方法​ 1、getBytes（）返回一个byte[]数组 ​ 2、toCharArray（）返回一个字符数组 ​ 3、求子串、分割、返回包含的字串索引 3、StringBuilder内存图如下：","categories":[],"tags":[]},{"title":"7、面向对象基础","slug":"7、面向对象基础","date":"2020-09-28T13:49:12.000Z","updated":"2020-09-28T13:49:53.003Z","comments":true,"path":"2020/09/28/7、面向对象基础/","link":"","permalink":"http://yoursite.com/2020/09/28/7%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/","excerpt":"","text":"7、面向对象基础1、类和对象​ 1、类是现实世界中一类事物的抽象，对象是一个个具体的事物 ​ 2、成员变量是事物的属性，方法是事物的行为 2、private关键字​ private关键字可以修饰成员变量和成员方法，被修饰的成员只能在本类中访问。 3、构造方法​ 1、构造方法没有返回值，也不需要写返回值类型（其实是连void都不能写） ​ 2、构造方法名和类名相同，系统会默认给出一个无惨构造方法。","categories":[],"tags":[]},{"title":"6、进制","slug":"6、进制","date":"2020-09-28T13:48:59.000Z","updated":"2020-09-28T13:49:42.415Z","comments":true,"path":"2020/09/28/6、进制/","link":"","permalink":"http://yoursite.com/2020/09/28/6%E3%80%81%E8%BF%9B%E5%88%B6/","excerpt":"","text":"6、进制1.1、N进制转十进制​ 对N进制每一位number，取number*N^(位数-1)，再做和。 1.2、十进制转N进制​ sum/N=ans,余r;sum=ans,反复直到被除数等于0，将每次所得余数逆序拼接即为转化后的进制。 1.3、原码反码补码​ 1、正数的原反补相同 ​ 2、负数，原码等于正数的原码首位取反；反码等于原码取反（符号位不变）；补码等于反码末尾+1。 1.4、二维数组​ 1、初始化 12动态：int [][] arr &#x3D; new int[m][n];静态：int [][] arr &#x3D; &#123;&#123;，，，...&#125;，&#123;，，，...&#125;，...&#125;;","categories":[],"tags":[]},{"title":"5、方法","slug":"5、方法","date":"2020-09-25T14:25:34.000Z","updated":"2020-09-25T14:25:51.813Z","comments":true,"path":"2020/09/25/5、方法/","link":"","permalink":"http://yoursite.com/2020/09/25/5%E3%80%81%E6%96%B9%E6%B3%95/","excerpt":"","text":"5、方法1、方法重载的几种方式​ 1、参数类型不同 ​ 2、参数个数不同 ​ 3、参数顺序不同 1234567891011121314151617181920212223242526272829303132package com.itheima02.domain;&#x2F;** * @author xiaojujing * @date 2020-09-25 22:19 *&#x2F;public class overWrite &#123; public static void main(String[] args) &#123; int a &#x3D; 1; double b &#x3D; 1.1; f(a); f(b); f(a,b); f(b,a); &#125; private static void f(double b,int a) &#123; System.out.println(&quot;我是参数位置不同的重载函数&quot;); System.out.println(a + &quot; &quot; + b); &#125; private static void f(int a, double b) &#123; System.out.println(a + &quot; &quot; + b); &#125; private static void f(double b) &#123; System.out.println(b); &#125; private static void f(int a) &#123; System.out.println(a); &#125;&#125;","categories":[],"tags":[]},{"title":"2014蓝桥B组省赛题解","slug":"2014蓝桥B组省赛题解","date":"2020-09-24T14:22:10.467Z","updated":"2020-09-24T14:21:25.426Z","comments":true,"path":"2020/09/24/2014蓝桥B组省赛题解/","link":"","permalink":"http://yoursite.com/2020/09/24/2014%E8%93%9D%E6%A1%A5B%E7%BB%84%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/","excerpt":"","text":"2014蓝桥B组省赛题解1、啤酒和饮料​ 答案：11 ​ 思路：简单循环列举所有情况，送分题 2、切面条​ 答案：1025 ​ 思路：数学归纳法。 对折次数 折角 切一刀面条数 1 1 2+1 2 1+2 2+1+2 3 1+2+4 2+1+2+4 n 1+2+…+2^(n-1) 2+1+2+..2^(n-1) 3、李白打酒​ 答案：14 ​ 思路：按条件试探进行深搜，注意题目给的最后一次遇到的是花，出口应设置要提前一次。 12345678910111213141516#include&lt;iostream&gt; using namespace std;int ans &#x3D; 0;void f(int dian,int hua ,int jiu)&#123; if(dian&#x3D;&#x3D;0&amp;&amp;hua&#x3D;&#x3D;0&amp;&amp;jiu&#x3D;&#x3D;1)&#123; ans++; &#125; if(dian&gt;0) f(dian-1,hua,jiu*2); if(hua&gt;0) f(dian,hua-1,jiu-1);&#125;int main()&#123; f(5,9,2); cout&lt;&lt;ans; return 0;&#125; 4、史丰收速算​ 答案：if(r&gt;0) return i; ​ 思路：代码填空的经验一般要结合上下代码，写出相似或者是补充的判断条件，由此写出if条件为r&gt;0,返回的值为i是模拟了f(“4285712”)的结果输出了2999997，首字母为2与直接输出i=2相对应。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std; &#x2F;&#x2F;计算个位 int ge_wei(int a)&#123; if(a % 2 &#x3D;&#x3D; 0) return (a * 2) % 10; else return (a * 2 + 5) % 10; &#125; &#x2F;&#x2F;计算进位 int jin_wei(char* p)&#123; char* level[] &#x3D; &#123; &quot;142857&quot;, &quot;285714&quot;, &quot;428571&quot;, &quot;571428&quot;, &quot;714285&quot;, &quot;857142&quot; &#125;; char buf[7]; buf[6] &#x3D; &#39;\\0&#39;; strncpy(buf,p,6); int i; for(i&#x3D;5; i&gt;&#x3D;0; i--)&#123; int r &#x3D; strcmp(level[i], buf); if(r&lt;0) return i+1; while(r&#x3D;&#x3D;0)&#123; p +&#x3D; 6; strncpy(buf,p,6); r &#x3D; strcmp(level[i], buf); if(r&lt;0) return i+1; &#x2F;&#x2F;______________________________; &#x2F;&#x2F;填空 &#125; &#125; return 0;&#125; &#x2F;&#x2F;多位数乘以7void f(char* s) &#123; int head &#x3D; jin_wei(s); if(head &gt; 0) printf(&quot;%d&quot;, head); char* p &#x3D; s; while(*p)&#123; int a &#x3D; (*p-&#39;0&#39;); int x &#x3D; (ge_wei(a) + jin_wei(p+1)) % 10; printf(&quot;%d&quot;,x); p++; &#125; printf(&quot;\\n&quot;);&#125; int main()&#123; f(&quot;428571428571&quot;); f(&quot;34553834937543&quot;); return 0;&#125; 5、打印图形​ 答案：f(a, rank-1, row, col+w/2); ​ 思路：递归代码看整体，容易看出题目给出的是切割出来的下面两段，故补上上面段的递归打印。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std; #define N 70void f(char a[][N], int rank, int row, int col)&#123; if(rank&#x3D;&#x3D;1)&#123; a[row][col] &#x3D; &#39;*&#39;; return; &#125; int w &#x3D; 1; int i; for(i&#x3D;0; i&lt;rank-1; i++) w *&#x3D; 2; f(a, rank-1, row, col+w&#x2F;2); &#x2F;&#x2F;f(a, rank-1, row, col+w&#x2F;2);_________________;填空 f(a, rank-1, row+w&#x2F;2, col); f(a, rank-1, row+w&#x2F;2, col+w);&#125;int main()&#123; char a[N][N]; int i,j; for(i&#x3D;0;i&lt;N;i++) for(j&#x3D;0;j&lt;N;j++) a[i][j] &#x3D; &#39; &#39;; f(a,6,0,0); for(i&#x3D;0; i&lt;N; i++)&#123; for(j&#x3D;0; j&lt;N; j++) printf(&quot;%c&quot;,a[i][j]); printf(&quot;\\n&quot;); &#125; return 0;&#125; 6、奇怪的分式​ 答案：14 ​ 思路：列举所有种类的分数记录满足条件的结果数，这里我把题目中重复的部分分开了，只计算分数都小于1的相乘情况，再将结果乘以两倍；同时还考虑到了一个分数小于1一个分数大于1的情况，但是简单验证发现这部分没有满足题解的。建议大家还是列举所有的分子、分母不相等的情况，中间用continue跳过分子==分母的条件，这样不容易遗漏。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt; using namespace std;int gcd(int a,int b)&#123; if(b&#x3D;&#x3D;0) return a; return gcd(b,a%b);&#125;int count &#x3D; 0;int main()&#123; for(int i&#x3D;9;i&gt;&#x3D;1;i--)&#123; for(int j&#x3D;i-1;j&gt;&#x3D;1;j--)&#123; for(int k&#x3D;9;k&gt;&#x3D;1;k--)&#123; for(int z&#x3D;k-1;z&gt;&#x3D;1;z--)&#123; &#x2F;* i&#x2F;j * z&#x2F;k *&#x2F; int x1&#x3D;i*z; int y1&#x3D;j*k; int m&#x3D;gcd(x1,y1); &#x2F;&#x2F;cout&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y1&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl; x1&#x2F;&#x3D;m;y1&#x2F;&#x3D;m; int x2&#x3D;i*10+z; int y2&#x3D;j*10+k; int n&#x3D;gcd(x2,y2); x2&#x2F;&#x3D;n;y2&#x2F;&#x3D;n; if(x1&#x3D;&#x3D;x2&amp;&amp;y1&#x3D;&#x3D;y2) count++; &#125; &#125; &#125; &#125; count*&#x3D;2; cout&lt;&lt;count; return 0;&#125; 7、六角填数​ 答案：10 ​ 思路：全排列所有可填入的情况，填充找到满足6条直线和等值的结果。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std;int main()&#123; &#x2F;* 1 2 3 9 4 5 6 7 8 *&#x2F; int a[9]&#x3D;&#123;2,4,5,6,7,9,10,11,12&#125;; do&#123; int b&#x3D;8+a[0]+a[1]+a[2]; int c&#x3D;8+a[8]+a[5]+3; if(b!&#x3D;c) continue; int d&#x3D;a[2]+a[3]+a[6]+3; if(c!&#x3D;d) continue; int e&#x3D;1+a[0]+a[8]+a[4]; if(d!&#x3D;e) continue; int f&#x3D;1+a[1]+a[3]+a[7]; if(e!&#x3D;f) continue; int g&#x3D;a[4]+a[5]+a[6]+a[7]; if(f!&#x3D;g) continue; cout&lt;&lt;a[8]; &#125;while(next_permutation(a,a+9)); return 0;&#125; 8、蚂蚁感冒​ 思路：蚂蚁碰撞时，两个都将感染，或者不；此时可假设两个蚂蚁并没有回头而是交换了身份继续往原来的方向走（不影响继续感染的结果），由此它们会继续感染与他们反向的所有蚂蚁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt; using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[n]; for(int i&#x3D;0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; if(a[0]&gt;0)&#123; &#x2F;&#x2F;感染源往右 int ans&#x3D;1; for(int i&#x3D;0;i&lt;n;i++)&#123; if(a[i]&lt;0&amp;&amp;-a[i]&gt;a[0])&#123; &#x2F;&#x2F;感染源右边往左走 ans++; &#125; &#125; if(ans!&#x3D;1)&#123; &#x2F;&#x2F;一旦有被感染的往左走，那么感染源左边的往右走的也必将被感染 for(int i&#x3D;0;i&lt;n;i++)&#123; if(a[i]&gt;0&amp;&amp;a[i]&lt;a[0]) ans++; &#125; &#125; cout&lt;&lt;ans; &#125; if(a[0]&lt;0)&#123; &#x2F;&#x2F;感染源往左 int ans&#x3D;1; for(int i&#x3D;0;i&lt;n;i++)&#123; if(a[i]&gt;0&amp;&amp;a[i]&lt;-a[0])&#123; &#x2F;&#x2F;感染源左边边往右走 ans++; &#125; &#125; if(ans!&#x3D;1)&#123; &#x2F;&#x2F;一旦有被感染的往右走，那么感染源右边的往左走的也必将被感染 for(int i&#x3D;0;i&lt;n;i++)&#123; if(a[i]&lt;0&amp;&amp;a[i]&lt;a[0]) ans++; &#125; &#125; cout&lt;&lt;ans; return 0; &#125;&#125;","categories":[],"tags":[]},{"title":"4、IDEA和数组","slug":"4、IDEA和数组","date":"2020-09-23T11:55:09.000Z","updated":"2020-09-23T12:00:11.020Z","comments":true,"path":"2020/09/23/4、IDEA和数组/","link":"","permalink":"http://yoursite.com/2020/09/23/4%E3%80%81IDEA%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"4、IDEA和数组1、IDEA安装和使用1.1、安装​ 官网一键式安装 1.2、使用​ 1、新建project，选择Empty Project，一直next ​ 2、新建Module，注意选择JDK版本 2、数组2.1、初始化​ 1、char [] ch= new char[size]； ​ 2、静态初始化：char [] ch= {变量值}； 2.2、数组内存分配1、一个数组的内存分配 ![1591007817165](D:\\Develop\\1-学习资料\\7月Java基础班\\day04笔记0724\\img\\1591007817165.png)​ 2、两个数组的内存分配","categories":[],"tags":[]},{"title":"3、循环","slug":"3、循环","date":"2020-09-23T01:08:56.533Z","updated":"2020-09-23T12:03:56.246Z","comments":true,"path":"2020/09/23/3、循环/","link":"","permalink":"http://yoursite.com/2020/09/23/3%E3%80%81%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"3、循环1、水仙花数​ 1234567891011121314151617public class ForTest04 &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束 for(int i&#x3D;100; i&lt;1000; i++) &#123; &#x2F;&#x2F;在计算之前获取三位数中每个位上的值 int ge &#x3D; i%10; int shi &#x3D; i&#x2F;10%10; int bai &#x3D; i&#x2F;10&#x2F;10%10; &#x2F;&#x2F;判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等 if(ge*ge*ge + shi*shi*shi + bai*bai*bai &#x3D;&#x3D; i) &#123; &#x2F;&#x2F;输出满足条件的数字就是水仙花数 System.out.println(i); &#125; &#125; &#125;&#125; 2、猜数字12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F;给出随机数的范围，设置猜字次数import java.util.Random;import java.util.Scanner;public class GuessNumber &#123; public static void main(String[] args) &#123; Scanner sc &#x3D; new Scanner(System.in); Random r &#x3D; new Random(); System.out.println(&quot;本次产生的随机数范围在1~100&quot;); int number &#x3D; r.nextInt(100)+1; System.out.println(&quot;请输入你要猜的次数：&quot;); int times &#x3D; sc.nextInt(); while (times &gt;&#x3D; 0) &#123; System.out.println(&quot;请给出你的结果：&quot;); int now &#x3D; sc.nextInt(); if(now &#x3D;&#x3D; number) &#123; System.out.println(&quot;恭喜你猜对了！&quot;); break; &#125;else if(now&gt;number)&#123; System.out.print(&quot;您猜大了！&quot;); &#125;else &#123; System.out.print(&quot;您猜小了！&quot;); &#125; times--; if(times &#x3D;&#x3D; 0) &#123; System.out.println(&quot;机会已用完，game over!&quot;); break; &#125;else &#123; System.out.println(&quot;还有&quot;+times+&quot;次机会&quot;); &#125; &#125; &#125;&#125; 3、产生范围内的随机数1234567891011121314151617181920212223242526272829303132import java.util.Random;public class getRandom() &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;随机生成10个1-20间不重复的整数 int [] a&#x3D;new int[10]; Random r &#x3D; new Random(); int count&#x3D;10; while(count&gt;0) &#123; int number &#x3D; r.nextInt(14)+5; for(int i&#x3D;0;i&lt;a.length;i++) &#123; if(a[i]&gt;0&amp;&amp;number&#x3D;&#x3D;a[i]) &#123; &#x2F;&#x2F;重复 break; &#125;else if(a[i]&gt;0&amp;&amp;number!&#x3D;a[i]) &#123; &#x2F;&#x2F;找到写入位置 continue; &#125;else &#123; &#x2F;&#x2F;写入数据 a[i]&#x3D;number; count--; break; &#125; &#125; &#125; for(int i&#x3D;0;i&lt;a.length;i++) &#123; System.out.println(a[i]); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"2、运算符","slug":"2、运算符","date":"2020-09-22T16:30:30.000Z","updated":"2020-09-22T16:34:36.626Z","comments":true,"path":"2020/09/23/2、运算符/","link":"","permalink":"http://yoursite.com/2020/09/23/2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"2、运算符1、算术运算符​ +、-、*、/、% 2、比较运算符​ &gt;、&lt;、&gt;=、&lt;=、== 3、逻辑运算符​ &amp;&amp;、||、!、(&amp;、| 短路) 4、其他运算符​ ++、–、=、? : 4、优先级​ 算术&gt;逻辑&gt;比较&gt;赋值 5、隐式转换​ 整型数据类型：小转大","categories":[],"tags":[]},{"title":"1、Java概述","slug":"1、Java概述","date":"2020-09-22T13:09:36.000Z","updated":"2020-09-22T16:34:13.712Z","comments":true,"path":"2020/09/22/1、Java概述/","link":"","permalink":"http://yoursite.com/2020/09/22/1%E3%80%81Java%E6%A6%82%E8%BF%B0/","excerpt":"","text":"1、Java环境搭建及入门1、Java发展历程​ 2014年jdk8上线，成为目前公司主要在使用的一款稳定版；2019年更新为jdk11。 2、jvm​ jvm（java virtual method）全名java虚拟机，能够将java代码编译到不同的操作系统形成可执行的class文件。 3、jre​ jre（java runtime environment）是java程序代码必不可少的运行环境,内含jvm和核心类库。 4、jdk​ jdk=（jre（jvm+核心类库）+工具集） 5、环境搭建​ 1、下载好jdk版本，并在电脑-&gt;属性-&gt;系统设置-&gt;环境变量-&gt;系统变量-&gt;新建系统变量-&gt;变量名：JAVA_HOME 变量值：jdk安装目录；在path变量下添加：%JAVA_HOME%\\bin。 6、基本语法123public static void main(String marg)&#123; System.out.println(&quot;Hello world!&quot;);&#125; 7、常用Dos命令​ 1、进入：cd..（回退） ​ 2、连接：ping + 主机ip 8、基础语法​ 1、注释：单行// 多行/* */ ​ 2、变量名： ​ 规则： ​ 不以数字、下划线、$符号开头，不能取关键字 ​ 规范： ​ 类名：大驼峰 方法名：小驼峰 ​ 3、数据类型： ​ byte、short、int、long、Double、char、String、Boolean","categories":[],"tags":[]},{"title":"PAT乙级1025","slug":"PAT乙级1025","date":"2020-02-15T15:48:25.000Z","updated":"2020-02-15T15:48:25.347Z","comments":true,"path":"2020/02/15/PAT乙级1025/","link":"","permalink":"http://yoursite.com/2020/02/15/PAT%E4%B9%99%E7%BA%A71025/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"广度优先搜索","slug":"广度优先搜索","date":"2020-02-12T14:40:52.000Z","updated":"2020-02-12T14:41:58.803Z","comments":true,"path":"2020/02/12/广度优先搜索/","link":"","permalink":"http://yoursite.com/2020/02/12/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std; /int N,K; //抓住这头牛const int MAXN=100000;int visited[MAXN+10];struct Step{ int x; int steps; Step(int xx,int s):x(xx),steps(s){ }};queue q;/ int main(){ /cin&gt;&gt;N&gt;&gt;K; memset(visited,0,sizeof(visited)); q.push(Step(N,0)); visited[N]=1; while(!q.empty()){ Step s=q.front(); if(s.x==K){ cout&lt;&lt;s.steps&lt;&lt;endl; return 0; }else{ if(s.x&gt;=0&amp;&amp;!visited[s.x-1]){ q.push(Step(s.x-1,s.steps+1)); visited[s.x-1]=1; } if(s.x+1&lt;=MAXN&amp;&amp;!visited[s.x+1]){ q.push(Step(s.x+1,s.steps+1)); visited[s.x+1]=1; } if(s.x2&lt;=MAXN&amp;&amp;!visited[s.x2]){ q.push(Step(s.x2,s.steps+1)); visited[s.x2]=1; } q.pop(); } }/ return 0;}","categories":[],"tags":[]},{"title":"贪心","slug":"贪心","date":"2020-02-11T07:34:19.000Z","updated":"2020-02-11T07:35:55.861Z","comments":true,"path":"2020/02/11/贪心/","link":"","permalink":"http://yoursite.com/2020/02/11/%E8%B4%AA%E5%BF%83/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std; /const double eps=1e-6; //圣诞老人的礼物struct Candy{ int v; int w; bool operator &lt; (const Candy &amp; c){ return double(v)/w-double(c.v)/c.w&gt;eps; }}candies[110];/ struct Cow{ //分配畜栏 int a,b; int No; bool operator &lt; (const Cow &amp;c) const{ return a&lt;c.a; };}cows[50100];int pos[50100];struct Stall{ int end; int No; bool operator&lt;(const Stall &amp;s) const{ return end&gt;s.end; } Stall(int e,int n):end(e),No(n){ }}; int main(){ /int n,w; scanf(“%d%d”,&amp;n,&amp;w); for(int i=0;i&lt;n;i++){ scanf(“%d%d”,&amp;candies[i].v,&amp;candies[i].w); } sort(candies,candies+n); int totalW=0; double totalV=0; for(int i=0;i&lt;n;i++){ if(totalW+candies[i].w&lt;=w){ totalW+=candies[i].w; totalV+=candies[i].v; }else{ totalV+=candies[i].v*double(w-totalW)/candies[i].w; break; } } printf(“%.1f”,totalV);/ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;++i){ scanf(&quot;%d%d&quot;,&amp;cows[i].a,&amp;cows[i].b); cows[i].No=i; } sort(cows,cows+n); int total=0; priority_queue&lt;Stall&gt; pq; for(int i=0;i&lt;n;++i){ if(pq.empty()){ ++total; pq.push(Stall(cows[i].b,total)); pos[cows[i].No]=total; }else{ Stall st=pq.top(); if(st.end&lt;cows[i].a){ pq.pop(); pos[cows[i].No]=st.No; pq.push(Stall(cows[i].b,st.No)); }else{ ++total; pq.push(Stall(cows[i].b,total)); pos[cows[i].No]=total; } } } printf(&quot;%d\\n&quot;,total); for(int i=0;i&lt;n;i++){ printf(&quot;%d\\n&quot;,pos[i]); } return 0;}","categories":[],"tags":[]},{"title":"动态规划","slug":"动态规划","date":"2020-02-10T11:54:26.000Z","updated":"2020-02-10T11:55:04.676Z","comments":true,"path":"2020/02/10/动态规划/","link":"","permalink":"http://yoursite.com/2020/02/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std; /const int MAXN=1010; //最长上升子序列int a[MAXN];int maxLen[MAXN];/ char sz1[1000]; //最长公共子序列char sz2[1000];int maxLen[1000][1000]; int main(){ /int N; cin&gt;&gt;N; for(int i=1;i&lt;=N;i++){ cin&gt;&gt;a[i]; maxLen[i]=1; } for(int i=2;i&lt;=N;i++){ for(int j=1;j&lt;i;j++){ if(a[i]&gt;a[j]) maxLen[i]=max(maxLen[i],maxLen[j]+1); } } cout&lt;&lt;*max_element(maxLen+1,maxLen+N+1);/ while(cin&gt;&gt;sz1&gt;&gt;sz2){ int length1=strlen(sz1); int length2=strlen(sz2); int nTmp; int i,j; for(i=0;i&lt;=length1;i++) maxLen[i][0]=0; for(j=0;j&lt;=length2;j++) maxLen[0][j]=0; for(i=1;i&lt;=length1;i++){ for(j=1;j&lt;=length2;j++){ if(sz1[i-1]==sz2[j-1]) maxLen[i][j]=maxLen[i-1][j-1]+1; else maxLen[i][j]=max(maxLen[i][j-1],maxLen[i-1][j]); } } cout&lt;&lt;maxLen[length1][length2]&lt;&lt;endl; } return 0;}","categories":[],"tags":[]},{"title":"深度优先搜索","slug":"深度优先搜索","date":"2020-02-09T14:07:52.000Z","updated":"2020-02-09T14:08:11.093Z","comments":true,"path":"2020/02/09/深度优先搜索/","link":"","permalink":"http://yoursite.com/2020/02/09/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std;/*int R,C; //城堡问题int rooms[60][60];int color[60][60];int maxRoomArea=0,roomNum=0;int roomArea;void Dfs(int i,int k){ if(color[i][k]) return; ++roomArea; color[i][k]=roomNum; if((rooms[i][k]&amp;1)==0) Dfs(i,k-1); if((rooms[i][k]&amp;2)==0) Dfs(i-1,k); if((rooms[i][k]&amp;4)==0) Dfs(i,k+1); if((rooms[i][k]&amp;8)==0) Dfs(i+1,k);} int visited[30][50]; //采方格int ways(int i,int j,int n){ if(n==0) return 1; visited[i][j]=1; int num=0; if(!visited[i][j-1]) num+=ways(i,j-1,n-1); if(!visited[i][j+1]) num+=ways(i,j+1,n-1); if(!visited[i+1][j]) num+=ways(i+1,j,n-1); visited[i][j]=0; return num;} int k,n,r; //寻路问题struct Road{ int d,L,t;};vector&lt; vector &gt; G(110);int minL[110][10010];int minLen;int totalLen;int totalCost;int visited[110]; void dfs(int s){ if(s==n){ minLen=min(minLen,totalLen); return; } for(int i=0;i&lt;G[s].size();++i){ Road r=G[s][i]; if(totalCost+r.t&gt;k) continue; if(!visited[r.d]){ if(totalLen+r.L&gt;=minLen) continue; if(totalLen+r.L&gt;=minL[r.d][totalCost+r.t]) continue; minL[r.d][totalCost+r.t]=totalLen+r.L; totalLen+=r.L; totalCost+=r.t; visited[r.d]=1; dfs(r.d); totalLen-=r.L; totalCost-=r.t; visited[r.d]=0; } }}*/ int N,M; //生日蛋糕int minArea=1&lt;&lt;30;int area=0; void Dfs(int v,int n,int r,int h){ if(n==0){ if(v) return ; else{ minArea=min(minArea,area); return; } } if(v&lt;=0) return; for(int rr=r;rr&gt;=n;–rr){ if(n==M) area=rrrr; for(int hh=h;hh&gt;=n;–hh){ area+=2rrhh; Dfs(v-rrrrhh,n-1,rr-1,hh-1); area-=2rr*hh; } }} int main(){ /cin&gt;&gt;R&gt;&gt;C; for(int i=1;i&lt;=R;i++){ for(int k=1;k&lt;=C;k++){ cin&gt;&gt;rooms[i][k]; } } memset(color,0,sizeof(color)); for(int i=1;i&lt;=R;i++){ for(int k=1;k&lt;=C;k++){ if(!color[i][k]){ ++roomNum; roomArea=0; Dfs(i,k); maxRoomArea=max(roomArea,maxRoomArea); } } } cout&lt;&lt;roomNum&lt;&lt;endl&lt;&lt;maxRoomArea&lt;&lt;endl;/ /*int n; cin&gt;&gt;n; memset(visited,0,sizeof(visited)); cout&lt;&lt;ways(0,25,n); cin&gt;&gt;k&gt;&gt;n&gt;&gt;r; for(int i=0;i&lt;r;i++){ int s; Road r; cin&gt;&gt;s&gt;&gt;r.d&gt;&gt;r.L&gt;&gt;r.t; if(s!=r.d){ G[s].push_back(r); } } memset(visited,0,sizeof(visited)); totalLen=0; minLen=1&lt;&lt;30; totalCost=0; visited[1]=1; for(int i=0;i&lt;110;i++){ for(int j=0;j&lt;10010;j++){ minL[i][j]=1&lt;&lt;30; } } dfs(1); if(minLen&lt;(1&lt;&lt;30)){ cout&lt;&lt;minLen&lt;&lt;endl; }else{ cout&lt;&lt;-1&lt;&lt;endl; }*/ int maxR=5,maxH=100; cin&gt;&gt;N&gt;&gt;M; Dfs(N,M,maxR,maxH); if(minArea==1&lt;&lt;30) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;minArea&lt;&lt;endl; return 0;}","categories":[],"tags":[]},{"title":"分治再探","slug":"分治再探","date":"2020-02-08T15:45:45.000Z","updated":"2020-02-08T15:54:00.706Z","comments":true,"path":"2020/02/08/分治再探/","link":"","permalink":"http://yoursite.com/2020/02/08/%E5%88%86%E6%B2%BB%E5%86%8D%E6%8E%A2/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std;#define MAX 101int D[MAX][MAX]={0};int n;int maxsum[MAX][MAX];int MaxSum(int i,int j){ if(maxsum[i][j]!=-1) return maxsum[i][j]; if(i==n) maxsum[i][j]=D[i][j]; else{ int x=MaxSum(i+1,j); int y=MaxSum(i+1,j+1); maxsum[i][j]=max(x,y)+D[i][j]; } return maxsum[i][j];}int main(){ int i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ for(j=1;j&lt;=i;j++){ cin&gt;&gt;D[i][j]; maxsum[i][j]=-1; } } cout&lt;&lt;MaxSum(1,1)&lt;&lt;endl; return 0;}","categories":[],"tags":[]},{"title":"递归和分治","slug":"递归和分治","date":"2020-02-07T15:10:35.000Z","updated":"2020-02-07T15:50:52.451Z","comments":true,"path":"2020/02/07/递归和分治/","link":"","permalink":"http://yoursite.com/2020/02/07/%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std;void Swap(int &amp;a,int &amp;b){ int temp=0; temp=a; a=b; b=temp;} void Hanoi(int n,char src,char mid,char dest){ //汉诺塔问题 if(n==1){ cout&lt;&lt;src&lt;&lt;”-&gt;”&lt;&lt;dest&lt;&lt;endl; return; } Hanoi(n-1,src,dest,mid); cout&lt;&lt;src&lt;&lt;”-&gt;”&lt;&lt;dest&lt;&lt;endl; Hanoi(n-1,mid,src,dest);} int N;int queenPos[100];void NQueen(int k){ //N皇后 if(k==N){ for(int i=0;i&lt;N;i++){ cout&lt;&lt;queenPos[i]+1&lt;&lt;’ ‘; } cout&lt;&lt;endl; return; } for(int i=0;i&lt;N;i++){ int j; for(j=0;j&lt;k;j++){ if(queenPos[j]==i||abs(queenPos[j]-i)==abs(k-j)){ break; } } if(j==k){ queenPos[k]=i; NQueen(k+1); } }} double exp(){ //逆波兰式 char s[20]; cin&gt;&gt;s; switch(s[0]){ case ‘+’: return exp()+exp(); case ‘-‘: return exp()-exp(); case ‘‘: return exp()exp(); case ‘/‘: return exp()/exp(); default: return atof(s); break; }} int expression_value(){ //表达式的值 int term_value(); int result=term_value(); bool more=true; while(more){ char op=cin.peek(); if(op==’+’||op==’-‘){ cin.get(); int value=term_value(); if(op==’+’) result+=value; else result-=value; } else more=false; } return result;}int term_value(){ int factor_value(); int result=factor_value(); while(true){ char op=cin.peek(); if(op==’‘||op==’/‘){ cin.get(); int value=factor_value(); if(op==’‘) result*=value; else result/=value; } else break; } return result; }int factor_value(){ int result=0; char c=cin.peek(); if(c==’(‘){ cin.get(); result=expression_value(); cin.get(); }else{ while(isdigit(c)){ result=10*result+c-‘0’; cin.get(); c=cin.peek(); } } return result;} bool HuiWen(string s){ //回文串判断,小写输入 int h=0,t=s.size()-1; while(h&lt;=t){ if(s[h]!=s[t]) return 0; h++;t–; } return 1;} void QuanPai(int a[],int k,int n){ //全排列 if(n==k){ for(int i=1;i&lt;=n;i++){ cout&lt;&lt;a[i]&lt;&lt;’ ‘; } cout&lt;&lt;endl; }else{ for(int i=k;i&lt;n+1;i++){ Swap(a[k],a[i]); QuanPai(a,k+1,n); Swap(a[k],a[i]); } } } int main(){ //递归 /*char a=&apos;A&apos;,b=&apos;B&apos;,c=&apos;C&apos;; int n=0; cin&gt;&gt;n; Hanoi(n,a,b,c);*/ /*cin&gt;&gt;N; NQueen(0);*/ //cout&lt;&lt;exp()&lt;&lt;endl; //cout&lt;&lt;expression_value()&lt;&lt;endl; //分治 /*string s; int flag=-1; cin&gt;&gt;s; flag=HuiWen(s); cout&lt;&lt;&quot;回文串:&quot;&lt;&lt;flag&lt;&lt;endl; */ /*int *a,len; cout&lt;&lt;&quot;len:&quot;&lt;&lt;endl; cin&gt;&gt;len; a=new int[len+1]; for(int i=1;i&lt;len+1;i++){ a[i]=i; } QuanPai(a,1,len);*/ return 0;}","categories":[],"tags":[]},{"title":"STL实践","slug":"STL实践","date":"2020-02-06T15:39:45.000Z","updated":"2020-02-06T17:54:54.461Z","comments":true,"path":"2020/02/06/STL实践/","link":"","permalink":"http://yoursite.com/2020/02/06/STL%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"#include #include#include#include#include#include#include#include#includeusing namespace std;struct Student{ int a,b; bool operator &lt; (const Student &amp;rs) const{ if(a==rs.a) return b&lt;rs.b; return a&lt;rs.a; }}; int main(){ priority_queue q; deque ::const_iterator i; set ::const_iterator j; map &lt;int,char&gt;::iterator k; vector v; deque d; map&lt;int,char&gt; m; set s; s.insert(5);s.insert(8);s.insert(1);s.insert(3);s.insert(3); m.insert(pair&lt;int,char&gt;(1,’a’)); m.insert(pair&lt;int,char&gt;(2,’a’)); m.insert(pair&lt;int,char&gt;(3,’c’)); m.insert(pair&lt;int,char&gt;(4,’d’)); /m.insert(map&lt;int,char&gt;::value_type(1,’a’)); m.insert(map&lt;int,char&gt;::value_type(1,’b’)); m.insert(map&lt;int,char&gt;::value_type(3,’c’)); m.insert(map&lt;int,char&gt;::value_type(4,’d’));/ for(k=m.begin();k!=m.end();k++){ cout&lt;&lt;1&lt;&lt;’ ‘; } cout &lt;&lt;endl; for(int i=0;i&lt;10;i++){ v.push_back(i); d.push_front(i); } for(i=d.begin();i&lt;d.end();i++){ cout&lt;&lt;i&lt;&lt;’ ‘; } cout &lt;&lt;endl; for(j=s.begin();j!=s.end();j++){ cout&lt;&lt;j&lt;&lt;’ ‘; } cout &lt;&lt;endl; for(int i=0;i&lt;10;i++){ q.push(i); } while(q.size()){ cout&lt;&lt;q.top()&lt;&lt;&apos; &apos;; q.pop(); } cout &lt;&lt;endl; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q_; for(int i=0;i&lt;10;i++){ q_.push(i); } while(q_.size()){ cout&lt;&lt;q_.top()&lt;&lt;&apos; &apos;; q_.pop(); } cout &lt;&lt;endl; Student student[5]={{5,5},{5,4},{3,1},{2,2},{2,1}}; sort(student,student+5); for(int i=0;i&lt;5;i++){ cout&lt;&lt;student[i].a&lt;&lt;&apos; &apos;&lt;&lt;student[i].b&lt;&lt;endl; } priority_queue &lt;Student&gt; qq; for(int i=0;i&lt;5;i++){ qq.push(student[i]); } while(qq.size()){ Student now=qq.top(); cout&lt;&lt;now.a&lt;&lt;&apos; &apos;&lt;&lt;now.b&lt;&lt;endl; qq.pop(); } cout &lt;&lt;endl; return 0;}","categories":[],"tags":[]},{"title":"图的遍历","slug":"图的遍历","date":"2020-02-05T14:42:29.000Z","updated":"2020-02-05T14:45:27.662Z","comments":true,"path":"2020/02/05/图的遍历/","link":"","permalink":"http://yoursite.com/2020/02/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"","text":"邻接表存储DFSvoid Visit(Vertex v){ printf(“%d\\n”,v);}void DFS(LGraph Graph,Vertex v,void (*Visit)(Vertex)){ ProToAdjVNode W; Visit(v); Visited[v]=true; for(W=Graph-&gt;G[v].FitstEdge;W;W=W-&gt;Next){ if(!Visited[W-&gt;Adjv]){ DFS(Graph,W-&gt;Adjv,Visit); } }} 邻接矩阵存储BFSvoid Visit(Vertex v){ printf(“正在访问的顶点%d\\n”,v);}bool IsEdge(MGraph Graph,Vertex v,Vertex w){ return Graph-&gt;G[v][w]&lt;INFNITY?true:false;}void BFS(MGraph Graph,Vertex S,void(*Visit)(Vertex)){ queue Q; Vertex V,W; Visit(S); Visited[S]=true; Q.push(S); while(!Q.empty()){ V=Q.front();Q.pop(); for(W=0;WNv;W++){ if(!Visited[W]&amp;&amp;IsEdge(Graph,V,W)){ Visit(W); Visited[W]=true; Q.push(W); } } }}","categories":[],"tags":[]},{"title":"图的两种表示法","slug":"图的两种表示法","date":"2020-02-04T14:38:09.000Z","updated":"2020-02-04T14:38:32.857Z","comments":true,"path":"2020/02/04/图的两种表示法/","link":"","permalink":"http://yoursite.com/2020/02/04/%E5%9B%BE%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%B3%95/","excerpt":"","text":"邻接矩阵表示:#include#include#define MaxVertexNum 100#define INFNITY 65535using namespace std;typedef int Vertex;typedef int WeightType;typedef char DataType; typedef struct ENode{ Vertex v1,v2; WeightType Weight;}*PtrToENode;typedef PtrToENode Edge; typedef struct GNode{ int Nv,Ne; WeightType G[MaxVertexNum][MaxVertexNum]; DataType Data[MaxVertexNum];}*PtrToMNode;typedef PtrToMNode MGraph; MGraph CreateGraph(int VertexNum){ Vertex v,w; MGraph Graph; Graph=(MGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv=VertexNum; Graph-&gt;Ne=0; for(v=0;vNv;v++){ for(w=0;wNv;w++){ Graph-&gt;G[v][w]=INFNITY; } } return Graph;}void InsertEdge(MGraph Graph,Edge E){ Graph-&gt;G[E-&gt;v1][E-&gt;v2]=E-&gt;Weight; Graph-&gt;G[E-&gt;v2][E-&gt;v1]=E-&gt;Weight;}MGraph BuildGraph(){ MGraph Graph; Edge E; Vertex v; int Nv,i; scanf(“%d”,&amp;Nv); Graph=CreateGraph(Nv); scanf(“%d”,&amp;(Graph-&gt;Ne)); if(Graph-&gt;Ne!=0){ E=(Edge)malloc(sizeof(struct ENode)); for(i=0;iNe;i++){ scanf(“%d%d%d”,&amp;E-&gt;v1,&amp;E-&gt;v2,&amp;E-&gt;Weight); InsertEdge(Graph,E); } } for(v=0;vNv;v++){ scanf(“ %c”,&amp;(Graph-&gt;Data[v])); } return Graph;}int main(){ MGraph Graph; Graph=BuildGraph(); int n=0; int v=-1; printf(“请输入你要查询的顶点编号:”); scanf(“%d”,&amp;v); printf(“你查询的顶点%c的邻接点:\\n”,Graph-&gt;Data[v]); for(n=0;nNv;n++){ if(Graph-&gt;G[v][n]&lt;INFNITY&amp;&amp;Graph-&gt;G[v][n]&gt;0){ printf(“%c “,Graph-&gt;Data[n]); } } printf(“\\n”); for(int i=0;iNv;i++){ for(int j=0;jNv;j++){ printf(“%d “,Graph-&gt;G[i][j]); } printf(“\\n”); } /* 5 5 0 1 2 0 3 10 0 4 13 1 2 4 2 4 9 a e d c b */ return 0;} 邻接表表示#include#includeusing namespace std; #define MaxVertexNum 100typedef int Vertex;typedef int WeightType;typedef char DataType; typedef struct ENode{ Vertex v1,v2; WeightType Weight;}*PtrToENode;typedef PtrToENode Edge; typedef struct AdjVNode{ Vertex Adjv; WeightType Weight; AdjVNode Next;}ProToAdjVNode; typedef struct VNode{ ProToAdjVNode FitstEdge; DataType Data;}AdjList[MaxVertexNum]; typedef struct GNode{ int Nv; int Ne; AdjList G;}*PtrToGNode;typedef PtrToGNode LGraph; LGraph CreateGraph(int VertexNum){ Vertex v; LGraph Graph; Graph=(LGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv=VertexNum; Graph-&gt;Ne=0; for(v=0;vNv;v++){ Graph-&gt;G[v].FitstEdge=NULL; } return Graph;} void InsertEdge(LGraph Graph,Edge E){ ProToAdjVNode NewNode; NewNode=(ProToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;Adjv=E-&gt;v2; NewNode-&gt;Weight=E-&gt;Weight; NewNode-&gt;Next=Graph-&gt;G[E-&gt;v2].FitstEdge; Graph-&gt;G[E-&gt;v1].FitstEdge=NewNode; NewNode=(ProToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;Adjv=E-&gt;v1; NewNode-&gt;Weight=E-&gt;Weight; NewNode-&gt;Next=Graph-&gt;G[E-&gt;v2].FitstEdge; Graph-&gt;G[E-&gt;v2].FitstEdge=NewNode;}LGraph BuildGraph(){ LGraph Graph; Edge E; Vertex v; int Nv,i; scanf(“%d”,&amp;Nv); Graph=CreateGraph(Nv); scanf(“%d”,&amp;(Graph-&gt;Ne)); if(Graph-&gt;Ne!=0){ E=(Edge)malloc(sizeof(ENode)); for(i=0;iNe;i++){ scanf(“%d %d %d”,&amp;E-&gt;v1,&amp;E-&gt;v2,&amp;E-&gt;Weight); InsertEdge(Graph,E); } } for(v=0;vNv;v++){ scanf(“ %c”,&amp;(Graph-&gt;G[v].Data)); } return Graph;}int main(){ LGraph Graph; Graph=BuildGraph(); int n=0; int v=-1; printf(“请输入你要查询的顶点编号:”); scanf(“%d”,&amp;v); printf(“你查询的顶点%c的邻接点:”,Graph-&gt;G[v].Data); AdjVNode M; M=Graph-&gt;G[v].FitstEdge; while(M!=NULL){ printf(“%c “,Graph-&gt;G[M-&gt;Adjv].Data); M=M-&gt;Next; } printf(“\\n”); / 5 5 1 0 2 3 0 10 4 0 13 2 1 4 4 2 9 a e d c b */ return 0;}","categories":[],"tags":[]},{"title":"栈队列二叉树的简单实现","slug":"静态栈和队列以及二叉树","date":"2020-02-03T13:03:14.000Z","updated":"2020-02-03T13:24:29.597Z","comments":true,"path":"2020/02/03/静态栈和队列以及二叉树/","link":"","permalink":"http://yoursite.com/2020/02/03/%E9%9D%99%E6%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"#include#includeusing namespace std;typedef char Elemtype;typedef struct BiTNode{ Elemtype data; BiTNode lchild,rchild;}BiTNode,BiTree;int CreatBiTree(BiTree &amp;T){ //建立二叉树 Elemtype ch; cin&gt;&gt;ch; if(ch==’#’) T=NULL; else{ T=(BiTNode)malloc(sizeof(BiTNode)); T-&gt;data=ch; CreatBiTree(T-&gt;lchild); CreatBiTree(T-&gt;rchild); } return 0;}void PreOrder(BiTree &amp;T){ if(T!=NULL){ cout&lt;data&lt;&lt;endl; PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); }}void InOrder(BiTree &amp;T){ if(T!=NULL){ InOrder(T-&gt;lchild); cout&lt;data&lt;&lt;endl; InOrder(T-&gt;rchild); }}void PostOrder(BiTree &amp;T){ if(T!=NULL){ PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); cout&lt;data&lt;&lt;endl; }} int main(){ BiTree T; CreatBiTree(T); printf(“先序遍历:\\n”); // a PreOrder(T); // b c printf(“中序遍历:\\n”); //d e InOrder(T); // f g printf(“后序遍历:\\n”); PostOrder(T); return 0;}","categories":[],"tags":[]},{"title":"数据结构几种排序的简单实现","slug":"数据结构内部排序简单实现","date":"2020-02-02T15:16:58.000Z","updated":"2020-02-02T15:46:04.696Z","comments":true,"path":"2020/02/02/数据结构内部排序简单实现/","link":"","permalink":"http://yoursite.com/2020/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"源代码如下,亲测可用(基于c语言)#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void swap(int a,int *b){ //交换 int temp; temp=a; a=b; *b=temp;}//直接插入排序void Insert(int a[],int n){ int i=0,j=0,k=0,temp=0; for(i=1;i&lt;n;i++){ for(j=0;j&lt;i;j++){ if(a[i]&lt;a[j]){ temp=a[i]; for(k=i-1;k&gt;=j;k–){ a[k+1]=a[k]; } a[j]=temp; } } }}//希尔排序void Shell(int a[],int n){ int D=5,Dk=0,i=0,j=0,k=0,temp=0; for(D=5;D&gt;=1;D/=2){ //增量 for(Dk=0;Dk&lt;D;Dk++){ //执行增量排序次数 for(i=Dk+D;i&lt;n;i+=D){ //基于增量的直接插入排序 for(j=Dk;j&lt;i;j+=D){ if(a[i]&lt;a[j]){ temp=a[i]; for(k=i-D;k&gt;=j;k-=D){ a[k+D]=a[k]; } a[j]=temp; } } } } }}//简单选择排序void Select(int a[],int n){ int i=0,j=0,min=-1,minIndex,temp=0; for(i=0;i&lt;n-1;i++){ min=a[i]; for(j=i;j&lt;n;j++){ //找出最小元素的下标 if(a[j]&lt;min){ min=a[j]; minIndex=j; } } swap(a+i,a+minIndex); }}//冒泡排序void Bubble(int a[],int n){ int i=0,j=0,temp=0; for(i=n-1;i&gt;0;i–){ for(j=0;j&lt;i;j++){ if(a[j]&gt;a[j+1]){ swap(a+j,a+j+1); } } }}//快速排序void Quick(int a[],int low,int high){ if(low&gt;high) return; int L=low,R=high,pivot=a[low]; while(L&lt;R){ while(L&lt;R&amp;&amp;a[R]&gt;=pivot){ //从右边开始找到比枢纽小的值移到左边 R–; } if(L&lt;R){ a[L]=a[R]; L++; } while(L&lt;R&amp;&amp;a[L]&lt;pivot){ //从左边开始找到比枢纽小的值移到右边 L++; } if(L&lt;R){ a[R]=a[L]; R–; } } Quick(a,low,L-1); Quick(a,L+1,high); }int main(){ int begin=0,end=0; int i=0,a[100]={0}; for(i=0;i&lt;100;i++){ a[i]=rand()%1000; } //Insert(a,100); //Bubble(a,100); //Select(a,100); //Shell(a,100); Quick(a,0,99); for(i=1;i&lt;=100;i++){ printf(“%d “,a[i-1]); if(i%10==0) printf(“\\n”); } return 0;}","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2020-02-01T13:05:40.000Z","updated":"2020-02-01T13:35:05.766Z","comments":true,"path":"2020/02/01/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/02/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"万事开头难–坚持 大四即将工作的老学长即日起更新博客. 励志做一名中级程序员 qaq~~ 座右铭: 我赚钱养家,你拿去花.","categories":[],"tags":[]}],"categories":[],"tags":[]}