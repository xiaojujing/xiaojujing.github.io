{"meta":{"title":"Hexo","subtitle":"","description":"","author":"xiaojujing","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"8_API","slug":"8_API","date":"2020-11-04T14:41:55.500Z","updated":"2020-11-04T14:42:15.237Z","comments":true,"path":"2020/11/04/8_API/","link":"","permalink":"http://yoursite.com/2020/11/04/8_API/","excerpt":"1.API1.1 API概述-帮助文档的使用 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API","text":"1.API1.1 API概述-帮助文档的使用 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API ​ 指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。 如何使用API帮助文档 : 打开帮助文档 找到索引选项卡中的输入框 在输入框中输入Random 看类在哪个包下 看类的描述 看构造方法 看成员方法 1.2 键盘录入字符串Scanner类 : ​ next() : 遇到了空格, 就不再录入数据了 , 结束标记: 空格, tab键 ​ nextLine() : 可以将数据完整的接收过来 , 结束标记: 回车换行符 代码实现 : 12345678910111213141516171819202122232425package com.itheima.api;import java.util.Scanner;public class Demo1Scanner &#123; /* next() : 遇到了空格, 就不再录入数据了 结束标记: 空格, tab键 nextLine() : 可以将数据完整的接收过来 结束标记: 回车换行符 */ public static void main(String[] args) &#123; // 1. 创建Scanner对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); // 2. 调用nextLine方法接收字符串 // ctrl + alt + v : 快速生成方法的返回值 String s = sc.nextLine(); System.out.println(s); &#125;&#125; 12345678910111213141516171819202122package com.itheima.api;import java.util.Scanner;public class Demo2Scanner &#123; /* nextInt和nextLine方法配合使用的时候, nextLine方法就没有键盘录入的机会了 建议: 今后键盘录入数据的时候, 如果是字符串和整数一起接受, 建议使用next方法接受字符串. */ public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入整数:\"); int num = sc.nextInt(); // 10 + 回车换行 System.out.println(\"请输入字符串:\"); String s = sc.nextLine(); System.out.println(num); System.out.println(s); &#125;&#125; 2. String类2.1 String概述​ 1 String 类在 java.lang 包下，所以使用的时候不需要导包 ​ 2 String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象 ​ 3 字符串不可变，它们的值在创建后不能被更改 2.2 String类的构造方法常用的构造方法 示例代码 1234567891011121314151617181920212223242526272829303132package com.itheima.string;public class Demo2StringConstructor &#123; /* String类常见构造方法: public String() : 创建一个空白字符串对象，不含有任何内容 public String(char[] chs) : 根据字符数组的内容，来创建字符串对象 public String(String original) : 根据传入的字符串内容，来创建字符串对象 String s = “abc”; 直接赋值的方式创建字符串对象，内容就是abc 注意: String这个类比较特殊, 打印其对象名的时候, 不会出现内存地址 而是该对象所记录的真实内容. 面向对象-继承, Object类 */ public static void main(String[] args) &#123; // public String() : 创建一个空白字符串对象，不含有任何内容 String s1 = new String(); System.out.println(s1); // public String(char[] chs) : 根据字符数组的内容，来创建字符串对象 char[] chs = &#123;'a','b','c'&#125;; String s2 = new String(chs); System.out.println(s2); // public String(String original) : 根据传入的字符串内容，来创建字符串对象 String s3 = new String(\"123\"); System.out.println(s3); &#125;&#125; 2.4 创建字符串对象的区别对比 通过构造方法创建 ​ 通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同 直接赋值方式创建 ​ 以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护 2.5 字符串的比较2.5.1 字符串的比较 == 比较基本数据类型：比较的是具体的值 == 比较引用数据类型：比较的是对象地址值 String类 : public boolean equals(String s) 比较两个字符串内容是否相同、区分大小写 代码 : 12345678910111213141516package com.itheima.stringmethod;public class Demo1Equals &#123; public static void main(String[] args) &#123; String s1 = \"abc\"; String s2 = \"ABC\"; String s3 = \"abc\"; // equals : 比较字符串内容, 区分大小写 System.out.println(s1.equals(s2)); System.out.println(s1.equals(s3)); // equalsIgnoreCase : 比较字符串内容, 忽略大小写 System.out.println(s1.equalsIgnoreCase(s2)); &#125;&#125; 2.6 用户登录案例【应用】案例需求 : ​ 已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示 *实现步骤 : * 已知用户名和密码，定义两个字符串表示即可 键盘录入要登录的用户名和密码，用 Scanner 实现 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。 字符串的内容比较，用equals() 方法实现 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循 代码实现 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.itheima.test;import java.util.Scanner;public class Test1 &#123; /* 需求：已知用户名和密码，请用程序实现模拟用户登录。 总共给三次机会，登录之后，给出相应的提示 思路： 1. 已知用户名和密码，定义两个字符串表示即可 2. 键盘录入要登录的用户名和密码，用 Scanner 实现 3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。 字符串的内容比较，用equals() 方法实现 4. 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环 */ public static void main(String[] args) &#123; // 1. 已知用户名和密码，定义两个字符串表示即可 String username = \"admin\"; String password = \"123456\"; // 2. 键盘录入要登录的用户名和密码，用 Scanner 实现 Scanner sc = new Scanner(System.in); // 4. 用循环实现多次机会，这里的次数明确，采用for循环实现 for(int i = 1; i &lt;= 3; i++)&#123; System.out.println(\"请输入用户名:\"); String scUsername = sc.nextLine(); System.out.println(\"请输入密码:\"); String scPassword = sc.nextLine(); // 3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。 if(username.equals(scUsername) &amp;&amp; password.equals(scPassword))&#123; System.out.println(\"登录成功\"); break; &#125;else&#123; if(i == 3)&#123; System.out.println(\"您的登录次数已达到今日上限, 请明天再来\"); &#125;else&#123; System.out.println(\"登录失败,您还剩余\" + (3-i) +\"次机会\"); &#125; &#125; &#125; &#125;&#125; 2.7 遍历字符串案例【应用】案例需求 : ​ 键盘录入一个字符串，使用程序实现在控制台遍历该字符串 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 遍历字符串，首先要能够获取到字符串中的每一个字符, public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的 遍历字符串，其次要能够获取到字符串的长度, public int length()：返回此字符串的长度 遍历打印 代码实现 : 123456789101112131415161718192021222324252627282930package com.itheima.test;import java.util.Scanner;public class Test2 &#123; /* 需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 遍历字符串，首先要能够获取到字符串中的每一个字符 public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的 3. 遍历字符串，其次要能够获取到字符串的长度 public int length()：返回此字符串的长度 4. 遍历打印9 */ public static void main(String[] args) &#123; // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 遍历字符串，首先要能够获取到字符串中的每一个字符 for(int i = 0; i &lt; s.length(); i++)&#123; // i : 字符串的每一个索引 char c = s.charAt(i); System.out.println(c); &#125; &#125;&#125; 2.8 统计字符次数案例【应用】案例需求 : ​ 键盘录入一个字符串，使用程序实现在控制台遍历该字符串 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 将字符串拆分为字符数组 , public char[] toCharArray( )：将当前字符串拆分为字符数组并返回 遍历字符数 代码实现 : 12345678910111213141516171819202122232425262728package com.itheima.test;import java.util.Scanner;public class Test3 &#123; /* 需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 将字符串拆分为字符数组 public char[] toCharArray( )：将当前字符串拆分为字符数组并返回 3. 遍历字符数组 */ public static void main(String[] args) &#123; // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 将字符串拆分为字符数组 char[] chars = s.toCharArray(); // 3. 遍历字符数组 for (int i = 0; i &lt; chars.length; i++) &#123; System.out.println(chars[i]); &#125; &#125;&#125; 2.9 手机号屏蔽-字符串截取案例需求 : ​ 以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽 1最终效果为：156****1234 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 截取字符串前三位 截取字符串后四位 将截取后的两个字符串，中间加上****进行拼接，输出结果 代码实现 : 1234567891011121314151617181920212223242526272829package com.itheima.test;import java.util.Scanner;public class Test5 &#123; /* 需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽 最终效果为：156****1234 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 截取字符串前三位 3. 截取字符串后四位 4. 将截取后的两个字符串，中间加上****进行拼接，输出结果 */ public static void main(String[] args) &#123; // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入手机号:\"); String telString = sc.nextLine(); // 2. 截取字符串前三位 String start = telString.substring(0,3); // 3. 截取字符串后四位 String end = telString.substring(7); // 4. 将截取后的两个字符串，中间加上****进行拼接，输出结果 System.out.println(start + \"****\" + end); &#125;&#125; 2.10 敏感词替换-字符串替换案例需求 : ​ 键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 替换敏感词 12String replace(CharSequence target, CharSequence replacement)将当前字符串中的target内容，使用replacement进行替换，返回新的字符串 输出结果 代码实现 : 123456789101112131415161718192021222324252627package com.itheima.test;import java.util.Scanner;public class Test6 &#123; /* 需求：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 替换敏感词 String replace(CharSequence target, CharSequence replacement) 将当前字符串中的target内容，使用replacement进行替换，返回新的字符串 3. 输出结果 */ public static void main(String[] args) &#123; // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 替换敏感词 String result = s.replace(\"TMD\",\"***\"); // 3. 输出结果 System.out.println(result); &#125;&#125; 2.11 切割字符串案例需求 : ​ 以字符串的形式从键盘录入学生信息，例如：“张三 , 23” ​ 从该字符串中切割出有效数据,封装为Student学生对象 实现步骤 : 编写Student类，用于封装数据 键盘录入一个字符串，用 Scanner 实现 根据逗号切割字符串，得到（张三）（23） String[] split(String regex) ：根据传入的字符串作为规则进行切割将切割后的内容存入字符串数组中，并将字符串数组返回 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 调用对象getXxx方法，取出数据并打印。 代码实现 : 123456789101112131415161718192021222324252627282930313233343536373839package com.itheima.test;import com.itheima.domain.Student;import java.util.Scanner;public class Test7 &#123; /* 需求：以字符串的形式从键盘录入学生信息，例如：“张三 , 23” 从该字符串中切割出有效数据,封装为Student学生对象 思路： 1. 编写Student类，用于封装数据 2. 键盘录入一个字符串，用 Scanner 实现 3. 根据逗号切割字符串，得到（张三）（23） String[] split(String regex) ：根据传入的字符串作为规则进行切割 将切割后的内容存入字符串数组中，并将字符串数组返回 4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 5. 调用对象getXxx方法，取出数据并打印。 */ public static void main(String[] args) &#123; // 2. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入学生信息:\"); String stuInfo = sc.nextLine(); // stuInfo = \"张三,23\"; // 3. 根据逗号切割字符串，得到（张三）（23） String[] sArr = stuInfo.split(\",\");// System.out.println(sArr[0]);// System.out.println(sArr[1]); // 4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 Student stu = new Student(sArr[0],sArr[1]); // 5. 调用对象getXxx方法，取出数据并打印。 System.out.println(stu.getName() + \"...\" + stu.getAge()); &#125;&#125; 2.12 String方法小结String类的常用方法 : ​ public boolean equals(Object anObject) 比较字符串的内容，严格区分大小写 ​ public boolean equalsIgnoreCase(String anotherString) 比较字符串的内容，忽略大小写 ​ public int length() 返回此字符串的长度 ​ public char charAt(int index) 返回指定索引处的 char 值 ​ public char[] toCharArray() 将字符串拆分为字符数组后返回 ​ public String substring(int beginIndex, int endIndex) 根据开始和结束索引进行截取，得到新的字符串（包含头，不包含尾） ​ public String substring(int beginIndex) 从传入的索引处截取，截取到末尾，得到新的字符串 ​ public String replace(CharSequence target, CharSequence replacement) 使用新值，将字符串中的旧值替换，得到新的字符串 ​ public String[] split(String regex) 根据传入的规则切割字符串，得到字符串数组 3 StringBuilder类3.1 StringBuilder类概述​ 概述 : StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的 3.2 StringBuilder类和String类的区别 String类：内容是不可变的 StringBuilder类：内容是可变的 3.3StringBuilder类的构造方法常用的构造方法 方法名 说明 public StringBuilder() 创建一个空白可变字符串对象，不含有任何内容 public StringBuilder(String str) 根据字符串的内容，来创建可变字符串对象 示例代码 12345678910111213public class StringBuilderDemo01 &#123; public static void main(String[] args) &#123; //public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容 StringBuilder sb = new StringBuilder(); System.out.println(\"sb:\" + sb); System.out.println(\"sb.length():\" + sb.length()); //public StringBuilder(String str)：根据字符串的内容，来创建可变字符串对象 StringBuilder sb2 = new StringBuilder(\"hello\"); System.out.println(\"sb2:\" + sb2); System.out.println(\"sb2.length():\" + sb2.length()); &#125;&#125; 3.4 StringBuilder常用的成员方法 添加和反转方法 方法名 说明 public StringBuilder append(任意类型) 添加数据，并返回对象本身 public StringBuilder reverse() 返回相反的字符序列 示例代码 123456789101112131415161718192021222324252627public class StringBuilderDemo01 &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder sb = new StringBuilder(); //public StringBuilder append(任意类型)：添加数据，并返回对象本身// StringBuilder sb2 = sb.append(\"hello\");//// System.out.println(\"sb:\" + sb);// System.out.println(\"sb2:\" + sb2);// System.out.println(sb == sb2);// sb.append(\"hello\");// sb.append(\"world\");// sb.append(\"java\");// sb.append(100); //链式编程 sb.append(\"hello\").append(\"world\").append(\"java\").append(100); System.out.println(\"sb:\" + sb); //public StringBuilder reverse()：返回相反的字符序列 sb.reverse(); System.out.println(\"sb:\" + sb); &#125;&#125; 3.5StringBuilder和String相互转换【应用】 StringBuilder转换为String ​ public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String String转换为StringBuilder ​ public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder 示例代码 12345678910111213141516171819202122232425public class StringBuilderDemo02 &#123; public static void main(String[] args) &#123; /* //StringBuilder 转换为 String StringBuilder sb = new StringBuilder(); sb.append(\"hello\"); //String s = sb; //这个是错误的做法 //public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String String s = sb.toString(); System.out.println(s); */ //String 转换为 StringBuilder String s = \"hello\"; //StringBuilder sb = s; //这个是错误的做法 //public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder StringBuilder sb = new StringBuilder(s); System.out.println(sb); &#125;&#125; 3.6 StringBuilder拼接字符串案例案例需求 : ​ 定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法， ​ 并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3] 实现步骤 : 定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。 1返回值类型 String，参数列表 int[] arr 在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 调用方法，用一个变量接收结果 输出结果 代码实现 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 思路： 1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。 返回值类型 String，参数列表 int[] arr 3:在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 4:调用方法，用一个变量接收结果 5:输出结果 */public class StringBuilderTest01 &#123; public static void main(String[] args) &#123; //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 int[] arr = &#123;1, 2, 3&#125;; //调用方法，用一个变量接收结果 String s = arrayToString(arr); //输出结果 System.out.println(\"s:\" + s); &#125; //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回 /* 两个明确： 返回值类型：String 参数：int[] arr */ public static String arrayToString(int[] arr) &#123; //在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for(int i=0; i&lt;arr.length; i++) &#123; if(i == arr.length-1) &#123; sb.append(arr[i]); &#125; else &#123; sb.append(arr[i]).append(\", \"); &#125; &#125; sb.append(\"]\"); String s = sb.toString(); return s; &#125;&#125;键盘录入一个字符串,将其中的大写转成小写,小写转大写,数字不变,其他字符变成*;","categories":[],"tags":[]},{"title":"7_类和对象","slug":"7_类和对象","date":"2020-11-04T14:41:16.824Z","updated":"2020-11-04T14:42:25.063Z","comments":true,"path":"2020/11/04/7_类和对象/","link":"","permalink":"http://yoursite.com/2020/11/04/7_%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"1. 类和对象*面向对象和面向过程的思想对比 : * ​ 面向过程 ：是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的 ​ 面向对象 ：是一种以对象为中心的编程思想，通过指挥对象实现具体的功能","text":"1. 类和对象*面向对象和面向过程的思想对比 : * ​ 面向过程 ：是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的 ​ 面向对象 ：是一种以对象为中心的编程思想，通过指挥对象实现具体的功能 1.1 类和对象的关系客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。 类 类的理解 类是对现实生活中一类具有共同属性和行为的事物的抽象 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合 简单理解：类就是对现实事物的一种描述 类的组成 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸） 行为：指事物能执行的操作，例如：手机事物（打电话，发短信） 类和对象的关系 类：类是对现实生活中一类具有共同属性和行为的事物的抽象 对象：是能够看得到摸的着的真实存在的实体 简单理解：类是对事物的一种描述，对象则为具体存在的事物 1.2 类的定义【应用】类的组成是由属性和行为两部分组成 属性：在类中通过成员变量来体现（类中方法外的变量） 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可） 类的定义步骤： ​ ① 定义类 ​ ② 编写类的成员变量 ​ ③ 编写类的成员方法 123456789101112public class Student &#123; // 属性 : 姓名, 年龄 // 成员变量: 跟之前定义变量的格式一样, 只不过位置发生了改变, 类中方法外 String name; int age; // 行为 : 学习 // 成员方法: 跟之前定义方法的格式一样, 只不过去掉了static关键字. public void study()&#123; System.out.println(\"学习\"); &#125;&#125; 1.3 对象的创建和使用 创建对象的格式： 类名 对象名 = new 类名(); 调用成员的格式： 对象名.成员变量 对象名.成员方法(); *示例代码 : * 1234567891011121314151617181920212223242526272829303132package com.itheima.object1;public class TestStudent &#123; /* 创建对象的格式: 类名 对象名 = new 类名(); 调用成员变量的格式: 对象名.变量名 调用成员方法的格式: 对象名.方法名(); */ public static void main(String[] args) &#123; // 类名 对象名 = new 类名(); Student stu = new Student(); // 对象名.变量名 // 默认初始化值 System.out.println(stu.name); // null System.out.println(stu.age); // 0 stu.name = \"张三\"; stu.age = 23; System.out.println(stu.name); // 张三 System.out.println(stu.age); // 23 // 对象名.方法名(); stu.study(); // com.itheima.object1.Student@b4c966a // 全类名(包名 + 类名) System.out.println(stu); &#125;&#125; 1.4 案例-手机类的创建和使用需求 ：首先定义一个手机类，然后定义一个手机测试类，在手机测试类中通过对象完成成员变量和成员方法的使用 分析 ： 成员变量：品牌, 价格 成员方法：打电话, 发短信 示例代码： 12345678910111213141516package com.itheima.test1;public class Phone &#123; // 品牌, 价格 String brand; int price; // 打电话, 发短信 public void call(String name)&#123; System.out.println(\"给\"+name+\"打电话\"); &#125; public void sendMessage()&#123; System.out.println(\"群发短信\"); &#125;&#125; 12345678910111213141516package com.itheima.test1;public class TestPhone &#123; public static void main(String[] args) &#123; // 1. 创建对象 Phone p = new Phone(); // 2. 给成员变量进行赋值 p.brand = \"大米\"; p.price = 2999; // 3. 打印赋值后的成员变量 System.out.println(p.brand + \"...\" + p.price); // 4. 调用成员方法 p.call(\"阿强\"); p.sendMessage(); &#125;&#125; 2. 对象内存图2.1 单个对象内存图【理解】 2.2 多个对象内存图【理解】 总结： 多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份 2.3 多个对象指向相同内存图【理解】 总结 : 当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的） 只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。 3. 成员变量和局部变量3.1 成员变量和局部变量的区别 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上） 内存中位置不同：成员变量（堆内存）局部变量（栈内存） 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失） 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用） 4. 封装4.1 private关键字​ 概述 : private是一个修饰符，可以用来修饰成员（成员变量，成员方法） ​ 特点 : 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用， 提供相应的操作 ​ 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰 ​ 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰 ​ 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940/* 学生类 */class Student &#123; //成员变量 String name; private int age; //提供get/set方法 public void setAge(int a) &#123; if(a&lt;0 || a&gt;120) &#123; System.out.println(\"你给的年龄有误\"); &#125; else &#123; age = a; &#125; &#125; public int getAge() &#123; return age; &#125; //成员方法 public void show() &#123; System.out.println(name + \",\" + age); &#125;&#125;/* 学生测试类 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); //给成员变量赋值 s.name = \"林青霞\"; s.setAge(30); //调用show方法 s.show(); &#125;&#125; 4.2 private关键字的使用 需求： 定义标准的学生类，要求name和age使用private修饰 并提供set和get方法以及便于显示数据的show方法 测试类中创建对象并使用，最终控制台输出 林青霞，30 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 学生类 */class Student &#123; //成员变量 private String name; private int age; //get/set方法 public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125; public void show() &#123; System.out.println(name + \",\" + age); &#125;&#125;/* 学生测试类 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); //使用set方法给成员变量赋值 s.setName(\"林青霞\"); s.setAge(30); s.show(); //使用get方法获取成员变量的值 System.out.println(s.getName() + \"---\" + s.getAge()); System.out.println(s.getName() + \",\" + s.getAge()); &#125;&#125; 4.3 this关键字【应用】概述 : this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题） 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量 代码实现 : 123456789101112131415161718192021222324public class Student &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void show() &#123; System.out.println(name + \",\" + age); &#125;&#125; 4.4 this内存原理【理解】 注意 : this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象 图解 ： 4.5 封装思想 封装概述 是面向对象三大特征之一（封装，继承，多态） 是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的 封装原则 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法 封装好处 通过方法来控制成员变量的操作，提高了代码的安全性 把代码用方法进行封装，提高了代码的复用性 5. 构造方法5.1 构造方法的格式和执行时机 格式注意 : 方法名与类名相同，大小写也要一致 没有返回值类型，连void都没有 没有具体的返回值（不能由retrun带回结果数据） 执行时机 ： 创建对象的时候调用，每创建一次对象，就会执行一次构造方法 不能手动调用构造方法 示例代码： 1234567891011121314151617181920212223class Student &#123; private String name; private int age; //构造方法 public Student() &#123; System.out.println(\"无参构造方法\"); &#125; public void show() &#123; System.out.println(name + \",\" + age); &#125;&#125;/* 测试类 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); s.show(); &#125;&#125; 5.2 构造方法的作用 用于给对象的数据（属性）进行初始化 12345678910111213141516171819202122232425262728package com.itheima.constructor;public class Student &#123; /* 格式: 1. 方法名需要跟类名相同, 大小写也要一致 2. 没有返回值类型, 连void都没有 3. 没有具体的返回值(不能由return带回具体的结果) */ private String name; private int age; // 1. 如果一个类中没有编写任何构造方法, 系统将会提供一个默认的无参数构造方法 public Student()&#123;&#125; // 2. 如果手动编写了构造方法, 系统就不会再提供默认的无参数构造方法了 public Student(String name, int age)&#123; this.name = name; this.age = age; System.out.println(\"我是Student类的构造方法\"); &#125; public void show()&#123; System.out.println(name + \"...\" + age); &#125;&#125; 12345678910package com.itheima.constructor;public class TestStudent &#123; public static void main(String[] args) &#123; Student stu1 = new Student(\"张三\",23); stu1.show(); Student stu2 = new Student(); &#125;&#125; 5.3 构造方法的注意事项构造方法的创建 : ​ 如果没有定义构造方法，系统将给出一个默认的无参数构造方法 ​ 如果定义了构造方法，系统将不再提供默认的构造方法 构造方法的创建 : ​ 如果没有定义构造方法，系统将给出一个默认的无参数构造方法如果定义了构造方法，系统将不再提供默认的构造方法 推荐的使用方式 : ​ 无论是否使用，都手动书写无参数构造方法，和带参数构造方法 5.4 标准类的代码编写和使用代码 : 12345678910111213141516171819202122232425262728293031323334353637package com.itheima.test3;/* JavaBean类: 封装数据 */public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void show()&#123; System.out.println(name + \"...\" + age); &#125;&#125; 123456789101112131415package com.itheima.test3;public class TestStudent &#123; public static void main(String[] args) &#123; // 1. 无参数构造方法创建对象, 通过setXxx方法给成员变量进行赋值 Student stu1 = new Student(); stu1.setName(\"张三\"); stu1.setAge(23); stu1.show(); // 2. 通过带参数构造方法, 直接给属性进行赋值 Student stu2 = new Student(\"李四\",24); stu2.show(); &#125;&#125;","categories":[],"tags":[]},{"title":"6_Debug模式","slug":"6_Debug模式","date":"2020-11-03T15:15:30.312Z","updated":"2020-11-04T15:41:59.543Z","comments":true,"path":"2020/11/03/6_Debug模式/","link":"","permalink":"http://yoursite.com/2020/11/03/6_Debug%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1.Debug模式1.1 什么是Debug模式是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。 1.2 Debug介绍与操作流程 如何加断点 选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可 如何运行加了断点的程序 在代码区域右键Debug执行 看哪里 看Debugger窗口 看Console窗口 点哪里 点Step Into (F7)这个箭头，也可以直接按F7 如何删除断点 选择要删除的断点，单击鼠标左键即可 如果是多个断点，可以每一个再点击一次。也可以一次性全部删除 2. 进制的介绍与书写格式2.1 进制的介绍与书写格式几进制,就是逢几进1,借1当几 二进制:组成 0 , 1 八进制:组成: 0 - 7 十六进制 组成: 0-9 a-f 代码 : 12345678910111213141516public class Demo1 &#123; /* 十进制：Java中，数值默认都是10进制，不需要加任何修饰。 二进制：数值前面以0b开头，b大小写都可以。 八进制：数值前面以0开头。 十六进制：数值前面以0x开头，x大小写都可以。 注意: 书写的时候, 虽然加入了进制的标识, 但打印在控制台展示的都是十进制数据. */ public static void main(String[] args) &#123; System.out.println(10); System.out.println(\"二进制数据0b10的十进制表示为:\" + 0b10); System.out.println(\"八进制数据010的十进制表示为:\" + 010); System.out.println(\"十六进制数据0x10的十进制表示为:\" + 0x10); &#125;&#125; 2.2 任意进制到十进制的转换 2.3 进制转换-十进制到任意进制转换​ 2.3.1 : 十进制到二进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到 0 ，再将余数倒着拼起来即可。 ​ 需求：将十进制数字11，转换为2进制。 ​ 实现方式：源数据为11，使用11不断的除以基数，也就是2，直到商为0。 ​ 2.3.2 : 十进制到十六进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。 ​ 需求：将十进制数字60，转换为16进制。 ​ 实现方式：源数据为60，使用60不断的除以基数，也就是16，直到商为0。 ​ 结论：十进制到任意进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着 拼起来即可 2.4 快速进制转换法​ 8421码： ​ 8421码又称BCD码，是BCD代码中最常用的一种BCD： (Binary-Coded Decimal‎) 二进制码十进制数在这种编码方式中，每一位二进制值的1都是代表一个固定数值，把每一位的1代表的十进制数加起来得到的结果就是它所代表的十进制数。 ​ 2.5 原码反码补码前言 : 计算机中的数据，都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的 *原码 *:（可直观看出数据大小） 原码是看数据大小的,反码就是一个原码和补码的一个桥梁,补码是运算的时候存在的. 正数的原,反,补都一样. 负数的反码是符号位不变,其他位取反.从左到右第一个数符号位,0表示正数,1表示负数. 补码就是反码+1; 就是二进制定点表示法，即最高位为符号位，【0】表示正，【1】表示负，其余位表示数值的大小。 通过一个字节表示+7和-7，代码：byte b1 = 7; byte b2 = -7;一个字节等于8个比特位，也就是8个二进制位 0(符号位) 0000111 1(符号位) 0000111 反码 : 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码 : （数据以该状态进行运算）正数的补码与其原码相同；负数的补码是在其反码的末位加1。 2.6 位运算-基本位运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima.demo;public class Demo2 &#123; /* 位运算: 位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。 在二进制位运算中，1表示true，0表示false。 &amp; 位与 : 遇false则false, 遇0则0 00000000 00000000 00000000 00000110 // 6的二进制 &amp; 00000000 00000000 00000000 00000010 // 2的二进制 ----------------------------------------- 00000000 00000000 00000000 00000010 // 结果: 2 | 位或 : 遇true则true, 遇1则1 ^ 位异或 : 相同为false, 不同为true ~ 取反 : 全部取反, 0变1, 1变0 (也包括符号位) 00000000 00000000 00000000 00000110 // 6的二进制补码 ~ 11111111 11111111 11111111 11111001 - 1 // -1求反码 ------------------------------------ 11111111 11111111 11111111 11111000 // 反码推原码 10000000 00000000 00000000 00000111 // -7 */ public static void main(String[] args) &#123; System.out.println(6 &amp; 2); System.out.println(~6); &#125;&#125;一个数和另一个数异或两次 得到的是这个数本身因为一个数异或两次之后 每个二进制位都相同 所以都是false 是0一个数和0异或得到的是这个数本身 0和1异的到的1 0和0异或 0 正数的原反补都一样,原码是看数据大小的,反码就是转换,补码是计算机运算的时候用原码 反码补码 +1原码---&gt;反码(符号位不变,其余为全部取反)---&gt;补码 -1补码---&gt;反码---&gt;原码(符号位不变,其余位全部取反) 2.7 位运算-位移运算符位运算概述 : 位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。在二进制位运算中，1表示true，0表示false。 位运算符介绍 : 代码 : 1234567891011121314151617181920212223242526272829303132package com.itheima.demo;public class Demo3 &#123; /* 位移运算符: &lt;&lt; 有符号左移运算，二进制位向左移动, 左边符号位丢弃, 右边补齐0 运算规律: 向左移动几位, 就是乘以2的几次幂 12 &lt;&lt; 2 (0)0000000 00000000 00000000 000011000 // 12的二进制 ----------------------------------------------------------------------------- &gt;&gt; 有符号右移运算，二进制位向右移动, 使用符号位进行补位 运算规律: 向右移动几位, 就是除以2的几次幂 000000000 00000000 00000000 0000001(1) // 3的二进制 ----------------------------------------------------------------------------- &gt;&gt;&gt; 无符号右移运算符, 无论符号位是0还是1，都补0 010000000 00000000 00000000 00000110 // -6的二进制 */ public static void main(String[] args) &#123; System.out.println(12 &lt;&lt; 1); // 24 System.out.println(12 &lt;&lt; 2); // 48 &#125;&#125; 123456789101112package com.itheima.demo;public class Demo4 &#123; /* ^ 运算符的特点 一个数, 被另外一个数, 异或两次, 该数本身不变 */ public static void main(String[] args) &#123; System.out.println(10 ^ 5 ^ 10); &#125;&#125; 3.基础练习3.1 数据交换案例需求 ​ 已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换 1最终输出a &#x3D; 20，b &#x3D; 10; 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.test;public class Test1 &#123; /* 需求：已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换 最终输出a = 20，b = 10; 思路： 1. 定义一个三方变量temp，将a原本记录的值，交给temp记录 （a的值，不会丢了） 2. 使用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了） 3. 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕） 4. 输出 a 和 b 变量即可 */ /* 动态初始化格式： 数据类型[][] 变量名 = new 数据类型[m][n]; m表示这个二维数组，可以存放多少个一维数组 n表示每一个一维数组，可以存放多少个元素 */ public static void main(String[] args) &#123; int a = 10; int b = 20; // 将a原本记录的值，交给temp记录 （a的值，不会丢了） int temp = a; // 用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了） a = b; // 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕） b = temp; // 输出 a 和 b 变量即可 System.out.println(\"a=\" + a); System.out.println(\"b=\" + b); &#125;&#125;public class Demo1 &#123; public static void main(String[] args) &#123; /*int a = 10; int b = 20; int temp = b; b = a; a = temp;*/ int a = 10; int b = 20; a = a^b; //我们不用计算 b= a^b; //b = a^b^b b=a a = a^b; //a = a^b^a a=b System.out.println(a); System.out.println(b); &#125;&#125; 3.2 数组反转【应用】案例需求 : ​ 已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换， ​ 交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素 实现步骤 : 定义两个变量, start和end来表示开始和结束的指针. 确定交换条件, start &lt; end 允许交换 循环中编写交换逻辑代码 每一次交换完成, 改变两个指针所指向的索引 start++, end– 循环结束后, 遍历数组并打印, 查看反转后的数组 代码实现 : 12345678910111213141516171819202122232425262728293031323334package com.itheima.test;public class Test2 &#123; /* 需求：已知一个数组 arr = &#123;19, 28, 37, 46, 50&#125;; 用程序实现把数组中的元素值交换， 交换后的数组 arr = &#123;50, 46, 37, 28, 19&#125;; 并在控制台输出交换后的数组元素。 步骤: 1. 定义两个变量, start和end来表示开始和结束的指针. 2. 确定交换条件, start &lt; end 允许交换 3. 循环中编写交换逻辑代码 4. 每一次交换完成, 改变两个指针所指向的索引 start++, end-- 5. 循环结束后, 遍历数组并打印, 查看反转后的数组 */ public static void main(String[] args) &#123; int[] arr = &#123;19, 28, 37, 46, 50&#125;; // 1. 定义两个变量, start和end来表示开始和结束的指针. int start = 0; int end = arr.length -1; // 2. 确定交换条件, start &lt; end 允许交换 // 4. 每一次交换完成, 改变两个指针所指向的索引 start++, end-- // for(int start = 0, end = arr.length -1; start &lt; end; start++, end--) for( ; start &lt; end; start++, end--)&#123; // 3. 循环中编写交换逻辑代码 int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 3.3 二维数组概述​ 概述 : 二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器 3.4 二维数组动态初始化12345动态初始化格式：数据类型[][] 变量名 = new 数据类型[m][n];m表示这个二维数组，可以存放多少个一维数组,一维数组的个数n表示每一个一维数组，可以存放多少个元素,一个数组存储元素的个数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.demo;public class Demo1Array &#123; /* 动态初始化格式： 数据类型[][] 变量名 = new 数据类型[m][n]; m表示这个二维数组，可以存放多少个一维数组 n表示每一个一维数组，可以存放多少个元素 */ public static void main(String[] args) &#123; // 数据类型[][] 变量名 = new 数据类型[m][n]; int[][] arr = new int[3][3]; /* [[I@10f87f48 @ : 分隔符 10f87f48 : 十六进制内存地址 I : 数组中存储的数据类型 [[ : 几个中括号就代表的是几维数组 */ System.out.println(arr); /* 二维数组存储一维数组的时候, 存储的是一维数组的内存地址 */ System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[0][0]); System.out.println(arr[1][1]); System.out.println(arr[2][2]); // 向二维数组中存储元素 arr[0][0] = 11; arr[0][1] = 22; arr[0][2] = 33; arr[1][0] = 11; arr[1][1] = 22; arr[1][2] = 33; arr[2][0] = 11; arr[2][1] = 22; arr[2][2] = 33; // 从二维数组中取出元素并打印 System.out.println(arr[0][0]); System.out.println(arr[0][1]); System.out.println(arr[0][2]); System.out.println(arr[1][0]); System.out.println(arr[1][1]); System.out.println(arr[1][2]); System.out.println(arr[2][0]); System.out.println(arr[2][1]); System.out.println(arr[2][2]); &#125;&#125; 3.5 二维数组访问元素的细节问题问题 : 二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ? 答 : 可以的 代码实现123456789101112131415161718192021222324package com.itheima.demo;public class Demo2Array &#123; /* 问题: 二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ? 答 : 可以的 */ public static void main(String[] args) &#123; int[] arr1 = &#123;11,22,33&#125;; int[] arr2 = &#123;44,55,66&#125;; int[] arr3 = &#123;77,88,99,100&#125;; int[][] arr = new int[3][3]; arr[2][3] = 100; arr[0] = arr1; arr[1] = arr2; arr[2] = arr3; System.out.println(arr[1][2]); System.out.println(arr[2][3]); &#125;&#125; 3.6 二维数组静态初始化**完整格式 :** 数据类型[][] 变量名 = new 数据类型[][]{ {元素1, 元素2...} , {元素1, 元素2...} **简化格式 :** 数据类型[][] 变量名 = { {元素1, 元素2...} , {元素1, 元素2...} ...};*代码实现 : * 12345678910111213141516171819package com.itheima.demo;public class Demo3Array &#123; /* 完整格式：数据类型[][] 变量名 = new 数据类型[][]&#123; &#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125; ...&#125;; 简化格式: 数据类型[][] 变量名 = &#123; &#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125; ...&#125;; */ public static void main(String[] args) &#123; int[] arr1 = &#123;11,22,33&#125;; int[] arr2 = &#123;44,55,66&#125;; int[][] arr = &#123; &#123;11,22,33&#125;, &#123;44,55,66&#125; &#125;; System.out.println(arr[0][2]); int[][] array = &#123;arr1,arr2&#125;; System.out.println(array[0][2]); &#125;&#125; 3.7 二维数组遍历需求 : ​ 已知一个二维数组 arr = { {11, 22, 33}, {33, 44, 55} }; ​ 遍历该数组，取出所有元素并打印 步骤 : 遍历二维数组，取出里面每一个一维数组 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素 代码实现 : 123456789101112131415161718192021222324252627package com.itheima.test;public class Test1 &#123; /* 需求: 已知一个二维数组 arr = &#123; &#123;11, 22, 33&#125;, &#123;33, 44, 55&#125; &#125;; 遍历该数组，取出所有元素并打印 步骤: 1. 遍历二维数组，取出里面每一个一维数组 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素 */ public static void main(String[] args) &#123; int[][] arr = &#123; &#123;11, 22, 33&#125;, &#123;33, 44, 55&#125; &#125;; // 1. 遍历二维数组，取出里面每一个一维数组 for (int i = 0; i &lt; arr.length; i++) &#123; //System.out.println(arr[i]); // 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素 //int[] temp = arr[i]; for (int j = 0; j &lt; arr[i].length; j++) &#123; System.out.println(arr[i][j]); &#125; &#125; &#125;&#125; 3.8 二维数组求和需求 : 某公司季度和月份统计的数据如下：单位(万元)1234第一季度：22,66,44第二季度：77,33,88第三季度：25,45,65第四季度：11,66,99 步骤 : 定义求和变量，准备记录最终累加结果 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 遍历二维数组，获取所有元素，累加求和 输出最终结果 代码实现 : 1234567891011121314151617181920212223242526272829303132package com.itheima.test;public class Test2 &#123; /* 需求: 某公司季度和月份统计的数据如下：单位(万元) 第一季度：22,66,44 第二季度：77,33,88 第三季度：25,45,65 第四季度：11,66,99 步骤: 1. 定义求和变量，准备记录最终累加结果 2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 3. 遍历二维数组，获取所有元素，累加求和 4. 输出最终结果 */ public static void main(String[] args) &#123; // 1. 定义求和变量，准备记录最终累加结果 int sum = 0; // 2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 int[][] arr = &#123; &#123;22,66,44&#125; , &#123;77,33,88&#125; , &#123;25,45,65&#125; , &#123;11,66,99&#125; &#125;; // 3. 遍历二维数组，获取所有元素，累加求和 for (int i = 0; i &lt; arr.length; i++) &#123; for(int j = 0; j &lt; arr[i].length; j++)&#123; sum += arr[i][j]; &#125; &#125; // 4. 输出最终结果 System.out.println(sum); &#125;&#125;","categories":[],"tags":[]},{"title":"5_方法概述","slug":"5_方法概述","date":"2020-11-03T15:14:41.628Z","updated":"2020-11-03T16:23:02.838Z","comments":true,"path":"2020/11/03/5_方法概述/","link":"","permalink":"http://yoursite.com/2020/11/03/5_%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0/","excerpt":"1. 方法概述1.1 方法的概念​ 方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集 封装 注意： 方法必须先创建才可以使用，该过程成为方法定义 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用","text":"1. 方法概述1.1 方法的概念​ 方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集 封装 注意： 方法必须先创建才可以使用，该过程成为方法定义 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用 2. 方法的定义和调用2.1 无参数方法定义和调用 定义格式： 123public static void 方法名 ( ) &#123; // 方法体;&#125; 范例： 123public static void method ( ) &#123; // 方法体;&#125; 调用格式： 1方法名(); 范例： 1method(); 注意： ​ 方法必须先定义，后调用，否则程序将报错 2.2 方法的调用过程 总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。 2.3 方法练习-奇偶数判断 需求：判断一个数是奇数还是偶数 代码： 123456789101112131415161718192021222324252627public class Demo1Method &#123; /* 带参数方法的定义格式: public static void 方法名 ( 参数 ) &#123; … … &#125; public static void 方法名 ( 数据类型 变量名 ) &#123; … … &#125; 带参数方法的调用格式: 方法名 ( 参数 ) ; 方法名 ( 变量名/常量值 ) ; tips: 参数可以是一个, 也可以是多个. 需求: 判断一个数是奇数还是偶数 */ public static void main(String[] args) &#123; isEvenNumber(10); &#125; public static void isEvenNumber(int num)&#123; if(num % 2 == 0)&#123; System.out.println(\"偶数\"); &#125;else&#123; System.out.println(\"奇数\"); &#125; &#125;&#125; 3. 带参数方法的定义和调用3.1 带参数方法定义和调用 定义格式： 参数：由数据类型和变量名组成 - 数据类型 变量名 参数范例：int a 1234567public static void 方法名 (参数1) &#123; 方法体;&#125;public static void 方法名 (参数1, 参数2, 参数3...) &#123; 方法体;&#125; 范例： 123456public static void isEvenNumber(int number)&#123; ...&#125;public static void getMax(int num1, int num2)&#123; ...&#125; 注意： 1方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错 1方法定义时，多个参数之间使用逗号( ，)分隔 调用格式： 123方法名(参数)；方法名(参数1,参数2); 范例： 123isEvenNumber(10);getMax(10,20); 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 3.2 形参和实参 形参：方法定义中的参数 ​ 等同于变量定义格式，例如：int number 实参：方法调用中的参数 ​ 等同于使用变量或常量，例如： 10 number 3.3 带参数方法的练习-打印n-m之间所有的奇数 需求：设计一个方法（print） 用于打印 n 到 m 之间所有的奇数 思路： ​ 1：定义方法，名称为print 12342：为方法添加两个int类型的形参，准备接受调用者传递过来的实参3：方法中设计for循环，循环从n开始，到m结束4：循环中加入if判断，是奇数，则打印5：main方法中调用print方法，传入两个实际参数 代码： 12345678910111213141516171819202122package com.itheima.method2;public class Demo2Method &#123; public static void main(String[] args) &#123; // 5：main方法中调用print方法，传入两个实际参数 print(20,10); &#125; //1：定义方法，名称为print // 2：为方法添加两个int类型的形参，准备接受调用者传递过来的实参 public static void print(int n, int m)&#123; System.out.println(n + \"到\" + m + \"之间的奇数为:\"); // 3：方法中设计for循环，循环从n开始，到m结束 for(int i = 20; i &lt;= 10; i++)&#123; // 4：循环中加入if判断，是奇数，则打印 if(i % 2 == 1)&#123; System.out.println(i); &#125; &#125; &#125;&#125; 4. 带返回值方法的定义和调用4.1 带返回值方法定义和调用（掌握） 定义格式 123public static 数据类型 方法名 ( 参数 ) &#123; return 数据 ;&#125; 范例 123456public static boolean isEvenNumber( int number ) &#123; return true ;&#125;public static int getMax( int a, int b ) &#123; return 100 ;&#125; 注意： 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错 调用格式 12方法名 ( 参数 ) ;数据类型 变量名 = 方法名 ( 参数 ) ; 范例 12isEvenNumber ( 5 ) ;boolean flag = isEvenNumber ( 5 ); 注意： 方法的返回值通常会使用变量接收，否则该返回值将无意义 4.2 带返回值方法的练习-求两个数的最大值(应用) 需求：设计一个方法可以获取两个数的较大值，数据来自于参数 思路： 定义一个方法，声明两个形参接收计算的数值，求出结果并返回 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果 在main()方法中调用定义好的方法并使用 【 变量保存 】 代码： 123456789101112131415161718192021222324252627282930 /* 需求：设计一个方法可以获取两个数的较大值，数据来自于参数 1. 定义一个方法，声明两个形参接收计算的数值，求出结果并返回 2. 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果 3. 在main()方法中调用定义好的方法并使用 【 变量保存 】 */ public static void main(String[] args) &#123; // 3. 在main()方法中调用定义好的方法并使用 【 变量保存 】 System.out.println(getMax(10,20)); // 输出调用 int result = getMax(10,20); System.out.println(result); for(int i = 1; i &lt;= result; i++)&#123; System.out.println(\"HelloWorld\"); &#125; &#125; // 方法可以获取两个数的较大值 public static int getMax(int a, int b)&#123; if(a &gt; b)&#123; return a; &#125;else&#123; return b; &#125; &#125;&#125; 5. 方法的注意事项5.1 方法的通用格式（掌握） 格式： 1234public static 返回值类型 方法名(参数) &#123; 方法体; return 数据 ;&#125; 解释： public static 修饰符，目前先记住这个格式 返回值类型 方法操作完毕之后返回的数据的数据类型 ​ 如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return 方法名 调用方法时候使用的标识 参数 由数据类型和变量名组成，多个参数之间用逗号隔开 方法体 完成功能的代码块 return 如果方法操作完毕，有数据返回，用于把数据返回给调用者 定义方法时，要做到两个明确 明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型 明确参数：主要是明确参数的类型和数量 调用方法时的注意： void类型的方法，直接调用即可 非void类型的方法，推荐用变量接收调用 5.2 方法的注意事项 方法不能嵌套定义 示例代码： 1234567891011public class MethodDemo &#123; public static void main(String[] args) &#123; &#125; public static void methodOne() &#123; public static void methodTwo() &#123; // 这里会引发编译错误!!! &#125; &#125;&#125; void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据 示例代码： 12345678910public class MethodDemo &#123; public static void main(String[] args) &#123; &#125; public static void methodTwo() &#123; //return 100; 编译错误，因为没有具体返回值类型 return; //System.out.println(100); return语句后面不能跟数据或代码 &#125;&#125; 6. 方法重载6.1 方法重载 方法重载概念 方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载 多个方法在同一个类中 多个方法具有相同的方法名 多个方法的参数顺序不相同，类型不同或者数量不同 注意： 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载 正确范例： 1234567891011121314151617public class MethodDemo &#123; public static void fn(int a) &#123; //方法体 &#125; public static int fn(double a) &#123; //方法体 &#125;&#125;public class MethodDemo &#123; public static float fn(int a) &#123; //方法体 &#125; public static int fn(int a , int b) &#123; //方法体 &#125;&#125; 错误范例： 12345678910111213141516171819public class MethodDemo &#123; public static void fn(int a) &#123; //方法体 &#125; public static int fn(int a) &#123; /*错误原因：重载与返回值无关*/ //方法体 &#125;&#125;public class MethodDemo01 &#123; public static void fn(int a) &#123; //方法体 &#125;&#125; public class MethodDemo02 &#123; public static int fn(double a) &#123; /*错误原因：这是两个类的两个fn方法*/ //方法体 &#125;&#125; 6.2 方法重载练习 需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） 思路： ​ ①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数 ​ ②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数 ​ ③定义所有的重载方法，两个byte类型与两个short类型参数 ​ ④完成方法的调用，测试运行结果 代码： 12345678910111213141516171819202122232425262728293031323334public class MethodTest &#123; public static void main(String[] args) &#123; //调用方法 System.out.println(compare(10, 20)); System.out.println(compare((byte) 10, (byte) 20)); System.out.println(compare((short) 10, (short) 20)); System.out.println(compare(10L, 20L)); &#125; //int public static boolean compare(int a, int b) &#123; System.out.println(\"int\"); return a == b; &#125; //byte public static boolean compare(byte a, byte b) &#123; System.out.println(\"byte\"); return a == b; &#125; //short public static boolean compare(short a, short b) &#123; System.out.println(\"short\"); return a == b; &#125; //long public static boolean compare(long a, long b) &#123; System.out.println(\"long\"); return a == b; &#125;&#125; 7. 方法的参数传递7.1 方法参数传递基本类型（理解） 测试代码： 12345678910111213141516171819package com.itheima.param;public class Test1 &#123; /* 方法参数传递为基本数据类型 : 传入方法中的, 是具体的数值. */ public static void main(String[] args) &#123; int number = 100; System.out.println(\"调用change方法前:\" + number); change(number); System.out.println(\"调用change方法后:\" + number); &#125; public static void change(int number) &#123; number = 200; &#125;&#125; 结论： 基本数据类型的参数，形式参数的改变，不影响实际参数 结论依据： 每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失 7.2 方法参数传递引用类型 测试代码： 12345678910111213141516171819package com.itheima.param;public class Test2 &#123; /* 方法参数传递为引用数据类型 : 传入方法中的, 是内存地址. */ public static void main(String[] args) &#123; int[] arr = &#123;10, 20, 30&#125;; System.out.println(\"调用change方法前:\" + arr[1]); change(arr); System.out.println(\"调用change方法后:\" + arr[1]); &#125; public static void change(int[] arr) &#123; arr[1] = 200; &#125;&#125; 结论： 对于引用类型的参数，形式参数的改变，影响实际参数的值 (字符串除外) 结论依据： 引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果 7.3 数组遍历 需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] 思路： 因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”); System.out.println(“内容”); 输出内容并换行 System.out.print(“内容”); 输出内容不换行 System.out.println(); 起到换行的作用 定义一个数组，用静态初始化完成数组元素初始化 定义一个方法，用数组遍历通用格式对数组进行遍历 用新的输出语句修改遍历操作 调用遍历方法 代码： 123456789101112131415161718192021222324252627282930313233343536373839package com.itheima.test;public class Test1 &#123; /* 需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] 思路： 1.定义一个数组，用静态初始化完成数组元素初始化 2.定义一个方法，对数组进行遍历 3.遍历打印的时候，数据不换行 4.调用遍历方法 */ public static void main(String[] args) &#123; // 1.定义一个数组，用静态初始化完成数组元素初始化 int[] arr = &#123;11, 22, 33, 44, 55&#125;; // 4.调用遍历方法 printArray(arr); System.out.println(\"另外一段代码逻辑 \"); &#125; /* 2.定义一个方法，对数组进行遍历 1, 参数 int[] arr 2, 返回值类型 void */ public static void printArray(int[] arr)&#123; System.out.print(\"[\"); for (int i = 0; i &lt; arr.length; i++) &#123; if(i == arr.length -1)&#123; // 如果满足条件, 说明是最后一个元素, 最后一个元素, 特殊处理 System.out.println(arr[i] + \"]\"); &#125;else&#123; // 3.遍历打印的时候，数据不换行 System.out.print(arr[i] + \", \"); &#125; 12 &#125;&#125; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051### 7.4 数组最大值* 需求：设计一个方法用于获取数组中元素的最大值 * 思路： * ①定义一个数组，用静态初始化完成数组元素初始化 * ②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了 * ③调用获取最大值方法，用变量接收返回结果 * ④把结果输出在控制台* 代码： &#96;&#96;&#96;java package com.itheima.test; public class Test2 &#123; &#x2F;* 需求：设计一个方法用于获取数组中元素的最大值 思路： 1.定义一个数组，用静态初始化完成数组元素初始化 2.定义一个方法，用来获取数组中的最大值 3.调用获取最大值方法，用变量接收返回结果 4.把结果输出在控制台 *&#x2F; public static void main(String[] args) &#123; &#x2F;&#x2F; 1.定义一个数组，用静态初始化完成数组元素初始化 int[] arr &#x3D; &#123;11, 55, 22, 44, 33&#125;; &#x2F;&#x2F; 3.调用获取最大值方法，用变量接收返回结果 int max &#x3D; getMax(arr); &#x2F;&#x2F; 4.把结果输出在控制台 System.out.println(max); &#125; &#x2F;* 2.定义一个方法，用来获取数组中的最大值 1, 参数 int[] arr 2, 返回值类型 int *&#x2F; public static int getMax(int[] arr)&#123; int max &#x3D; arr[0]; for (int i &#x3D; 1; i &lt; arr.length; i++) &#123; if(max &lt; arr[i])&#123; max &#x3D; arr[i]; &#125; &#125; return max; &#125; &#125; 7.5 方法同时获取数组最大值和最小值 需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值 注意: return语句, 只能带回一个结果. 代码： 12345678910111213141516171819202122232425262728293031323334353637public class Test3 &#123; /* 需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值 注意: return语句, 只能带回一个结果. */ public static void main(String[] args) &#123; int[] arr = &#123;11,55,33,22,44&#125;; int[] maxAndMin = getMaxAndMin(arr); System.out.println(maxAndMin[0]); System.out.println(maxAndMin[1]); &#125; public static int[] getMaxAndMin(int[] arr)&#123; int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if(max &lt; arr[i])&#123; max = arr[i]; &#125; &#125; int min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if(min &gt; arr[i])&#123; min = arr[i]; &#125; &#125; int[] maxAndMin = &#123;min, max&#125;; return maxAndMin; &#125;&#125;","categories":[],"tags":[]},{"title":"4_IDEA和数组","slug":"4_IDEA和数组","date":"2020-11-02T15:43:12.066Z","updated":"2020-11-03T16:25:02.386Z","comments":true,"path":"2020/11/02/4_IDEA和数组/","link":"","permalink":"http://yoursite.com/2020/11/02/4_IDEA%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"第一部分 : IDEA开发工具参见 ：IEDA的安装请参考文件夹PPT中的 04_IDEA.ppt 1.数组1.1 数组介绍​ 数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。","text":"第一部分 : IDEA开发工具参见 ：IEDA的安装请参考文件夹PPT中的 04_IDEA.ppt 1.数组1.1 数组介绍​ 数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。 1.2 数组的定义格式1.2.1 第一种格式​ 数据类型[] 数组名 ​ 示例： 123int[] arr; double[] arr; char[] arr; 1.2.2 第二种格式​ 数据类型 数组名[] ​ 示例： 123int arr[];double arr[];char arr[]; 1.3 数组的动态初始化1.3.1 什么是动态初始化​ 数组动态初始化就是只给定数组的长度，由系统给出默认初始化值 1.3.2 动态初始化格式1数据类型[] 数组名 = new 数据类型[数组长度]; 1int[] arr = new int[3]; 1.3.3 动态初始化格式详解 等号左边： int:数组的数据类型 []:代表这是一个数组 arr:代表数组的名称 等号右边： new:为数组开辟内存空间 int:数组的数据类型 []:代表这是一个数组 3:代表数组的长度 代码 : 1234567891011121314151617181920212223242526272829303132333435package com.itheima.array;public class Demo2Array &#123; /* 数组的动态初始化: 在初始化的时候, 需要手动指定数组的长度, 系统会为数组容器分配初始值. 动态初始化格式: 数据类型[] 数组名 = new 数据类型[数组的长度]; 注意: 打印数组变量的时候, 会打印出数组的内存地址 [I@10f87f48 : @ : 分隔符 [ : 当前的空间是一个数组类型 I : 当前数组容器中所存储的数据类型 10f87f48 : 十六进制内存地址 0 1 2 3 4 5 6 7 8 9 a b c d e f */ public static void main(String[] args) &#123; // 数据类型[] 数组名 = new 数据类型[数组的长度]; // 通过new关键字创建了一个int类型的数组容器, 该容器可以存储5个int类型的整数, 该容器被arr数组变量所记录 int[] arr = new int[5]; // [I@10f87f48 System.out.println(arr); byte[] bArr = new byte[3]; // [B@b4c966a System.out.println(bArr); &#125;&#125; 1.4 数组元素访问1.4.1 什么是索引​ 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始,是连续的,不间断的,每次加1。 ​ 这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 1.4.2访问数组元素格式1数组名[索引]; 1.4.3示例代码1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.array;public class Demo3ArrayIndex &#123; /* 数组动态初始化: 初始化的时候, 手动指定数组长度, 系统会为数组容器分配初始值. 数组的元素访问格式: 数组名[索引] 索引: 数组中数据的编号方式, 编号从0开始 作用: 访问数组容器中的空间位置 注意: 数组在创建完毕后, 即使没有赋值, 也可以取出, 但取出的元素都是默认初始化值. */ public static void main(String[] args) &#123; int[] arr = new int[3]; // 0 1 2 System.out.println(arr); // 数组的内存地址 [I@10f87f48 // 数组名[索引] 访问数组容器中的空间位置 System.out.println(arr[0]); // 0 系统自动分配的默认初始化值 System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(\"--------------\"); // 数组名[索引] arr[0] = 11; arr[1] = 22; arr[2] = 33; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 1.5 内存分配1.5.1 内存概述​ 内存是计算机中的重要原件，临时存储区域，作用是运行程序。 ​ 我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。 ​ 必须放进内存中才能运行，运行完毕后会清空内存。 ​ Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 1.5.2 java中的内存分配 目前我们只需要记住两个内存，分别是：栈内存和堆内存 区域名称 作用 寄存器 给CPU使用，和我们开发无关。 本地方法栈 JVM在使用操作系统功能的时候使用，和我们开发无关。 方法区 存储可以运行的class文件。 堆内存 存储对象或者数组，new来创建的，都存储在堆内存。 方法栈 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 1.6 Java内存分配-一个数组内存图 1.7 两个数组内存图 1.8 多个数组指向相同内存图 1.9 数组的静态初始化1.9.1 什么是静态初始化​ 在创建数组时，直接将元素确定 1.9.2 静态初始化格式 完整版格式 1数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,...&#125;; 简化版格式 1数据类型[] 数组名 = &#123;元素1,元素2,...&#125;; 1.9.3示例代码123456789101112131415161718192021222324252627package com.itheima.array2;public class Demo1Array &#123; /* 数组静态初始化 : 初始化时指定每个数组元素的初始值，由系统决定数组长度 完整格式: 数据类型[] 数组名 = new 数据类型[]&#123;数据1,数据2,数据3...&#125;; 简化格式: 数据类型[] 数组名 = &#123;数据1,数据2,数据3...&#125;; */ public static void main(String[] args) &#123; // 数据类型[] 数组名 = new 数据类型[]&#123;数据1,数据2,数据3...&#125;; int[] arr = new int[]&#123;11,22,33&#125;; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); // 数据类型[] 数组名 = &#123;数据1,数据2,数据3...&#125;; int[] arr2 = &#123;44,55,66&#125;; System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); &#125;&#125; 1.10 数组操作的两个常见问题1.10.1 索引越界异常 出现原因 123456public class ArrayDemo &#123; public static void main(String[] args) &#123; int[] arr = new int[3]; System.out.println(arr[3]); &#125;&#125; 数组长度为3，索引范围是0~2，但是我们却访问了一个3的索引。 程序运行后，将会抛出ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 解决方案 将错误的索引修改为正确的索引范围即可！ 1.10.2 空指针异常 出现原因 123456789public class ArrayDemo &#123; public static void main(String[] args) &#123; int[] arr = new int[3]; //把null赋值给数组 arr = null; System.out.println(arr[0]); &#125;&#125; arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的空指针是不能出现的，一旦出现了，就必须要修改我们编写的代码。 解决方案 给数组一个真正的堆内存空间引用即可！ 1.11 数组遍历 数组遍历：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。 12345678910public class ArrayTest01 &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[3]); System.out.println(arr[4]); &#125;&#125; 以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现。 1234567891011public class ArrayTest01 &#123; public static void main(String[] args) &#123; //定义数组 int[] arr = &#123;11, 22, 33, 44, 55&#125;; //使用通用的遍历格式 for(int x=0; x&lt;arr.length; x++) &#123; System.out.println(arr[x]); &#125; &#125;&#125; 1.12 数组获取最大值 最大值获取：从数组的所有元素中找出最大值。 实现思路： 定义变量，保存数组0索引上的元素 遍历数组，获取出数组中的每个元素 将遍历到的元素和保存数组0索引上值的变量进行比较 如果数组元素的值大于了变量的值，变量记录住新的值 数组循环遍历结束，变量保存的就是数组中的最大值 代码实现： 12345678910111213141516171819202122232425262728293031package com.itheima.test;import java.util.Scanner;public class Test2Array &#123; /* 需求: 从数组中查找最大值 int[] arr = &#123;12,45,98,73,60&#125;; 实现步骤: 1. 假设数组中的第一个元素为最大值 2. 遍历数组, 获取每一个元素, 准备进行比较 3. 如果比较的过程中, 出现了比max更大的, 让max记录更大的值 4. 循环结束后, 打印最大值. */ public static void main(String[] args) &#123; int[] arr = &#123;12,45,98,73,60&#125;; // 1. 假设数组中的第一个元素为最大值 int max = arr[0]; // 2. 遍历数组, 获取每一个元素, 准备进行比较 for(int i = 1; i &lt; arr.length; i++)&#123; // 3. 如果比较的过程中, 出现了比max更大的, 让max记录更大的值 if(arr[i] &gt; max)&#123; max = arr[i]; &#125; &#125; // 4. 循环结束后, 打印最大值. System.out.println(\"max:\" + max); &#125;&#125; 1.13 数组元素求和 需求：键盘录入5个整数，存储到数组中，并对数组求和 思路： 1234561.创建键盘录入对象，准备键盘录入2.定义一个求和变量，准备记录累加后的结果3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值4.将键盘录入的数值存储到数组中5.遍历数组，取出每一个元素，并求和6.输出总和 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940package com.itheima.test;import java.util.Scanner;public class Test3Array &#123; /* 需求：键盘录入5个整数，存储到数组中，并对数组求和 思路： 1.创建键盘录入对象，准备键盘录入 2.定义一个求和变量，准备记录累加后的结果 3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值 4.将键盘录入的数值存储到数组中 5.遍历数组，取出每一个元素，并求和 6.输出总和 */ public static void main(String[] args) &#123; // 1.创建键盘录入对象，准备键盘录入 Scanner sc = new Scanner(System.in); // 2.定义一个求和变量，准备记录累加后的结果 int sum = 0; // 3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值 int[] arr = new int[5]; // 4.将键盘录入的数值存储到数组中 for(int i = 0; i &lt; arr.length; i++)&#123; System.out.println(\"请输入第\" + (i+1) + \"个整数:\"); //arr[i] = 10; arr[i] = sc.nextInt(); &#125; // 5.遍历数组，取出每一个元素，并求和 for (int i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; // 6.输出总和 System.out.println(\"sum:\" + sum); &#125;&#125; 1.14 数组基本查找【应用】 需求： 12已知一个数组 arr &#x3D; &#123;19, 28, 37, 46, 50&#125;; 键盘录入一个数据，查找该数据在数组中的索引，并在控制台输出找到的索引值。 思路： 1234561.定义一个数组，用静态初始化完成数组元素的初始化2.键盘录入要查找的数据，用一个变量接收3.定义一个索引变量，初始值为-14.遍历数组，获取到数组中的每一个元素5.拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环6.输出索引变量 代码实现： 1234567891011121314151617181920212223public static void main(String[] args) &#123; // 1.定义一个数组，用静态初始化完成数组元素的初始化 int[] arr = &#123;19, 28, 37, 46, 50&#125;; // 2.键盘录入要查找的数据，用一个变量接收 Scanner sc = new Scanner(System.in); System.out.println(\"请输入您要查找的元素:\"); int num = sc.nextInt(); // 3.定义一个索引变量，初始值为-1 // 假设要查找的数据, 在数组中就是不存在的 int index = -1; // 4.遍历数组，获取到数组中的每一个元素 for (int i = 0; i &lt; arr.length; i++) &#123; // 5.拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环 if(num == arr[i])&#123; // 如果值相同，就把该值对应的索引赋值给索引变量，并结束循环 index = i; break; &#125; &#125; // 6.输出索引变量 System.out.println(index); &#125;&#125; 1.15 评委打分【应用】 需求：在编程竞赛中，有6个评委为参赛的选手打分，分数为0-100的整数分。 1选手的最后得分为：去掉一个最高分和一个最低分后 的4个评委平均值 (不考虑小数部分)。 思路： 123456781.定义一个数组，用动态初始化完成数组元素的初始化，长度为62.键盘录入评委分数3.由于是6个评委打分，所以，接收评委分数的操作，用循环4.求出数组最大值5.求出数组最小值6.求出数组总和7.按照计算规则进行计算得到平均分8.输出平均分 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 public static void main(String[] args) &#123; // 1.定义一个数组，用动态初始化完成数组元素的初始化，长度为6 int[] arr = new int[6]; // 2.键盘录入评委分数 Scanner sc = new Scanner(System.in); // 3.由于是6个评委打分，所以，接收评委分数的操作，用循环 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(\"请输入第\" + (i+1) + \"个评委的打分:\"); int score = sc.nextInt(); if(score &gt;= 0 &amp;&amp; score &lt;= 100)&#123; // 合法的分值 arr[i] = score; &#125;else&#123; // 非法的分值 System.out.println(\"您的打分输入有误, 请检查是否是0-100之间的\"); i--; &#125; &#125; // 4.求出数组最大值 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if(max &lt; arr[i])&#123; max = arr[i]; &#125; &#125; // 5.求出数组最小值 int min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if(min &gt; arr[i])&#123; min = arr[i]; &#125; &#125; // 6.求出数组总和 int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; // 7.按照计算规则进行计算得到平均分 int avg = (sum - max - min ) / (arr.length-2); // 8.输出平均分 System.out.println(avg); &#125;&#125; 总结数组 第一种：动态初始化格式 建议:数据类型 [] 数组名 = new 数据类型 [数组的长度]; 数据类型 数组名 [] = new 数据类型 [数组的长度]; 第二种：静态初始化格式 数据类型 数组名 [] = new 数据类型 [] {元素1，元素2，元素3…..};—-&gt;简化 用的比较多的:数据类型 数组名 [] = {元素1，元素2，元素3…..}; 数组的好处： 1.可以一次开辟多个空间 2.可以对这多个空间进行统一管理 3.数组定义好之后，每个数组空间都有一个唯一编号（索引，下标，角标），我们在操作数组的时候，都是对统一的数组名和对应的索引来操作数组的每一个空间。赋值:数组名[索引]=值; 拿值:数组名[索引] 4.数组的索引是从0开始，到长度-1结束. 5.我们可以通过数组名.length这个属性来获取数组的长度。 6.获取数组对应索引空间上的数据：数组名[当前的索引]","categories":[],"tags":[]},{"title":"3_switch语句","slug":"3_switch语句","date":"2020-11-02T15:42:34.078Z","updated":"2020-11-03T16:25:25.993Z","comments":true,"path":"2020/11/02/3_switch语句/","link":"","permalink":"http://yoursite.com/2020/11/02/3_switch%E8%AF%AD%E5%8F%A5/","excerpt":"1. switch语句1.1 分支语句switch语句 格式 123456789101112switch (表达式) &#123; case 1: 语句体1; break; case 2: 语句体2; break; ... default: 语句体n+1; break;&#125; 执行流程：","text":"1. switch语句1.1 分支语句switch语句 格式 123456789101112switch (表达式) &#123; case 1: 语句体1; break; case 2: 语句体2; break; ... default: 语句体n+1; break;&#125; 执行流程： 首先计算出表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 1.2 switch案例-减肥计划 需求：键盘录入星期数，显示今天的减肥活动 1234567周一：跑步 周二：游泳 周三：慢走 周四：动感单车周五：拳击 周六：爬山 周日：好好吃一顿 示例代码： 1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args)&#123; // 1. 键盘录入星期数据，使用变量接收 Scanner sc = new Scanner(System.in); System.out.println(\"请输入\"); int week = sc.nextInt(); // 2. 多情况判断，采用switch语句实现 switch(week)&#123; // 3. 在不同的case中，输出对应的减肥计划 case 1: System.out.println(\"跑步\"); break; case 2: System.out.println(\"游泳\"); break; case 3: System.out.println(\"慢走\"); break; case 4: System.out.println(\"动感单车\"); break; case 5: System.out.println(\"拳击\"); break; case 6: System.out.println(\"爬山\"); break; case 7: System.out.println(\"好好吃一顿\"); break; default: System.out.println(\"您的输入有误\"); break; &#125; &#125;&#125; 1.3 switch语句case穿透 概述 : 如果switch语句中,case省略了break语句, 就会开始case穿透 需求 : 键盘录入星期数，输出工作日、休息日 (1-5)工作日，(6-7)休息日 示例代码： 1234567891011121314151617181920212223242526272829303132/*case穿透是如何产生的? 如果switch语句中,case省略了break语句, 就会开始case穿透. 现象： 当开始case穿透，后续的case就不会具有匹配效果，内部的语句都会执行 直到看见break，或者将整体switch语句执行完毕，才会结束。*/public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入星期数:\"); int week = sc.nextInt(); switch(week)&#123; case 1: case 2: case 3: case 4: case 5: System.out.println(\"工作日\"); break; case 6: case 7: System.out.println(\"休息日\"); break; default: System.out.println(\"您的输入有误\"); break; &#125; &#125; &#125; 2. for循环2.1 循环语句-for循环 循环： 循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 for循环格式： 123for (初始化语句;条件判断语句;条件控制语句) &#123; 循环体语句;&#125; 格式解释： 初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去 循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去 执行流程： ①执行初始化语句 ②执行条件判断语句，看其结果是true还是false ​ 如果是false，循环结束 ​ 如果是true，继续执行 ③执行循环体语句 ④执行条件控制语句 ⑤回到②继续 2.2 for循环案例-输出数据1-5和5-1 需求：在控制台输出1-5和5-1的数据 示例代码： 12345678910111213public class ForTest01 &#123; public static void main(String[] args) &#123; //需求：输出数据1-5 for(int i=1; i&lt;=5; i++) &#123; System.out.println(i); &#125; System.out.println(\"--------\"); //需求：输出数据5-1 for(int i=5; i&gt;=1; i--) &#123; System.out.println(i); &#125; &#125;&#125; 2.3 for循环案例-求1-5数据和 需求：求1-5之间的数据和，并把求和结果在控制台输出 示例代码： 12345678910111213141516171819202122public class ForTest02 &#123; public static void main(String[] args) &#123; //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0 int sum = 0; //从1开始到5结束的数据，使用循环结构完成 for(int i=1; i&lt;=5; i++) &#123; //将反复进行的事情写入循环结构内部 // 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中 sum += i; /* sum += i; sum = sum + i; 第一次：sum = sum + i = 0 + 1 = 1; 第二次：sum = sum + i = 1 + 2 = 3; 第三次：sum = sum + i = 3 + 3 = 6; 第四次：sum = sum + i = 6 + 4 = 10; 第五次：sum = sum + i = 10 + 5 = 15; */ &#125; //当循环执行完毕时，将最终数据打印出来 System.out.println(\"1-5之间的数据和是：\" + sum); &#125;&#125; 本题要点： 今后遇到的需求中，如果带有求和二字，请立即联想到求和变量 求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的 2.4 for循环案例-求1-100偶数和 需求：求1-100之间的偶数和，并把求和结果在控制台输出 } 示例代码： 123456789101112131415public class ForTest03 &#123; public static void main(String[] args) &#123; //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0 int sum = 0; //对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同 for(int i=1; i&lt;=100; i++) &#123; //对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数 if(i%2 == 0) &#123; sum += i; &#125; &#125; //当循环执行完毕时，将最终数据打印出来 System.out.println(\"1-100之间的偶数和是：\" + sum); &#125;&#125; 2.5 for循环案例-水仙花数 需求：在控制台输出所有的“水仙花数” 解释：什么是水仙花数？ 水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数 例如153 3*3*3 + 5*5*5 + 1*1*1 = 153 思路： 获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取 获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数 示例代码 1234567891011121314151617public class ForTest04 &#123; public static void main(String[] args) &#123; //输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束 for(int i=100; i&lt;1000; i++) &#123; //在计算之前获取三位数中每个位上的值 int ge = i%10; int shi = i/10%10; int bai = i/10/10%10; //判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等 if(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) &#123; //输出满足条件的数字就是水仙花数 System.out.println(i); &#125; &#125; &#125;&#125; 2.6 for循环案例-每行打印2个水仙花数(统计) 需求：在控制台输出所有的“水仙花数”，要求每行打印2个 示例代码： 12345678910111213141516171819202122232425262728293031323334public class Demo6For &#123; /* 需求：在控制台输出所有的“水仙花数”，要求每行打印2个 System.out.print (打印内容); 打印后不换行 System.out.println(打印内容); 打印后换行 分析: 1. 定义变量count，用于保存“打印过”的数量，初始值为0 2. 在判定和打印水仙花数的过程中，拼接空格, 但不换行，并在打印后让count变量+1，记录打印过的数量 3. 在每一次count变量+1后，判断是否到达了2的倍数，是的话，换行。 */ public static void main(String[] args)&#123; // 1. 定义变量count，用于保存“打印过”的数量，初始值为0 int count = 0; for(int i = 100; i &lt;= 999; i++)&#123; int ge = i % 10; int shi = i / 10 % 10; int bai = i / 10 / 10 % 10; if( (ge*ge*ge + shi*shi*shi + bai*bai*bai) == i)&#123; // 2. 在判定和打印水仙花数的过程中，拼接空格, 但不换行，并在打印后让count变量+1，记录打印过的数量 System.out.print(i + \" \"); count++; // 3. 在每一次count变量+1后，判断是否到达了2的倍数，是的话，换行 if(count % 2 == 0)&#123; System.out.println(); &#125; &#125; &#125; &#125;&#125; 本题要点： 今后如果需求带有统计xxx，请先想到计数器变量 计数器变量定义的位置，必须在循环外部 3. while循环3.1 循环语句-while循环 while循环完整格式： 12345初始化语句;while (条件判断语句) &#123; 循环体语句; 条件控制语句;&#125; while循环执行流程： ①执行初始化语句 ②执行条件判断语句，看其结果是true还是false ​ 如果是false，循环结束 ​ 如果是true，继续执行 ③执行循环体语句 ④执行条件控制语句 ⑤回到②继续 示例代码： 12345678910111213141516public class WhileDemo &#123; public static void main(String[] args) &#123; //需求：在控制台输出5次\"HelloWorld\" //for循环实现 for(int i=1; i&lt;=5; i++) &#123; System.out.println(\"HelloWorld\"); &#125; System.out.println(\"--------\"); //while循环实现 int j = 1; while(j&lt;=5) &#123; System.out.println(\"HelloWorld\"); j++; &#125; &#125;&#125; 3.2 while循环案例-珠穆朗玛峰 需求：世界最高山峰是珠穆朗玛峰(8844.43米=8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度? 示例代码： 1234567891011121314151617181920public class WhileTest &#123; public static void main(String[] args) &#123; //定义一个计数器，初始值为0 int count = 0; //定义纸张厚度 double paper = 0.1; //定义珠穆朗玛峰的高度 int zf = 8844430; //因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环 //折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度 while(paper &lt;= zf) &#123; //循环的执行过程中每次纸张折叠，纸张的厚度要加倍 paper *= 2; //在循环中执行累加，对应折叠了多少次 count++; &#125; //打印计数器的值 System.out.println(\"需要折叠：\" + count + \"次\"); &#125;&#125; 4. 循环细节4.1 循环语句-dowhile循环 完整格式： 12345初始化语句;do &#123; 循环体语句; 条件控制语句;&#125;while(条件判断语句); 执行流程： ① 执行初始化语句 ② 执行循环体语句 ③ 执行条件控制语句 ④ 执行条件判断语句，看其结果是true还是false 如果是false，循环结束 如果是true，继续执行 ⑤ 回到②继续 示例代码： 12345678910111213141516public class DoWhileDemo &#123; public static void main(String[] args) &#123; //需求：在控制台输出5次\"HelloWorld\" //for循环实现 for(int i=1; i&lt;=5; i++) &#123; System.out.println(\"HelloWorld\"); &#125; System.out.println(\"--------\"); //do...while循环实现 int j = 1; do &#123; System.out.println(\"HelloWorld\"); j++; &#125;while(j&lt;=5); &#125;&#125; 4.2 三种循环的区别 三种循环的区别 for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行） do…while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断） for循环和while的区别 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用 死循环（无限循环）的三种格式 for(;;){} while(true){} do {} while(true); 4.3 死循环 死循环格式 12345678910111213141516for死循环格式 :for(;;)&#123;&#125;while死循环格式 :while(true)&#123;&#125;do..while死循环格式 :do&#123;&#125;while(true); 死循环案例 12345678910111213141516171819202122232425262728/* 问题: 死循环有应用场景吗? 例如: 键盘录入一个1-100之间的整数 顾虑: 键盘录入是用户操作的, 用户就可能会出现一些误操作的现象 */public static void main(String[] args) &#123; /* for(;;)&#123; System.out.println(\"我停不下来了~\"); &#125; */ /* while(true)&#123; System.out.println(\"我停不下来了~\"); &#125; */ do&#123; System.out.println(\"我停不下来了~\"); &#125;while(true); System.out.println(\"看看我能被执行吗?~\"); // 无法访问的语句&#125;&#125; 4.4 跳转控制语句 跳转控制语句（break） 跳出循环，结束循环 跳转控制语句（continue） 跳过本次循环，继续下次循环 注意： continue只能在循环中进行使用！ 123456789101112131415161718public class Demo1Continue &#123; /* continue : 跳过某次循环体内容的执行 注意：使用是基于条件控制, 在循环内部使用. 需求: 模拟电梯上行的过程 1-24层, 4层不停. */ public static void main(String[] args)&#123; for(int i = 1; i &lt;= 24; i++)&#123; if(i == 4)&#123; continue; &#125; System.out.println(i + \"层到了~\"); &#125; &#125; &#125; 123456789101112131415161718public class Demo2Break &#123; /* break : 终止循环体内容的执行 注意：使用是基于条件控制的 break语句只能在循环和switch中进行使用. 需求: 模拟20岁工作到80岁, 60岁退休. */ public static void main(String[] args)&#123; for(int i = 20; i &lt;= 80; i++)&#123; if(i == 60)&#123; break; // 结束整个循环 &#125; System.out.println(i + \"岁正在上班\"); &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Scanner;public class Test &#123; /* 需求：程序运行后，用户可多次查询星期对应的减肥计划，直到输入0，程序结束 步骤: 1. 不明确用户操作几次, 使用死循环包裹业务逻辑 2. 匹配到0的时候，使用break结束循环死循环 */ public static void main (String[] args)&#123; lo:while(true)&#123; System.out.println(\"请输入您要查看的星期数:\"); System.out.println(\"(如无需继续查看,请输入0退出程序)\"); // 1. 键盘录入星期数据，使用变量接收 Scanner sc = new Scanner(System.in); int week = sc.nextInt(); // 2. 多情况判断，采用switch语句实现 switch(week)&#123; // 3. 在不同的case中，输出对应的减肥计划 case 0: System.out.println(\"感谢您的使用\"); break lo; case 1: System.out.println(\"跑步\"); break; case 2: System.out.println(\"游泳\"); break; case 3: System.out.println(\"慢走\"); break; case 4: System.out.println(\"动感单车\"); break; case 5: System.out.println(\"拳击\"); break; case 6: System.out.println(\"爬山\"); break; case 7: System.out.println(\"好好吃一顿\"); break; default: System.out.println(\"您的输入有误\"); break; &#125; &#125; &#125;&#125; 5. Random5.1 Random产生随机数（掌握） 概述： Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能 API后续课程详细讲解，现在可以简单理解为Java已经写好的代码 使用步骤： 导入包 import java.util.Random; 创建对象 Random r = new Random(); 产生随机数 int num = r.nextInt(10); 解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19 示例代码： 12345678910111213141516171819202122232425262728293031import java.util.Random;public class Demo1Random &#123; /* Random : 产生随机数 1. 导包 : import java.util.Random; 导包的动作必须出现在类定义的上面 2. 创建对象 : Random r = new Random(); 上面这个格式里面，r 是变量名，可以变，其他的都不允许变 3. 获取随机数 : int number = r.nextInt(10); //获取数据的范围：[0,10) 包括0,不包括10 上面这个格式里面，number是变量名，可以变，数字10可以变。其他的都不允许变 需求: 产生随机数1-10之间的 */ public static void main(String[] args)&#123; // 2. 创建对象 Random r = new Random(); for(int i = 1; i &lt;= 10; i++)&#123; // 3. 获取随机数 int num = r.nextInt(10) + 1; // 1-10 System.out.println(num); &#125; &#125;&#125; 5.3 Random练习-猜数字（应用） 需求： 程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？ 当猜错的时候根据不同情况给出相应的提示 A. 如果猜的数字比真实数字大，提示你猜的数据大了 B. 如果猜的数字比真实数字小，提示你猜的数据小了 C. 如果猜的数字与真实数字相等，提示恭喜你猜中了 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Scanner;import java.util.Random;public class Test &#123; /* 需求：程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？ 当猜错的时候根据不同情况给出相应的提示 如果猜的数字比真实数字大，提示你猜的数据大了 如果猜的数字比真实数字小，提示你猜的数据小了 如果猜的数字与真实数字相等，提示恭喜你猜中了 1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入 2. 使用Random产生一个1-100之间的数, 作为要猜的数 3. 键盘录入用户猜的的数据 4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示 5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹 6. 猜对之后, break结束. */ public static void main(String[] args)&#123; // 1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入 Random r = new Random(); Scanner sc = new Scanner(System.in); // 2. 使用Random产生一个1-100之间的数, 作为要猜的数 int randomNum = r.nextInt(100) + 1; // 5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹 while(true)&#123; // 3. 键盘录入用户猜的的数据 System.out.println(\"请输入您猜的数据:\"); int num = sc.nextInt(); // 4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示 if(num &gt; randomNum)&#123; System.out.println(\"猜大了\"); &#125;else if(num &lt; randomNum)&#123; System.out.println(\"猜小了\"); &#125;else&#123; // 6. 猜对之后, break结束. System.out.println(\"恭喜,猜中了\"); break; &#125; &#125; System.out.println(\"感谢您的使用\"); &#125;&#125;","categories":[],"tags":[]},{"title":"2_Java基础语法","slug":"2_Java基础语法","date":"2020-11-01T15:49:40.774Z","updated":"2020-11-04T15:28:23.009Z","comments":true,"path":"2020/11/01/2_Java基础语法/","link":"","permalink":"http://yoursite.com/2020/11/01/2_Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"1_Java概述","slug":"1_Java概述","date":"2020-11-01T15:48:20.534Z","updated":"2020-11-03T16:25:34.462Z","comments":true,"path":"2020/11/01/1_Java概述/","link":"","permalink":"http://yoursite.com/2020/11/01/1_Java%E6%A6%82%E8%BF%B0/","excerpt":"1. Java概述1.1 Java语言背景介绍（了解）语言：人与人交流的一种方式 计算机语言：人与计算机进行交流的一种方式,java就是其中一种最优秀的方式之一. Java语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言","text":"1. Java概述1.1 Java语言背景介绍（了解）语言：人与人交流的一种方式 计算机语言：人与计算机进行交流的一种方式,java就是其中一种最优秀的方式之一. Java语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言 Java之父：高司令 2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：https://www.oracle.com java语言的三个版本： ​ JavaSE: Java 语言的（标准版），用于桌面应用的开发，是其他两个版本的基础 ​ JavaME: Java 语言的（小型版），用于嵌入式消费类电子设备 ​ JavaEE: Java 语言的（企业版），用于 Web 方向的网站开发 1.2 Java语言跨平台原理（理解）平台:操作系统 跨平台:同一套java代码可以不经任何修改在任意操作系统上运行. 操作系统:windows,mac,linux. java程序的跨平台是通过jvm(java虚拟机,当做一个假想的计算机)解决的,但jvm本身不垮平台,我们只需要在对应操作系统上安装对应jv即可. Java程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。 1.3 JRE和JDK（记忆）开发的三个步骤: 1.编写程序 2.编译程序 3.运行程序 JVM（Java Virtual Machine），java虚拟机,主要是解决跨平台. JRE（Java Runtime Environment），java运行环境,包含jvm+核心类库. JDK（Java Development Kit）,java开发工具包:jre+开发工具 总结：jdk(开发工具包) = jre(jvm+核心类库)+ 开发工具 1.4 JDK的下载和安装（应用）版本:我们的程序是需要根据社会的发展和需求进行不断的更新和迭代.进而更新我们写的程序,版本就依次叠加. java5里程碑 java8公司用的最多 我们学习12,11 1.4.1 下载通过官方网站获取JDK http://www.oracle.com 注意：不同的操作系统需要下载对应的jdk. 1.4.2 安装傻瓜式安装，下一步即可。但默认的安装路径是在C:\\Program Files下，为方便统一管理建议修改安装路径，将与开发相关的软件都安装到一个目录下，例如：E:\\develop。 注意：安装路径不要包含中文或者空格等特殊字符（使用纯英文目录）。 1.4.3 JDK的安装目录介绍 目录名称 说明 bin 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 conf 该路径下存放了JDK的相关配置文件。 include 该路径下存放了一些平台特定的头文件。 jmods 该路径下存放了JDK的各种模块。 legal 该路径下存放了JDK各模块的授权文档。 lib 该路径下存放了JDK工具的一些补充JAR包。 2. 第一个演示程序2.1 常用DOS命令（应用）在接触集成开发环境之前，我们需要使用命令行窗口对java程序进行编译和运行，所以需要知道一些常用DOS命令。 1、打开命令行窗口的方式：win + r打开运行窗口，输入cmd，回车。 2、常用命令及其作用 操作 说明 盘符名称: 盘符切换。E:回车，表示切换到E盘。 dir 查看当前路径下的内容。 cd 目录 进入单级目录。cd itheima cd .. 回退到上一级目录。 cd 目录1\\目录2... 进入多级目录。cd itheima\\JavaSE cd / 回退到盘符目录。 cls 清屏。 exit 退出命令提示符窗口。 2.2 Path环境变量的配置（应用）我们希望在任何情况下都能去运行我们jdk的bin目录下的开发工具。 1.如果我们想要去执行某个应用程序的时候，想在任何目录下去执行，那我们应该怎么办？ a.我们手动的点入到这个命令所在的文件夹,然后打开dos窗口,进行执行 b.我们讲此命令的地址配置到环境变量中,就可以在任意目录下去执行我们的命令. 原理:我们在执行命令的时候,首先系统回去当前文件夹下面去寻找有没有这个命令,如果有,就执行,如果没有就去环境变量中去寻找,有就执行,没有就报错, 2.3 HelloWorld案例（应用）HelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。 各种计算机语言都习惯使用该案例作为第一个演示案例。 2.3.1 Java程序开发运行流程开发Java程序，需要三个步骤: 编写程序: 新建一个记事本,将后缀名改成 文件名.java 编译程序:javac 文件名.java 执行程序: java 文件名 2.3.2 HelloWorld案例的编写1、新建文本文档文件，修改名称为HelloWorld.java。 2、用记事本打开HelloWorld.java文件，输写程序内容。 12345public class HelloWorld&#123; public static void main(String [] args)&#123; System.out.println(\"HelloWorld\"); &#125;&#125; 2.3.3 HelloWorld案例的编译和运行存文件，打开命令行窗口，将目录切换至java文件所在目录，编译java文件生成class文件，运行class文件。 编译：javac 文件名.java 范例：javac HelloWorld.java 执行：java 文件名 范例：java HelloWorld 2.4 HelloWorld案例详解（理解） java程序都是由一个个类组成的,类是java程序的基本组成单位.类是由方法和其他东西组成. 类的定义格式:class 类名{ } main方法是官方定义好的方法,他是程序的入口,一个类如果需要执行,必须有main(主方法)方法. jvm只认main方法. main方法的定义格式为: public static void main(String [] args){ } 2.5 HelloWorld案例常见问题（理解）2.5.1 BUG程序在运行过程中遇到的错误或没有达到预期效果的转态. 2.5.2 BUG的解决1、具备识别BUG的能力：多看 2、具备分析BUG的能力：多做 3、具备解决BUG的能力：多查 2.5.3 HelloWorld案例常见问题1、非法字符问题。Java中的符号都是英文格式的。 2、大小写问题。Java语言对大小写敏感（区分大小写）。 3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。 4、编译命令后的java文件名需要带文件后缀.java 5、运行命令后的class文件名（类名）不带文件后缀 2.6 Notepad++软件的安装和使用（应用）2.6.1 什么要使用Notepad++软件Notepad++功能比windows中的自带记事本功能强大，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。Notepad++有行号，能够快速定位问题位置，还有语法高亮度显示、代码折叠等功能。而且它是免费的。 2.6.2 Notepad++软件安装安装：傻瓜式安装，一直下一步即可。建议也安装到统一的开发软件目录下，比如E:\\develop。 2.6.3Notepad++软件配置安装完毕之后，为了使用方便，做一个简单的配置：修改默认语言和编码。 3. java基础语法3.1 注释（理解）注释是对代码的解释和说明文字，可以提高程序的可读性，因此在程序中添加必要的注释文字十分重要。Java中的注释分为三种： 单行注释。 1//从双斜线开始到本行尾结束,都不参与程序的编译和执行 多行注释。 1234/*这里面涉及到的多行信息都不参与程序的编译和执行*/注意：多行注释不能嵌套使用。 123456789101112131415161718192021/*java是由一个个类组成,类是java程序基本组成单位类的定义格式:public class 类名&#123; &#125;*/public class A&#123; /* 这是主方法 他是程序的入口,一个类需要执行,必须有主方法,他是由官方定义好的 他的定义格式 public static void main(String [] args)&#123; &#125; */ public static void main(String [] args)&#123; //这是一条输出语句,双引号里面写啥,控制台就打印什么 System.out.println(\"AD\"); &#125;&#125; 文档注释。文档注释以/**开始，以*/结束。（以后讲) 3.2 关键字（理解）关键字是被java官方赋予了特殊含义的单词. 关键字的特点： ​ 1.全部由字母组成,并且字母都是小写 ​ 2.常见的代码编辑器会对其进行高亮显示. ​ 例如:class public static void 3.3 常量（应用）常量：在程序的运行中,其值不可发生改变的量,叫做常量. Java中的常量分类： ​ 字符串常量 :被双引号引起来的内容叫做字符串,理解为生活中的一句话,包括0个或多个字符 ​ 整数常量 : 所有整数 ​ 小数常量 :所有小数 ​ 字符常量 :被单引号引起来的单个字符,就是一个字 ​ 布尔常量 :只有两个 true(真,正确的,对的) 和 false(假,错误的,不对的) ​ 空常量 : null 不能直接打印 除空常量外，其他常量均可使用输出语句直接输出。 123456789101112131415161718192021222324252627public class A&#123; /* 这是主方法 他是程序的入口,一个类需要执行,必须有主方法,他是由官方定义好的 他的定义格式 public static void main(String [] args)&#123; &#125; */ public static void main(String [] args)&#123; //这是一条输出语句,双引号里面写啥,控制台就打印什么 //被双引号引起来的内容叫做字符串,理解为生活中的一句话 System.out.println(\"你好,我好,大家好\"); //所有整数 System.out.println(10); // System.out.println(\"10\"); //小数 所有小数 System.out.println(10.0); //字符 System.out.println('我'); //布尔常量 true和false System.out.println(true); System.out.println(false); //空常量 null 不能被打印 // System.out.println(null); &#125;&#125; 3.4 变量的介绍(理解)变量其实就是内存中的一块存储空间,里面存在可能会经常发生改变的数值 变量也是在程序运行中,值可能会发生改变的量. 变量的定义格式： ​ 数据类型 变量名 = 初始化值; ​ 数据类型：马上讲解 ​ 变量名：自己起的名字 ​ 数据值： 一开始,你自己定,开始你想他是多少就是多少. 3.5 数据类型（应用）3.5.1 计算机存储单元我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”， 通常用大写字母”B”表示，字节是由连续的8个位组成。 除了字节外还有一些常用的存储单位，其换算单位如下： 1B = 8b 1kb = 1024B 1mb = 1024kb 1Gb = 1024mb 1Tb = 1024Gb 3.5.2 Java中的数据类型Java是一个强类型语言，Java中的数据必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。 Java中的基本数据类型：四类8种 数据类型 关键字 内存占用 取值范围 整数类型 byte 1 -128~127 short 2 -32768~32767 int(默认) 4 -2的31次方到2的31次方-1 long 8 -2的63次方到2的63次方-1 浮点类型 float 4 负数：-3.402823E+38到-1.401298E-45 正数： 1.401298E-45到3.402823E+38 double(默认) 8 负数：-1.797693E+308到-4.9000000E-324 正数：4.9000000E-324 到1.797693E+308 字符类型 char 2 0-65535 布尔类型 boolean 1 true，false 引用数据类型:类,数组,接口. 说明： ​ e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。 ​ 在java中整数默认是int类型，浮点数默认是double类型。 3.6 变量（应用）3.6.1 变量的定义变量：变量其实就是内存中的一块存储空间,里面存在可能会经常发生改变的数值 变量也是在程序运行中,值可能会发生改变的量. 从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化。 变量的定义格式： 123数据类型 变量名 = 初始化值; // 声明变量并赋值int age = 18;System.out.println(age); 或者(扩展) 123456// 先声明，后赋值（使用前赋值即可）数据类型 变量名;变量名 = 初始化值;double money;money = 55.5;System.out.println(money); 还可以(扩展) 在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。但不建议使用这种方式，降低程序的可读性。 123456789int a = 10, b = 20; // 定义int类型的变量a和b，中间使用逗号隔开System.out.println(a);System.out.println(b);int c,d; // 声明int类型的变量c和d，中间使用逗号隔开c = 30;d = 40;System.out.println(c);System.out.println(d); 3.6.2 变量的修改123int a = 10;a = 30; //修改变量的值System.out.println(a); 变量前面不加数据类型时，表示修改已存在的变量的值。 1234567891011121314151617181920212223242526272829303132333435363738public class Demo&#123; public static void main(String [] args)&#123; //变量的定义格式 数据类型 变量名 = 初始化值; 定义变量并赋值 /*int a = 10; double d = 3.14; char c = '我'; boolean b = true; //使用变量 直接使用变量名即可 //直接打印 System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); // 修改值 变量名 = 新值; a = 20; b= false; c='你'; d = 5.20; System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); //第二种定义格式 //定义一个变量不复制 数据类型 变量名; int aa ; // 变量名 = 初始化值; aa = 60; System.out.println(aa);*/ //定义变量的第三种格式 一次性定义多个相同类型的变量 //数据类型 变量名 = 初始化值,变量名 = 初始化值.... int a = 10,b=20,c=30; System.out.println(a); System.out.println(b); System.out.println(c); &#125;&#125; 3.7 变量的注意事项(理解) 在同一对花括号中，变量名不能重复。 变量在使用之前，必须初始化（赋值）。 定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。 定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的，类型不兼容。 3.8 键盘录入（理解）我们可以通过 Scanner 类来获取用户的输入。使用步骤如下： 1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。 1import java.util.Scanner; 2、创建Scanner对象。 1Scanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变 3、接收数据 1int i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。 示例： 1234567891011121314//导包 (告诉高司令我要用一下你写的类)import java.util.Scanner;public class Demo2&#123; public static void main(String [] args)&#123; // 数据类型 变量名 = 初始化值; //创建对象(使用规则) sc是变量名 除了他可以改 其他的都不要改 Scanner sc1 = new Scanner(System.in); //接收用户输入的值 System.out.println(\"请您输入一个数字\"); int a = sc1.nextInt(); System.out.println(a); &#125; &#125; 3.9 标识符（理解）标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。 Java中标识符的组成规则： 1.数字,字母,_(下划线),$组成. 2.不能以数字开头 3.区分大小写. 4.不能是关键字 Java中标识符的命名约定： ​ 小驼峰式命名：变量,方法 ​ 首字母小写,从第二个单词开始首字母大写 ​ 例如：username、studentNumber等。 ​ 大驼峰式命名：类名 ​ 所有组成单词首字母大写. ​ 例如:HelloWold​ ​","categories":[],"tags":[]}],"categories":[],"tags":[]}