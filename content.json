{"meta":{"title":"xiaojujing's blogs","subtitle":"","description":"some blogs of xiaojujing","author":"xiaojujing","url":"http://xiaojujing.com","root":"/"},"pages":[],"posts":[{"title":"排序","slug":"47_排序","date":"2020-12-21T01:03:19.000Z","updated":"2020-12-27T13:29:19.007Z","comments":true,"path":"2020/12/21/47_排序/","link":"","permalink":"http://xiaojujing.com/2020/12/21/47_%E6%8E%92%E5%BA%8F/","excerpt":"1、归并排序 分治要排序队列为两部分，归并时从两个子队列选取","text":"1、归并排序 分治要排序队列为两部分，归并时从两个子队列选取 2、堆排序 将无序队列构建成一个堆，将堆顶元素与末尾元素交换；重新调整结构使其满足堆定义 4、排序算法的比较","categories":[],"tags":[{"name":"归并排序 堆排序","slug":"归并排序-堆排序","permalink":"http://xiaojujing.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E5%A0%86%E6%8E%92%E5%BA%8F/"}]},{"title":"Token与第三方通信","slug":"46_Spring","date":"2020-12-21T01:00:34.000Z","updated":"2020-12-27T13:29:42.607Z","comments":true,"path":"2020/12/21/46_Spring/","link":"","permalink":"http://xiaojujing.com/2020/12/21/46_Spring/","excerpt":"Spring1、IOC 依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦，动态地将某种依赖关系注入到对象之中","text":"Spring1、IOC 依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦，动态地将某种依赖关系注入到对象之中 2、AOP","categories":[],"tags":[]},{"title":"Java数据结构","slug":"45_容器","date":"2020-12-21T00:59:09.000Z","updated":"2020-12-30T06:12:27.289Z","comments":true,"path":"2020/12/21/45_容器/","link":"","permalink":"http://xiaojujing.com/2020/12/21/45_%E5%AE%B9%E5%99%A8/","excerpt":"容器1、ArrayList扩容机制 默认初始化容量为10，无参构造赋值的是空数组，在添加第一个元素时才真正赋值","text":"容器1、ArrayList扩容机制 默认初始化容量为10，无参构造赋值的是空数组，在添加第一个元素时才真正赋值 1.5倍扩容 https://www.cnblogs.com/baichunyu/p/12965241.html 2、HashMap2.1、jdk1.7 扩容大小为2的幂次方，Entry+链表 默认第一次扩容&gt;=12&amp;&amp;hash冲突，必定扩容27 2.2、jdk1.8 Node+链表+红黑树(&gt;=8) 13必定扩容 https://www.cnblogs.com/yanzige/p/8392142.html 3、ConcurrentHashMaphttps://www.cnblogs.com/zerotomax/p/8687425.html 3.1、线程安全 1.7分段锁、每个Entry既是一个链表又是一个ReentrantLock（缺点：Hash过程比普通HashMap要长） 1.8syn和cas","categories":[],"tags":[]},{"title":"day02探花交友","slug":"41_day02探花交友","date":"2020-12-07T01:36:19.000Z","updated":"2020-12-27T13:28:39.131Z","comments":true,"path":"2020/12/07/41_day02探花交友/","link":"","permalink":"http://xiaojujing.com/2020/12/07/41_day02%E6%8E%A2%E8%8A%B1%E4%BA%A4%E5%8F%8B/","excerpt":"day02探花交友1 Nginx配置","text":"day02探花交友1 Nginx配置12345location [=| |^~|~*|~|/] /url/ &#123;...&#125;匹配顺序 [1精准匹配|2空格字符串匹配|3优于正则匹配|4正则匹配不区分大小写|5正则区分大小写|6通用匹配] client_max_body_size 20M;nginx对上传文件的大小有限制，默认是1M，当超过大小的时候会报413（too large）错误。这个时候我们要修改nginx的参数 2 登陆、圈子、视频功能 Controller Service SmsService sendCheckCode UserService login queryUserByToken UserInfoService saveUserInfo saveLogo QuanziApiImpl savePublish queryPublishList saveLikeComment removeComment saveLoveComment saveComment queryCommentCount queryPublishById queryCommentList RecommendUserApiImpl queryWithMaxScore queryPageInfo VideoApiImpl saveVideo queryVideoList followUser disFollowUser 3 模板类及方法3.1 Jackson ObjectMapper（） 1234对象转为字符串mapper.writeValueAsString(user);json字符串转为对象mapper.readValue(jsonStr, User.class); 3.2 Mybatis-Plus queryMapper（）条件构造器 1234Entity对象封装操作类，常用方法eq 等于 | ne 不等于 | gt 大于 | ge 大于等于 | lt 小于 | le 小于等于between | like | in | group by | orderByAsc | orderByDesc having | or | and 3.3 RedisTemplate12345678判断key是否存在hasKey(key)获取缓存opsForValue().get(key)添加缓存set(key, value)添加缓存并设置过期时间set(key, value, time, TimeUnit.SECONDS) 3.4 RocketMQTemplate12发送消息convertAndSend(&quot;topic&quot;,User) 3.5 ResponseEntity​ 泛型响应数据，@RestController+@RequestBody；前端页面接收响应数据：在ajax中使用statusCode处理结果。","categories":[],"tags":[{"name":"Nginx 模板","slug":"Nginx-模板","permalink":"http://xiaojujing.com/tags/Nginx-%E6%A8%A1%E6%9D%BF/"}]},{"title":"JVM03","slug":"44_JVM03","date":"2020-12-05T08:41:36.000Z","updated":"2020-12-27T13:29:10.622Z","comments":true,"path":"2020/12/05/44_JVM03/","link":"","permalink":"http://xiaojujing.com/2020/12/05/44_JVM03/","excerpt":"JVM031 新生代GC","text":"JVM031 新生代GC 大部分正常对象，创建时都会优先分配进JVM堆内存新生代。 新生代如果对象满时会触发Minor GC回收掉没有引用的垃圾对象。 如果有对象躲过了十多次的垃圾回收，就会放入老年代。 2扩展java中static变量存在内存什么区域​ 内存总体一共分为了4个部分(stack segment、heap segment、code segment、data segment) 。 ​ 当我们在程序中，申明一个局部变量的时候，此变量就存放在了 stack segment(栈)当中； 当new 一个对象的时候，此对象放在了heap segment(堆)当中； 而static 的变量或者字符串常量 则存在在 data segment(数据区)中； 那么类中方法的话，是存在在 code segment(代码区)中了。","categories":[],"tags":[]},{"title":"JVM02","slug":"43_JVM02","date":"2020-12-04T13:05:14.000Z","updated":"2020-12-27T13:29:02.360Z","comments":true,"path":"2020/12/04/43_JVM02/","link":"","permalink":"http://xiaojujing.com/2020/12/04/43_JVM02/","excerpt":"JVM021、JVM内存区域","text":"JVM021、JVM内存区域 JVM内存原理图 1.1、方法区​ 用来存放加载的Java类，jdk1.8之后更名为元数据空间。 1.2、栈内存​ 用于存放类中的成员变量以及每个方法的栈帧。 1.3、堆内存​ 用于存放对象的实例化数据。 2、Tomcat中的类加载机制 Tomcat的非双亲委派模型 2.1、我们思考一下：Tomcat是个web容器， 那么它要解决什么问题： 一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机。 web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来 web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情。所以，web容器需要支持 jsp 修改后不用重启。 2.2、Tomcat 如果使用默认的类加载机制行不行？​ 答案是不行的。 ​ 为什么？我们看，第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的累加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。 ​ 第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。第三个问题和第一个问题一样。 ​ 我们再看第四个问题，我们想我们要怎么实现jsp文件的热修改，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。 3、垃圾回收​ Java堆内存中的对象包含了对象实例化数据和本身信息两部分，占用了内存资源。但是当栈中的方法执行完并出栈，局部变量也被释放，就没有再指向堆中的对象，这也就意味着这个对象没有用了。在有限的内存资源下，JVM提供了垃圾回收机制，只要启动一个JVM进程就会自带一个后台线程不断检查堆内存中的各个实例对象，如果某个实例对象没有任何一个局部变量，也没有任何一个类的静态变量包括常量等指向它，这个线程就会把这个没有指向的实例对象回收掉，从内存清除。 4、方法区类回收​ 方法区也有垃圾回收机制，必须满足下面的条件: 首先该类的所有实例对象已经从Java堆内存里回收 其次该类的ClassLoader已经被回收 最后该类的Class对象没有任何引用 5、JVM分代模型 新生代： 对象创建后立马被回收 老年代： 对象创建后长时间不被回收 6、扩展小结 Java多线程每个线程都有自己的虚拟栈，但是共享一个堆。 静态变量多线程不安全。 每一个类都需要它的类加载器和这个类本身同一确立其在JVM中的唯一性，为了避免重复加载所有用到双亲委派模型。","categories":[],"tags":[{"name":"内存管理 Tomcat 垃圾回收","slug":"内存管理-Tomcat-垃圾回收","permalink":"http://xiaojujing.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Tomcat-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]},{"title":"JVM01","slug":"42_JVM01","date":"2020-12-01T11:38:38.000Z","updated":"2020-12-27T13:28:46.594Z","comments":true,"path":"2020/12/01/42_JVM01/","link":"","permalink":"http://xiaojujing.com/2020/12/01/42_JVM01/","excerpt":"JVM011 Java代码怎么运行1.1 编译","text":"JVM011 Java代码怎么运行1.1 编译​ Javac是一种编译器，能将一种语言规范转化成另外一种语言规范，通常编译器都是将便于人理解的语言规范转化成机器容易理解的语言规范，如C/C++或者汇编语言都是将源代码直接编译成目标机器码，这个目标机器代码是CPU直接执行的指令集合。这些指令集合也就是底层的一种语言规范。 ​ Javac的编译器也是将Java这种对人非常友好的编程语言编译成对对所有机器都非常友好的一种语言。这种语言不是针对某种机器或某个平台。怎么消除不同种类，不同平台之间的差异这个任务就有JVM来完成，而Javac的任务就是将Java源代码语言转化为JVM能够识别的一种语言，然后由JVM将JVM语言再转化成当前这个机器能够识别的机器语言。 ​ Javac的任务就是将Java源代码编译成Java字节码，也就是JVM能够识别的二进制代码，从表面看是将.java文件转化为.class文件。而实际上是将Java源代码转化成一连串二进制数字，这些二进制数字是有格式的，只有JVM能够真确的识别他们到底代表什么意思。 ​ 编译器把一种语言规范转化为另一种语言规范的这个过程需要哪些步骤？回答这个问题需要参照《编译原理》，总结过程如下： 词法分析：读取源代码，一个字节一个字节的读进来，找出这些词法中我们定义的语言关键词如：if、else、while等，识别哪些if是合法的哪些是不合法的。这个步骤就是词法分析过程。词法分析的结果：就是从源代码中找出了一些规范化的token流，就像人类语言中，给你一句话你要分辨出哪些是一个词语，哪些是标点符号，哪些是动词，哪些是名词。 语法分析：就是对词法分析中得到的token流进行语法分析，这一步就是检查这些关键词组合在一起是不是符合Java语言规范。如if的后面是不是紧跟着一个布尔型判断表达式。语法分析的结果：就是形成一个符合Java语言规定的抽象语法树，抽象语法树是一个结构化的语法表达形式，它的作用是把语言的主要词法用一个结构化的形式组织在一起。这棵语法树可以被后面按照新的规则再重新组织。 语义分析：语法分析完成之后也就不存在语法问题了，语义分析的主要工作就是把一些难懂的，复杂的语法转化成更简单的语法。就如难懂的文言文转化为大家都懂的百话文，或者是注释一下一些不懂的成语。语义分析结果：就是将复杂的语法转化为简单的语法，对应到Java就是将foreach转化为for循环，还有一些注释等。最后生成一棵抽象的语法树，这棵语法树也就更接近目标语言的语法规则。 字节码生成：将会根据经过注释的抽象语法树生成字节码，也就是将一个数据结构转化为另外一个数据结构。就像将所有的中文词语翻译成英文单词后按照英文语法组装文英文语句。代码生成器的结果就是生成符合java虚拟机规范的字节码。 1.2 JVM运行 JVM运行原理图 ​ 在JVM中加载了编译生成的类字节码文件，并通过解释器转化成机器能识别的指令，再执行代码。 1.3 怎么防止反编译​ 在编译的时候，对字节码进行加密；在类加载的时候，对加密的类采用自定义的类加载器来解密文件。 2 类加载过程 类加载过程原理图 2.1 验证​ 检查字节码文件是否符合规范。 2.2 准备​ 给类分配内存空间（如：成员变量及附初值等）。 2.3 解析​ 把符号引用替换为直接引用。 2.4 初始化​ 赋值并进行初始化全过程（如：加载父类等）。 3 双亲委派机制 双亲委派原理图 3.1、启动类加载器​ Bootstrap ClassLoader主要负责加载我们在机器上安装在Java目录下的核心类。 3.2、扩展类加载器​ Extension ClassLoader加载Java目录下lib\\ext中的类。 3.3、应用程序类加载器​ Application ClassLoader负责加载“ClassPath”环境变量所指定的路径中的类。 3.4、自定义类加载器​ 继承ClassLoader类，重写里面的方法，指定加载的路径。","categories":[],"tags":[{"name":"编译 类加载 双亲委派","slug":"编译-类加载-双亲委派","permalink":"http://xiaojujing.com/tags/%E7%BC%96%E8%AF%91-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"}]},{"title":"day01探花交友","slug":"40_day01探花交友","date":"2020-11-27T15:32:01.000Z","updated":"2020-12-07T01:37:25.856Z","comments":true,"path":"2020/11/27/40_day01探花交友/","link":"","permalink":"http://xiaojujing.com/2020/11/27/40_day01%E6%8E%A2%E8%8A%B1%E4%BA%A4%E5%8F%8B/","excerpt":"day01探花交友​ 今天内容分为：阿里云短信服务、OSS、登陆模块开发。","text":"day01探花交友​ 今天内容分为：阿里云短信服务、OSS、登陆模块开发。 1、阿里云短信服务​ 短信服务是互联网项目的一个常用功能，通常在登陆时用于用户身份校验。对于我们普通的Java开发者，想要自己开发短信服务的功能想必是可以做到的，但是问题在于我们没有通信牌照，因此通常要选用第三方的SDK服务。阿里云短信服务SMS（Short Message Server）就是一个还不错的选项，对于快速集成SMS，阿里云提供了非常规范、详细的开发文档，具体请参照： 下面介绍一些注意细节： 1.1、签名​ 想要快速发送短信，首先要申请一个签名，这个签名其实同时也用于其他服务，其中包含了AccessKey ID和AccessKey Secret通常在各个功能的模板代码中必不可少，而且在申请完成时只显示一次，之后不再显示，这里请注意一定要保存好！！！ 2、OSS​ 对象存储OSS是阿里的一款海量、安全、高可靠的云存储服务，对于实际项目中的需要存储的大量的图片、视频、音频的文件提供了一套解决方案。 2.1、用户​ 这里注意OSS是要创建一个用户，并且为其添加管理权限。","categories":[],"tags":[{"name":"SDK集成","slug":"SDK集成","permalink":"http://xiaojujing.com/tags/SDK%E9%9B%86%E6%88%90/"}]},{"title":"26_基础加强01","slug":"39_基础加强01","date":"2020-11-13T15:09:38.000Z","updated":"2020-11-13T15:11:01.282Z","comments":true,"path":"2020/11/13/39_基础加强01/","link":"","permalink":"http://xiaojujing.com/2020/11/13/39_%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA01/","excerpt":"1.类加载器1.1类加载器【理解】 作用 负责将.class文件（存储的物理文件）加载在到内存中","text":"1.类加载器1.1类加载器【理解】 作用 负责将.class文件（存储的物理文件）加载在到内存中 1.2类加载的过程【理解】 类加载时机 创建类的实例（对象） 调用类的类方法 访问类或者接口的类变量，或者为该类变量赋值 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 类加载过程 加载 通过包名 + 类名，获取这个类，准备用流进行传输 在这个类加载到内存中 加载完毕创建一个class对象 链接 验证 确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全 (文件中的信息是否符合虚拟机规范有没有安全隐患) 准备 负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值 (初始化静态变量) 解析 将类的二进制数据流中的符号引用替换为直接引用 (本类中如果用到了其他类，此时就需要找到对应的类) 初始化 根据程序员通过程序制定的主观计划去初始化类变量和其他资源 (静态变量赋值以及初始化其他资源) 小结 当一个类被使用的时候，才会加载到内存 类加载的过程: 加载、验证、准备、解析、初始化 1.3类加载的分类【理解】 分类 Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块 System class loader：系统类加载器,负责加载用户类路径上所指定的类库 类加载器的继承关系 System的父加载器为Platform Platform的父加载器为Bootstrap 代码演示 1234567891011121314151617public class ClassLoaderDemo1 &#123; public static void main(String[] args) &#123; //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); //获取系统类加载器的父加载器 --- 平台类加载器 ClassLoader classLoader1 = systemClassLoader.getParent(); //获取平台类加载器的父加载器 --- 启动类加载器 ClassLoader classLoader2 = classLoader1.getParent(); System.out.println(\"系统类加载器\" + systemClassLoader); System.out.println(\"平台类加载器\" + classLoader1); System.out.println(\"启动类加载器\" + classLoader2); &#125;&#125; 1.4双亲委派模型【理解】 介绍 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式 1.5ClassLoader 中的两个方法【应用】 方法介绍 方法名 说明 public static ClassLoader getSystemClassLoader() 获取系统类加载器 public InputStream getResourceAsStream(String name) 加载某一个资源文件 示例代码 123456789101112131415161718192021public class ClassLoaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; //static ClassLoader getSystemClassLoader() 获取系统类加载器 //InputStream getResourceAsStream(String name) 加载某一个资源文件 //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); //利用加载器去加载一个指定的文件 //参数：文件的路径（放在src的根目录下，默认去那里加载） //返回值：字节流。 InputStream is = systemClassLoader.getResourceAsStream(\"prop.properties\"); Properties prop = new Properties(); prop.load(is); System.out.println(prop); is.close(); &#125;&#125; 2.反射2.1反射的概述【理解】 反射机制 是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意属性和方法；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。 2.2获取Class类对象的三种方式【应用】 三种方式分类 类名.class属性 对象名.getClass()方法 Class.forName(全类名)方法 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void study()&#123; System.out.println(\"学生在学习\"); &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125;public class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //1.Class类中的静态方法forName(\"全类名\") //全类名:包名 + 类名 Class clazz = Class.forName(\"com.itheima.myreflect2.Student\"); System.out.println(clazz); //2.通过class属性来获取 Class clazz2 = Student.class; System.out.println(clazz2); //3.利用对象的getClass方法来获取class对象 //getClass方法是定义在Object类中. Student s = new Student(); Class clazz3 = s.getClass(); System.out.println(clazz3); System.out.println(clazz == clazz2); System.out.println(clazz2 == clazz3); &#125;&#125; 2.3反射获取构造方法并使用【应用】2.3.1Class类获取构造方法对象的方法 方法介绍 方法名 说明 Constructor&lt;?&gt;[] getConstructors() 返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[] getDeclaredConstructors() 返回所有构造方法对象的数组 Constructor getConstructor(Class&lt;?&gt;… parameterTypes) 返回单个公共构造方法对象 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 返回单个构造方法对象 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Student &#123; private String name; private int age; //私有的有参构造方法 private Student(String name) &#123; System.out.println(\"name的值为:\" + name); System.out.println(\"private...Student...有参构造方法\"); &#125; //公共的无参构造方法 public Student() &#123; System.out.println(\"public...Student...无参构造方法\"); &#125; //公共的有参构造方法 public Student(String name, int age) &#123; System.out.println(\"name的值为:\" + name + \"age的值为:\" + age); System.out.println(\"public...Student...有参构造方法\"); &#125;&#125;public class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; //method1(); //method2(); //method3(); //method4(); &#125; private static void method4() throws ClassNotFoundException, NoSuchMethodException &#123; // Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)：// 返回单个构造方法对象 //1.获取Class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); Constructor constructor = clazz.getDeclaredConstructor(String.class); System.out.println(constructor); &#125; private static void method3() throws ClassNotFoundException, NoSuchMethodException &#123; // Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)：// 返回单个公共构造方法对象 //1.获取Class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); //小括号中,一定要跟构造方法的形参保持一致. Constructor constructor1 = clazz.getConstructor(); System.out.println(constructor1); Constructor constructor2 = clazz.getConstructor(String.class, int.class); System.out.println(constructor2); //因为Student类中,没有只有一个int的构造,所以这里会报错. Constructor constructor3 = clazz.getConstructor(int.class); System.out.println(constructor3); &#125; private static void method2() throws ClassNotFoundException &#123; // Constructor&lt;?&gt;[] getDeclaredConstructors()：// 返回所有构造方法对象的数组 //1.获取Class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; &#125; private static void method1() throws ClassNotFoundException &#123; // Constructor&lt;?&gt;[] getConstructors()：// 返回所有公共构造方法对象的数组 //1.获取Class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); Constructor[] constructors = clazz.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; &#125;&#125; 2.3.2Constructor类用于创建对象的方法 方法介绍 方法名 说明 T newInstance(Object…initargs) 根据指定的构造方法创建对象 setAccessible(boolean flag) 设置为true,表示取消访问检查 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Student类同上一个示例,这里就不在重复提供了public class ReflectDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; //T newInstance(Object... initargs)：根据指定的构造方法创建对象 //method1(); //method2(); //method3(); //method4(); &#125; private static void method4() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; //获取一个私有的构造方法并创建对象 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); //2.获取一个私有化的构造方法. Constructor constructor = clazz.getDeclaredConstructor(String.class); //被private修饰的成员,不能直接使用的 //如果用反射强行获取并使用,需要临时取消访问检查 constructor.setAccessible(true); //3.直接创建对象 Student student = (Student) constructor.newInstance(\"zhangsan\"); System.out.println(student); &#125; private static void method3() throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; //简写格式 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); //2.在Class类中,有一个newInstance方法,可以利用空参直接创建一个对象 Student student = (Student) clazz.newInstance();//这个方法现在已经过时了,了解一下 System.out.println(student); &#125; private static void method2() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); //2.获取构造方法对象 Constructor constructor = clazz.getConstructor(); //3.利用空参来创建Student的对象 Student student = (Student) constructor.newInstance(); System.out.println(student); &#125; private static void method1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); //2.获取构造方法对象 Constructor constructor = clazz.getConstructor(String.class, int.class); //3.利用newInstance创建Student的对象 Student student = (Student) constructor.newInstance(\"zhangsan\", 23); System.out.println(student); &#125;&#125; 2.3.3小结 获取class对象 三种方式: Class.forName(“全类名”), 类名.class, 对象名.getClass() 获取里面的构造方法对象 getConstructor (Class... parameterTypes) getDeclaredConstructor (Class… parameterTypes) 如果是public的，直接创建对象 newInstance(Object… initargs) 如果是非public的，需要临时取消检查，然后再创建对象 setAccessible(boolean) 暴力反射 2.4反射获取成员变量并使用【应用】2.4.1Class类获取成员变量对象的方法 方法分类 方法名 说明 Field[] getFields() 返回所有公共成员变量对象的数组 Field[] getDeclaredFields() 返回所有成员变量对象的数组 Field getField(String name) 返回单个公共成员变量对象 Field getDeclaredField(String name) 返回单个成员变量对象 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Student &#123; public String name; public int age; public String gender; private int money = 300; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", gender='\" + gender + '\\'' + \", money=\" + money + '&#125;'; &#125;&#125;public class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123; // method1(); //method2(); //method3(); //method4(); &#125; private static void method4() throws ClassNotFoundException, NoSuchFieldException &#123; // Field getDeclaredField(String name)：返回单个成员变量对象 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取money成员变量 Field field = clazz.getDeclaredField(\"money\"); //3.打印一下 System.out.println(field); &#125; private static void method3() throws ClassNotFoundException, NoSuchFieldException &#123; // Field getField(String name)：返回单个公共成员变量对象 //想要获取的成员变量必须是真实存在的 //且必须是public修饰的. //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取name这个成员变量 //Field field = clazz.getField(\"name\"); //Field field = clazz.getField(\"name1\"); Field field = clazz.getField(\"money\"); //3.打印一下 System.out.println(field); &#125; private static void method2() throws ClassNotFoundException &#123; // Field[] getDeclaredFields()：返回所有成员变量对象的数组 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取所有的Field对象 Field[] fields = clazz.getDeclaredFields(); //3.遍历 for (Field field : fields) &#123; System.out.println(field); &#125; &#125; private static void method1() throws ClassNotFoundException &#123; // Field[] getFields()：返回所有公共成员变量对象的数组 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取Field对象. Field[] fields = clazz.getFields(); //3.遍历 for (Field field : fields) &#123; System.out.println(field); &#125; &#125;&#125; 2.4.2Field类用于给成员变量赋值的方法 方法介绍 方法名 说明 void set(Object obj, Object value) 赋值 Object get(Object obj) 获取值 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Student类同上一个示例,这里就不在重复提供了public class ReflectDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException &#123;// Object get(Object obj) 返回由该 Field表示的字段在指定对象上的值。 //method1(); //method2(); &#125; private static void method2() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException &#123; //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取成员变量Field的对象 Field field = clazz.getDeclaredField(\"money\"); //3.取消一下访问检查 field.setAccessible(true); //4.调用get方法来获取值 //4.1创建一个对象 Student student = (Student) clazz.newInstance(); //4.2获取指定对象的money的值 Object o = field.get(student); //5.打印一下 System.out.println(o); &#125; private static void method1() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException &#123; // void set(Object obj, Object value)：给obj对象的成员变量赋值为value //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取name这个Field对象 Field field = clazz.getField(\"name\"); //3.利用set方法进行赋值. //3.1先创建一个Student对象 Student student = (Student) clazz.newInstance(); //3.2有了对象才可以给指定对象进行赋值 field.set(student,\"zhangsan\"); System.out.println(student); &#125;&#125; 2.5反射获取成员方法并使用【应用】2.5.1Class类获取成员方法对象的方法 方法分类 方法名 说明 Method[] getMethods() 返回所有公共成员方法对象的数组，包括继承的 Method[] getDeclaredMethods() 返回所有成员方法对象的数组，不包括继承的 Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 返回单个公共成员方法对象 Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回单个成员方法对象 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class Student &#123; //私有的，无参无返回值 private void show() &#123; System.out.println(\"私有的show方法，无参无返回值\"); &#125; //公共的，无参无返回值 public void function1() &#123; System.out.println(\"function1方法，无参无返回值\"); &#125; //公共的，有参无返回值 public void function2(String name) &#123; System.out.println(\"function2方法，有参无返回值,参数为\" + name); &#125; //公共的，无参有返回值 public String function3() &#123; System.out.println(\"function3方法，无参有返回值\"); return \"aaa\"; &#125; //公共的，有参有返回值 public String function4(String name) &#123; System.out.println(\"function4方法，有参有返回值,参数为\" + name); return \"aaa\"; &#125;&#125;public class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; //method1(); //method2(); //method3(); //method4(); //method5(); &#125; private static void method5() throws ClassNotFoundException, NoSuchMethodException &#123; // Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)：// 返回单个成员方法对象 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取一个成员方法show Method method = clazz.getDeclaredMethod(\"show\"); //3.打印一下 System.out.println(method); &#125; private static void method4() throws ClassNotFoundException, NoSuchMethodException &#123; //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取一个有形参的方法function2 Method method = clazz.getMethod(\"function2\", String.class); //3.打印一下 System.out.println(method); &#125; private static void method3() throws ClassNotFoundException, NoSuchMethodException &#123; // Method getMethod(String name, Class&lt;?&gt;... parameterTypes) ：// 返回单个公共成员方法对象 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取成员方法function1 Method method1 = clazz.getMethod(\"function1\"); //3.打印一下 System.out.println(method1); &#125; private static void method2() throws ClassNotFoundException &#123; // Method[] getDeclaredMethods()：// 返回所有成员方法对象的数组，不包括继承的 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取Method对象 Method[] methods = clazz.getDeclaredMethods(); //3.遍历一下数组 for (Method method : methods) &#123; System.out.println(method); &#125; &#125; private static void method1() throws ClassNotFoundException &#123; // Method[] getMethods()：返回所有公共成员方法对象的数组，包括继承的 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取成员方法对象 Method[] methods = clazz.getMethods(); //3.遍历 for (Method method : methods) &#123; System.out.println(method); &#125; &#125;&#125; 2.5.2Method类用于执行方法的方法 方法介绍 方法名 说明 Object invoke(Object obj, Object… args) 运行方法 参数一: 用obj对象调用该方法 参数二: 调用方法的传递的参数(如果没有就不写) 返回值: 方法的返回值(如果没有就不写) 示例代码 1234567891011121314151617181920public class ReflectDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;// Object invoke(Object obj, Object... args)：运行方法// 参数一：用obj对象调用该方法// 参数二：调用方法的传递的参数（如果没有就不写）// 返回值：方法的返回值（如果没有就不写） //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取里面的Method对象 function4 Method method = clazz.getMethod(\"function4\", String.class); //3.运行function4方法就可以了 //3.1创建一个Student对象,当做方法的调用者 Student student = (Student) clazz.newInstance(); //3.2运行方法 Object result = method.invoke(student, \"zhangsan\"); //4.打印一下返回值 System.out.println(result); &#125;&#125;","categories":[],"tags":[]},{"title":"25_网络编程","slug":"38_网络编程","date":"2020-11-13T15:09:20.000Z","updated":"2020-11-13T15:10:14.375Z","comments":true,"path":"2020/11/13/38_网络编程/","link":"","permalink":"http://xiaojujing.com/2020/11/13/38_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"1.网络编程入门1.1 网络编程概述【理解】 计算机网络","text":"1.网络编程入门1.1 网络编程概述【理解】 计算机网络 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统 网络编程 在网络通信协议下，不同计算机上运行的程序，可以进行数据传输 1.2 网络编程三要素【理解】 IP地址 要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识 端口 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识 协议 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议 1.3 IP地址【理解】IP地址：是网络中设备的唯一标识 IP地址分为两大类 IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题 DOS常用命令： ipconfig：查看本机IP地址 ping IP地址：检查网络是否连通 特殊IP地址： 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用 1.4 InetAddress【应用】InetAddress：此类表示Internet协议（IP）地址 相关方法 方法名 说明 static InetAddress getByName(String host) 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 String getHostName() 获取此IP地址的主机名 String getHostAddress() 返回文本显示中的IP地址字符串 代码演示 1234567891011121314public class InetAddressDemo &#123; public static void main(String[] args) throws UnknownHostException &#123; //InetAddress address = InetAddress.getByName(\"itheima\"); InetAddress address = InetAddress.getByName(\"192.168.1.66\"); //public String getHostName()：获取此IP地址的主机名 String name = address.getHostName(); //public String getHostAddress()：返回文本显示中的IP地址字符串 String ip = address.getHostAddress(); System.out.println(\"主机名：\" + name); System.out.println(\"IP地址：\" + ip); &#125;&#125; 1.5 端口和协议【理解】 端口 设备上应用程序的唯一标识 端口号 用两个字节表示的整数，它的取值范围是065535。其中，01023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败 协议 计算机网络中，连接和通信的规则被称为网络通信协议 UDP协议 用户数据报协议(User Datagram Protocol) UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议 TCP协议 传输控制协议 (Transmission Control Protocol) TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手” 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠 第一次握手，客户端向服务器端发出连接请求，等待服务器确认 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 第三次握手，客户端再次向服务器端发送确认信息，确认连接 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等 2.UDP通信程序2.1 UDP发送数据【应用】 Java中的UDP通信 UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念 Java提供了DatagramSocket类作为基于UDP协议的Socket 构造方法 方法名 说明 DatagramSocket() 创建数据报套接字并将其绑定到本机地址上的任何可用端口 DatagramPacket(byte[] buf,int len,InetAddress add,int port) 创建数据包,发送长度为len的数据包到指定主机的指定端口 相关方法 方法名 说明 void send(DatagramPacket p) 发送数据报包 void close() 关闭数据报套接字 void receive(DatagramPacket p) 从此套接字接受数据报包 发送数据的步骤 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包 调用DatagramSocket对象的方法发送数据 关闭发送端 代码演示 12345678910111213141516171819202122public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口 DatagramSocket ds = new DatagramSocket(); //创建数据，并把数据打包 //DatagramPacket(byte[] buf, int length, InetAddress address, int port) //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。 byte[] bys = \"hello,udp,我来了\".getBytes(); DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName(\"127.0.0.1\"),10086); //调用DatagramSocket对象的方法发送数据 //void send(DatagramPacket p) 从此套接字发送数据报包 ds.send(dp); //关闭发送端 //void close() 关闭此数据报套接字 ds.close(); &#125;&#125; 2.2UDP接收数据【应用】 接收数据的步骤 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 构造方法 方法名 说明 DatagramPacket(byte[] buf, int len) 创建一个DatagramPacket用于接收长度为len的数据包 相关方法 方法名 说明 byte[] getData() 返回数据缓冲区 int getLength() 返回要发送的数据的长度或接收的数据的长度 示例代码 1234567891011121314151617public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println(\"数据是：\" + new String(dp.getData(), 0, dp.getLength())); &#125; &#125;&#125; 2.3UDP通信程序练习【应用】 案例需求 UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束 UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* UDP发送数据： 数据来自于键盘录入，直到输入的数据是886，发送数据结束 */public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); //键盘录入数据 Scanner sc = new Scanner(System.in); while (true) &#123; String s = sc.nextLine(); //输入的数据是886，发送数据结束 if (\"886\".equals(s)) &#123; break; &#125; //创建数据，并把数据打包 byte[] bys = s.getBytes(); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName(\"192.168.1.66\"), 12345); //调用DatagramSocket对象的方法发送数据 ds.send(dp); &#125; //关闭发送端 ds.close(); &#125;&#125;/* UDP接收数据： 因为接收端不知道发送端什么时候停止发送，故采用死循环接收 */public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) &#123; //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println(\"数据是：\" + new String(dp.getData(), 0, dp.getLength())); &#125; //关闭接收端// ds.close(); &#125;&#125; 2.4UDP三种通讯方式【理解】 单播 单播用于两个主机之间的端对端通信 组播 组播用于对一组特定的主机进行通信 广播 广播用于一个主机对整个局域网上所有主机上的数据通信 2.5UDP组播实现【理解】 实现步骤 发送端 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包(DatagramPacket) 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) 释放资源 接收端 创建接收端Socket对象(MulticastSocket) 创建一个箱子,用于接收数据 把当前计算机绑定一个组播地址 将数据接收到箱子中 解析数据包,并打印数据 释放资源 代码实现 123456789101112131415161718192021222324252627282930313233343536// 发送端public class ClinetDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); String s = \"hello 组播\"; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName(\"224.0.1.0\"); int port = 10000; // 2. 创建数据，并把数据打包(DatagramPacket) DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) ds.send(dp); // 4. 释放资源 ds.close(); &#125;&#125;// 接收端public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建接收端Socket对象(MulticastSocket) MulticastSocket ms = new MulticastSocket(10000); // 2. 创建一个箱子,用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中. ms.joinGroup(InetAddress.getByName(\"224.0.1.0\")); // 4. 将数据接收到箱子中 ms.receive(dp); // 5. 解析数据包,并打印数据 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 6. 释放资源 ms.close(); &#125;&#125; 2.6UDP广播实现【理解】 实现步骤 发送端 创建发送端Socket对象(DatagramSocket) 创建存储数据的箱子,将广播地址封装进去 发送数据 释放资源 接收端 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 代码实现 12345678910111213141516171819202122232425262728293031323334// 发送端public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建发送端Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); // 2. 创建存储数据的箱子,将广播地址封装进去 String s = \"广播 hello\"; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName(\"255.255.255.255\"); int port = 10000; DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); // 3. 发送数据 ds.send(dp); // 4. 释放资源 ds.close(); &#125;&#125;// 接收端public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(10000); // 2. 创建一个数据包，用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 调用DatagramSocket对象的方法接收数据 ds.receive(dp); // 4. 解析数据包，并把数据在控制台显示 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 5. 关闭接收端 ds.close(); &#125;&#125; 3.TCP通信程序3.1TCP发送数据【应用】 Java中的TCP通信 Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。 Java为客户端提供了Socket类，为服务器端提供了ServerSocket类 构造方法 方法名 说明 Socket(InetAddress address,int port) 创建流套接字并将其连接到指定IP指定端口号 Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 相关方法 方法名 说明 InputStream getInputStream() 返回此套接字的输入流 OutputStream getOutputStream() 返回此套接字的输出流 示例代码 123456789101112131415public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; //创建客户端的Socket对象(Socket) //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 Socket s = new Socket(\"127.0.0.1\",10000); //获取输出流，写数据 //OutputStream getOutputStream() 返回此套接字的输出流 OutputStream os = s.getOutputStream(); os.write(\"hello,tcp,我来了\".getBytes()); //释放资源 s.close(); &#125;&#125; 3.2TCP接收数据【应用】 构造方法 方法名 说明 ServletSocket(int port) 创建绑定到指定端口的服务器套接字 相关方法 方法名 说明 Socket accept() 监听要连接到此的套接字并接受它 注意事项 accept方法是阻塞的,作用就是等待客户端连接 客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接 针对客户端来讲,是往外写的,所以是输出流针对服务器来讲,是往里读的,所以是输入流 read方法也是阻塞的 客户端在关流的时候,还多了一个往服务器写结束标记的动作 最后一步断开连接,通过四次挥手协议保证连接终止 三次握手和四次挥手 三次握手 四次挥手 示例代码 123456789101112131415161718192021public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; //创建服务器端的Socket对象(ServerSocket) //ServerSocket(int port) 创建绑定到指定端口的服务器套接字 ServerSocket ss = new ServerSocket(10000); //Socket accept() 侦听要连接到此套接字并接受它 Socket s = ss.accept(); //获取输入流，读数据，并把数据显示在控制台 InputStream is = s.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); String data = new String(bys,0,len); System.out.println(\"数据是：\" + data); //释放资源 s.close(); ss.close(); &#125;&#125; 3.3TCP程序练习【应用】 案例需求 客户端：发送数据，接受服务器反馈 服务器：收到消息后给出反馈 案例分析 客户端创建对象，使用输出流输出数据 服务端创建对象，使用输入流接受数据 服务端使用输出流给出反馈数据 客户端使用输入流接受反馈数据 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 客户端public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(\"127.0.0.1\",10000); OutputStream os = socket.getOutputStream(); os.write(\"hello\".getBytes()); // os.close();如果在这里关流,会导致整个socket都无法使用 socket.shutdownOutput();//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; while((line = br.readLine())!=null)&#123; System.out.println(line); &#125; br.close(); os.close(); socket.close(); &#125;&#125;// 服务器public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); Socket accept = ss.accept(); InputStream is = accept.getInputStream(); int b; while((b = is.read())!=-1)&#123; System.out.println((char) b); &#125; System.out.println(\"看看我执行了吗?\"); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"你谁啊?\"); bw.newLine(); bw.flush(); bw.close(); is.close(); accept.close(); ss.close(); &#125;&#125; 3.4TCP程序文件上传练习【应用】 案例需求 客户端：数据来自于本地文件，接收服务器反馈 服务器：接收到的数据写入本地文件，给出反馈 案例分析 创建客户端对象，创建输入流对象指向文件，每读一次数据就给服务器输出一次数据，输出结束后使用shutdownOutput()方法告知服务端传输结束 创建服务器对象，创建输出流对象指向文件，每接受一次数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息 客户端接受服务端的回馈信息 相关方法 方法名 说明 void shutdownInput() 将此套接字的输入流放置在“流的末尾” void shutdownOutput() 禁止用此套接字的输出流 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 客户端public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(\"127.0.0.1\",10000); //是本地的流,用来读取本地文件的. BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"socketmodule\\\\ClientDir\\\\1.jpg\")); //写到服务器 --- 网络中的流 OutputStream os = socket.getOutputStream(); BufferedOutputStream bos = new BufferedOutputStream(os); int b; while((b = bis.read())!=-1)&#123; bos.write(b);//通过网络写到服务器中 &#125; bos.flush(); //给服务器一个结束标记,告诉服务器文件已经传输完毕 socket.shutdownOutput(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; while((line = br.readLine()) !=null)&#123; System.out.println(line); &#125; bis.close(); socket.close(); &#125;&#125;// 服务器public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"socketmodule\\\\ServerDir\\\\copy.jpg\")); int b; while((b = bis.read()) !=-1)&#123; bos.write(b); &#125; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); bos.close(); accept.close(); ss.close(); &#125;&#125; 3.5TCP程序服务器优化【应用】 优化方案一 需求 服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。 解决方案 使用循环 代码实现 123456789101112131415161718192021222324252627282930// 服务器代码如下,客户端代码同上个案例,此处不再给出public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); while (true) &#123; Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"optimizeserver\\\\ServerDir\\\\copy.jpg\")); int b; while((b = bis.read()) !=-1)&#123; bos.write(b); &#125; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); bos.close(); accept.close(); &#125; //ss.close(); &#125;&#125; 优化方案二 需求 第二次上传文件的时候，会把第一次的文件给覆盖。 解决方案 UUID. randomUUID()方法生成随机的文件名 代码实现 123456789101112131415161718192021222324252627282930// 服务器代码如下,客户端代码同上个案例,此处不再给出public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); while (true) &#123; Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"optimizeserver\\\\ServerDir\\\\\" + UUID.randomUUID().toString() + \".jpg\")); int b; while((b = bis.read()) !=-1)&#123; bos.write(b); &#125; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); bos.close(); accept.close(); &#125; //ss.close(); &#125;&#125; 优化方案三 需求 使用循环虽然可以让服务器处理多个客户端请求。但是还是无法同时跟多个客户端进行通信。 解决方案 开启多线程处理 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 线程任务类public class ThreadSocket implements Runnable &#123; private Socket acceptSocket; public ThreadSocket(Socket accept) &#123; this.acceptSocket = accept; &#125; @Override public void run() &#123; BufferedOutputStream bos = null; try &#123; //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(acceptSocket.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 bos = new BufferedOutputStream(new FileOutputStream(\"optimizeserver\\\\ServerDir\\\\\" + UUID.randomUUID().toString() + \".jpg\")); int b; while((b = bis.read()) !=-1)&#123; bos.write(b); &#125; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(acceptSocket.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (acceptSocket != null)&#123; try &#123; acceptSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;// 服务器代码public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); while (true) &#123; Socket accept = ss.accept(); ThreadSocket ts = new ThreadSocket(accept); new Thread(ts).start(); &#125; //ss.close(); &#125;&#125; 优化方案四 需求 使用多线程虽然可以让服务器同时处理多个客户端请求。但是资源消耗太大。 解决方案 加入线程池 代码实现 1234567891011121314151617181920212223// 服务器代码如下,线程任务类代码同上,此处不再给出public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); ThreadPoolExecutor pool = new ThreadPoolExecutor( 3,//核心线程数量 10, //线程池的总数量 60, //临时线程空闲时间 TimeUnit.SECONDS, //临时线程空闲时间的单位 new ArrayBlockingQueue&lt;&gt;(5),//阻塞队列 Executors.defaultThreadFactory(),//创建线程的方式 new ThreadPoolExecutor.AbortPolicy()//任务拒绝策略 ); while (true) &#123; Socket accept = ss.accept(); ThreadSocket ts = new ThreadSocket(accept); //new Thread(ts).start(); pool.submit(ts); &#125; //ss.close(); &#125;&#125;","categories":[],"tags":[]},{"title":"24_多线程02","slug":"37_多线程02","date":"2020-11-12T13:18:36.000Z","updated":"2020-11-12T13:21:02.390Z","comments":true,"path":"2020/11/12/37_多线程02/","link":"","permalink":"http://xiaojujing.com/2020/11/12/37_%E5%A4%9A%E7%BA%BF%E7%A8%8B02/","excerpt":"1.线程池1.1 线程状态介绍当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程","text":"1.线程池1.1 线程状态介绍当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程 状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下： 123456789101112131415161718192021222324252627282930public class Thread &#123; public enum State &#123; /* 新建 */ NEW , /* 可运行状态 */ RUNNABLE , /* 阻塞状态 */ BLOCKED , /* 无限等待状态 */ WAITING , /* 计时等待 */ TIMED_WAITING , /* 终止 */ TERMINATED; &#125; // 获取当前线程的状态 public State getState() &#123; return jdk.internal.misc.VM.toThreadState(threadStatus); &#125; &#125; 通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下 线程状态 具体含义 NEW 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 RUNNABLE 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 BLOCKED 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 WAITING 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 TIMED_WAITING 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 TERMINATED 一个完全运行完成的线程的状态。也称之为终止状态、结束状态 各个状态的转换，如下图所示： 1.2 线程池-基本原理概述 : ​ 提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。 线程池存在的意义： ​ 系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系 ​ 统资源的消耗，这样就有点”舍本逐末”了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就 ​ 会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。 线程池的设计思路 : 准备一个任务容器 一次性启动多个(2个)消费者线程 刚开始任务容器是空的，所以线程都在wait 直到一个外部线程向这个任务容器中扔了一个”任务”，就会有一个消费者线程被唤醒 这个消费者线程取出”任务”，并且执行这个任务，执行完毕后，继续等待下一次任务的到来 1.3 线程池-Executors默认线程池概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。 我们可以使用Executors中所提供的静态方法来创建线程池 ​ static ExecutorService newCachedThreadPool() 创建一个默认的线程池​ static newFixedThreadPool(int nThreads) 创建一个指定最多线程数量的线程池 代码实现 : 123456789101112131415161718192021222324252627282930package com.itheima.mythreadpool;//static ExecutorService newCachedThreadPool() 创建一个默认的线程池//static newFixedThreadPool(int nThreads) 创建一个指定最多线程数量的线程池import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class MyThreadPoolDemo &#123; public static void main(String[] args) throws InterruptedException &#123; //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值. ExecutorService executorService = Executors.newCachedThreadPool(); //Executors --- 可以帮助我们创建线程池对象 //ExecutorService --- 可以帮助我们控制线程池 executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + \"在执行了\"); &#125;); //Thread.sleep(2000); executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + \"在执行了\"); &#125;); executorService.shutdown(); &#125;&#125; 1.4 线程池-Executors创建指定上限的线程池使用Executors中所提供的静态方法来创建线程池 ​ static ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池 代码实现 : 1234567891011121314151617181920212223242526272829package com.itheima.mythreadpool;//static ExecutorService newFixedThreadPool(int nThreads)//创建一个指定最多线程数量的线程池import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;public class MyThreadPoolDemo2 &#123; public static void main(String[] args) &#123; //参数不是初始值而是最大值 ExecutorService executorService = Executors.newFixedThreadPool(10); ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService; System.out.println(pool.getPoolSize());//0 executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + \"在执行了\"); &#125;); executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + \"在执行了\"); &#125;); System.out.println(pool.getPoolSize());//2// executorService.shutdown(); &#125;&#125; 1.5 线程池-ThreadPoolExecutor创建线程池对象 : ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略); 代码实现 : 1234567891011121314151617181920212223package com.itheima.mythreadpool;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class MyThreadPoolDemo3 &#123;// 参数一：核心线程数量// 参数二：最大线程数// 参数三：空闲线程最大存活时间// 参数四：时间单位// 参数五：任务队列// 参数六：创建线程工厂// 参数七：任务的拒绝策略 public static void main(String[] args) &#123; ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy()); pool.submit(new MyRunnable()); pool.submit(new MyRunnable()); pool.shutdown(); &#125;&#125; 1.6 线程池-参数详解 123456789101112131415public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize： 核心线程的最大值，不能小于0maximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize &gt;= corePoolSizekeepAliveTime： 空闲线程最大存活时间,不能小于0unit： 时间单位workQueue： 任务队列，不能为nullthreadFactory： 创建线程工厂,不能为null handler： 任务的拒绝策略,不能为null 1.7 线程池-非默认任务拒绝策略RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。 1234ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。是默认的策略。ThreadPoolExecutor.DiscardPolicy： 丢弃任务，但是不抛出异常 这是不推荐的做法。ThreadPoolExecutor.DiscardOldestPolicy： 抛弃队列中等待最久的任务 然后把当前任务加入队列中。ThreadPoolExecutor.CallerRunsPolicy: 调用任务的run()方法绕过线程池直接执行。 注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数 案例演示1：演示ThreadPoolExecutor.AbortPolicy任务处理策略 123456789101112131415161718public class ThreadPoolExecutorDemo01 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ; // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常 for(int x = 0 ; x &lt; 5 ; x++) &#123; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"----&gt;&gt; 执行了任务\"); &#125;); &#125; &#125;&#125; 控制台输出结果 1234pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务 控制台报错，仅仅执行了4个任务，有一个任务被丢弃了 案例演示2：演示ThreadPoolExecutor.DiscardPolicy任务处理策略 12345678910111213141516public class ThreadPoolExecutorDemo02 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ; // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错 for(int x = 0 ; x &lt; 5 ; x++) &#123; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"----&gt;&gt; 执行了任务\"); &#125;); &#125; &#125;&#125; 控制台输出结果 1234pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务 控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了 案例演示3：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略 123456789101112131415161718public class ThreadPoolExecutorDemo02 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor; threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy()); // 提交5个任务 for(int x = 0 ; x &lt; 5 ; x++) &#123; // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰 final int y = x ; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"----&gt;&gt; 执行了任务\" + y); &#125;); &#125; &#125;&#125; 控制台输出结果 1234pool-1-thread-2----&gt;&gt; 执行了任务2pool-1-thread-1----&gt;&gt; 执行了任务0pool-1-thread-3----&gt;&gt; 执行了任务3pool-1-thread-1----&gt;&gt; 执行了任务4 由于任务1在线程池中等待时间最长，因此任务1被丢弃。 案例演示4：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略 123456789101112131415161718public class ThreadPoolExecutorDemo04 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor; threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy()); // 提交5个任务 for(int x = 0 ; x &lt; 5 ; x++) &#123; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"----&gt;&gt; 执行了任务\"); &#125;); &#125; &#125;&#125; 控制台输出结果 12345pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务pool-1-thread-1----&gt;&gt; 执行了任务main----&gt;&gt; 执行了任务 通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。 2. 原子性2.1 volatile-问题代码分析 : 12345678910111213package com.itheima.myvolatile;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); t1.setName(\"小路同学\"); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(\"小皮同学\"); t2.start(); &#125;&#125; 12345package com.itheima.myvolatile;public class Money &#123; public static int money = 100000;&#125; 123456789101112package com.itheima.myvolatile;public class MyThread1 extends Thread &#123; @Override public void run() &#123; while(Money.money == 100000)&#123; &#125; System.out.println(\"结婚基金已经不是十万了\"); &#125;&#125; 1234567891011121314package com.itheima.myvolatile;public class MyThread2 extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Money.money = 90000; &#125;&#125; 程序问题 : 女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。 2.2 volatile解决以上案例出现的问题 : ​ 当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 ​ 1，堆内存是唯一的，每一个线程都有自己的线程栈。 ​ 2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。 ​ 3 ，在线程中，每一次使用是从变量的副本中获取的。 Volatile关键字 : 强制线程每次在使用的时候，都会看一下共享区域最新的值 代码实现 : 使用volatile关键字解决 12345678910111213package com.itheima.myvolatile;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); t1.setName(\"小路同学\"); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(\"小皮同学\"); t2.start(); &#125;&#125; 12345package com.itheima.myvolatile;public class Money &#123; public static volatile int money = 100000;&#125; 123456789101112package com.itheima.myvolatile;public class MyThread1 extends Thread &#123; @Override public void run() &#123; while(Money.money == 100000)&#123; &#125; System.out.println(\"结婚基金已经不是十万了\"); &#125;&#125; 1234567891011121314package com.itheima.myvolatile;public class MyThread2 extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Money.money = 90000; &#125;&#125; 2.3 synchronized解决synchronized解决 : ​ 1 ，线程获得锁 ​ 2 ，清空变量副本 ​ 3 ，拷贝共享变量最新的值到变量副本中 ​ 4 ，执行代码 ​ 5 ，将修改后变量副本中的值赋值给共享数据 ​ 6 ，释放锁 代码实现 : 12345678910111213package com.itheima.myvolatile2;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); t1.setName(\"小路同学\"); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(\"小皮同学\"); t2.start(); &#125;&#125; 123456package com.itheima.myvolatile2;public class Money &#123; public static Object lock = new Object(); public static volatile int money = 100000;&#125; 123456789101112131415package com.itheima.myvolatile2;public class MyThread1 extends Thread &#123; @Override public void run() &#123; while(true)&#123; synchronized (Money.lock)&#123; if(Money.money != 100000)&#123; System.out.println(\"结婚基金已经不是十万了\"); break; &#125; &#125; &#125; &#125;&#125; 12345678910111213141516package com.itheima.myvolatile2;public class MyThread2 extends Thread &#123; @Override public void run() &#123; synchronized (Money.lock) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Money.money = 90000; &#125; &#125;&#125; 2.4 原子性概述 : 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。 代码实现 : 12345678910111213141516171819202122232425package com.itheima.threadatom;public class AtomDemo &#123; public static void main(String[] args) &#123; MyAtomThread atom = new MyAtomThread(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(atom).start(); &#125; &#125;&#125;class MyAtomThread implements Runnable &#123; private volatile int count = 0; //送冰淇淋的数量 @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; //1,从共享数据中读取数据到本线程栈中. //2,修改本线程栈中变量副本的值 //3,会把本线程栈中变量副本的值赋值给共享数据. count++; System.out.println(\"已经送了\" + count + \"个冰淇淋\"); &#125; &#125;&#125; 代码总结 : count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断 2.5 volatile关键字不能保证原子性解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。 12345678910111213141516171819202122232425262728package com.itheima.threadatom2;public class AtomDemo &#123; public static void main(String[] args) &#123; MyAtomThread atom = new MyAtomThread(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(atom).start(); &#125; &#125;&#125;class MyAtomThread implements Runnable &#123; private volatile int count = 0; //送冰淇淋的数量 private Object lock = new Object(); @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; //1,从共享数据中读取数据到本线程栈中. //2,修改本线程栈中变量副本的值 //3,会把本线程栈中变量副本的值赋值给共享数据. synchronized (lock) &#123; count++; System.out.println(\"已经送了\" + count + \"个冰淇淋\"); &#125; &#125; &#125;&#125; 2.6 原子性_AtomicInteger概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变 量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解 使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类： AtomicBoolean： 原子更新布尔类型 AtomicInteger： 原子更新整型 AtomicLong： 原子更新长整型 以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下： 12345678public AtomicInteger()： 初始化一个默认值为0的原子型Integerpublic AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integerint get(): 获取值int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。int addAndGet(int data): 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 代码实现 : 12345678910111213141516package com.itheima.threadatom3;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomIntergerDemo1 &#123;// public AtomicInteger()： 初始化一个默认值为0的原子型Integer// public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer public static void main(String[] args) &#123; AtomicInteger ac = new AtomicInteger(); System.out.println(ac); AtomicInteger ac2 = new AtomicInteger(10); System.out.println(ac2); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.itheima.threadatom3;import java.lang.reflect.Field;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomIntergerDemo2 &#123;// int get(): 获取值// int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。// int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。// int addAndGet(int data): 以原子方式将参数与对象中的值相加，并返回结果。// int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 public static void main(String[] args) &#123;// AtomicInteger ac1 = new AtomicInteger(10);// System.out.println(ac1.get());// AtomicInteger ac2 = new AtomicInteger(10);// int andIncrement = ac2.getAndIncrement();// System.out.println(andIncrement);// System.out.println(ac2.get());// AtomicInteger ac3 = new AtomicInteger(10);// int i = ac3.incrementAndGet();// System.out.println(i);//自增后的值// System.out.println(ac3.get());// AtomicInteger ac4 = new AtomicInteger(10);// int i = ac4.addAndGet(20);// System.out.println(i);// System.out.println(ac4.get()); AtomicInteger ac5 = new AtomicInteger(100); int andSet = ac5.getAndSet(20); System.out.println(andSet); System.out.println(ac5.get()); &#125;&#125; 2.7 AtomicInteger-内存解析AtomicInteger原理 : 自旋锁 + CAS 算法 CAS算法： ​ 有3个操作数（内存值V， 旧的预期值A，要修改的值B） ​ 当旧的预期值A == 内存值 此时修改成功，将V改为B ​ 当旧的预期值A！=内存值 此时修改失败，不做任何操作 ​ 并重新获取现在的最新值（这个重新获取的动作就是自旋） 2.8 AtomicInteger-源码解析代码实现 : 1234567891011package com.itheima.threadatom4;public class AtomDemo &#123; public static void main(String[] args) &#123; MyAtomThread atom = new MyAtomThread(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(atom).start(); &#125; &#125;&#125; 123456789101112131415161718192021222324package com.itheima.threadatom4;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomThread implements Runnable &#123; //private volatile int count = 0; //送冰淇淋的数量 //private Object lock = new Object(); AtomicInteger ac = new AtomicInteger(0); @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; //1,从共享数据中读取数据到本线程栈中. //2,修改本线程栈中变量副本的值 //3,会把本线程栈中变量副本的值赋值给共享数据. //synchronized (lock) &#123;// count++;// ac++; int count = ac.incrementAndGet(); System.out.println(\"已经送了\" + count + \"个冰淇淋\"); // &#125; &#125; &#125;&#125; 源码解析 : 1234567891011121314151617181920212223242526//先自增，然后获取自增后的结果public final int incrementAndGet() &#123; //+ 1 自增后的结果 //this 就表示当前的atomicInteger（值） //1 自增一次 return U.getAndAddInt(this, VALUE, 1) + 1;&#125;public final int getAndAddInt(Object o, long offset, int delta) &#123; //v 旧值 int v; //自旋的过程 do &#123; //不断的获取旧值 v = getIntVolatile(o, offset); //如果这个方法的返回值为false，那么继续自旋 //如果这个方法的返回值为true，那么自旋结束 //o 表示的就是内存值 //v 旧值 //v + delta 修改后的值 &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta)); //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。 // 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。 //如果修改失败，那么继续自旋。 return v;&#125; 2.9 悲观锁和乐观锁synchronized和CAS的区别 : 相同点：在多线程情况下，都可以保证共享数据的安全性。 不同点：synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每 次操作共享数据之前，都会上锁。（悲观锁） ​ cas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。 ​ 如果别人修改过，那么我再次获取现在最新的值。 ​ 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁） 3. 并发工具类3.1 并发工具类-Hashtable​ Hashtable出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。 代码实现 : 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.mymap;import java.util.HashMap;import java.util.Hashtable;public class MyHashtableDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Hashtable&lt;String, String&gt; hm = new Hashtable&lt;&gt;(); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 25; i++) &#123; hm.put(i + \"\", i + \"\"); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 25; i &lt; 51; i++) &#123; hm.put(i + \"\", i + \"\"); &#125; &#125;); t1.start(); t2.start(); System.out.println(\"----------------------------\"); //为了t1和t2能把数据全部添加完毕 Thread.sleep(1000); //0-0 1-1 ..... 50- 50 for (int i = 0; i &lt; 51; i++) &#123; System.out.println(hm.get(i + \"\")); &#125;//0 1 2 3 .... 50 &#125;&#125; 3.2 并发工具类-ConcurrentHashMap基本使用​ ConcurrentHashMap出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。 基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。 体系结构 : 总结 : ​ 1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题 ​ 2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下 ​ 3，ConcurrentHashMap也是线程安全的，效率较高。 在JDK7和JDK8中，底层原理不一样。 代码实现 : 123456789101112131415161718192021222324252627282930313233343536package com.itheima.mymap;import java.util.Hashtable;import java.util.concurrent.ConcurrentHashMap;public class MyConcurrentHashMapDemo &#123; public static void main(String[] args) throws InterruptedException &#123; ConcurrentHashMap&lt;String, String&gt; hm = new ConcurrentHashMap&lt;&gt;(100); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 25; i++) &#123; hm.put(i + \"\", i + \"\"); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 25; i &lt; 51; i++) &#123; hm.put(i + \"\", i + \"\"); &#125; &#125;); t1.start(); t2.start(); System.out.println(\"----------------------------\"); //为了t1和t2能把数据全部添加完毕 Thread.sleep(1000); //0-0 1-1 ..... 50- 50 for (int i = 0; i &lt; 51; i++) &#123; System.out.println(hm.get(i + \"\")); &#125;//0 1 2 3 .... 50 &#125;&#125; 3.3 并发工具类-ConcurrentHashMap1.7原理 3.4 并发工具类-ConcurrentHashMap1.8原理 总结 : ​ 1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。 在第一次添加元素的时候创建哈希表 ​ 2，计算当前元素应存入的索引。 ​ 3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。 ​ 4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。 ​ 5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性 3.5 并发工具类-CountDownLatchCountDownLatch类 : 方法 解释 public CountDownLatch(int count) 参数传递线程数，表示等待线程数量 public void await() 让线程等待 public void countDown() 当前线程执行完毕 使用场景： 让某一条线程等待其他线程执行完毕之后再执行 代码实现 : 12345678910111213141516171819202122package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread1 extends Thread &#123; private CountDownLatch countDownLatch; public ChileThread1(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.吃饺子 for (int i = 1; i &lt;= 10; i++) &#123; System.out.println(getName() + \"在吃第\" + i + \"个饺子\"); &#125; //2.吃完说一声 //每一次countDown方法的时候，就让计数器-1 countDownLatch.countDown(); &#125;&#125; 123456789101112131415161718192021package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread2 extends Thread &#123; private CountDownLatch countDownLatch; public ChileThread2(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.吃饺子 for (int i = 1; i &lt;= 15; i++) &#123; System.out.println(getName() + \"在吃第\" + i + \"个饺子\"); &#125; //2.吃完说一声 //每一次countDown方法的时候，就让计数器-1 countDownLatch.countDown(); &#125;&#125; 123456789101112131415161718192021package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread3 extends Thread &#123; private CountDownLatch countDownLatch; public ChileThread3(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.吃饺子 for (int i = 1; i &lt;= 20; i++) &#123; System.out.println(getName() + \"在吃第\" + i + \"个饺子\"); &#125; //2.吃完说一声 //每一次countDown方法的时候，就让计数器-1 countDownLatch.countDown(); &#125;&#125; 1234567891011121314151617181920212223package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class MotherThread extends Thread &#123; private CountDownLatch countDownLatch; public MotherThread(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.等待 try &#123; //当计数器变成0的时候，会自动唤醒这里等待的线程。 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //2.收拾碗筷 System.out.println(\"妈妈在收拾碗筷\"); &#125;&#125; 123456789101112131415161718192021222324252627package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class MyCountDownLatchDemo &#123; public static void main(String[] args) &#123; //1.创建CountDownLatch的对象，需要传递给四个线程。 //在底层就定义了一个计数器，此时计数器的值就是3 CountDownLatch countDownLatch = new CountDownLatch(3); //2.创建四个线程对象并开启他们。 MotherThread motherThread = new MotherThread(countDownLatch); motherThread.start(); ChileThread1 t1 = new ChileThread1(countDownLatch); t1.setName(\"小明\"); ChileThread2 t2 = new ChileThread2(countDownLatch); t2.setName(\"小红\"); ChileThread3 t3 = new ChileThread3(countDownLatch); t3.setName(\"小刚\"); t1.start(); t2.start(); t3.start(); &#125;&#125; 总结 : ​ 1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。 ​ 2. await()：让线程等待，当计数器为0时，会唤醒等待的线程 ​ 3. countDown()： 线程执行完毕时调用，会将计数器-1。 3.6 并发工具类-Semaphore使用场景 : ​ 可以控制访问特定资源的线程数量。 实现步骤 : ​ 1，需要有人管理这个通道 ​ 2，当有车进来了，发通行许可证 ​ 3，当车出去了，收回通行许可证 ​ 4，如果通行许可证发完了，那么其他车辆只能等着 代码实现 : 1234567891011121314151617181920212223package com.itheima.mysemaphore;import java.util.concurrent.Semaphore;public class MyRunnable implements Runnable &#123; //1.获得管理员对象， private Semaphore semaphore = new Semaphore(2); @Override public void run() &#123; //2.获得通行证 try &#123; semaphore.acquire(); //3.开始行驶 System.out.println(\"获得了通行证开始行驶\"); Thread.sleep(2000); System.out.println(\"归还通行证\"); //4.归还通行证 semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011package com.itheima.mysemaphore;public class MySemaphoreDemo &#123; public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(mr).start(); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"23_多线程01","slug":"36_多线程01","date":"2020-11-12T13:18:22.000Z","updated":"2020-11-12T13:20:16.433Z","comments":true,"path":"2020/11/12/36_多线程01/","link":"","permalink":"http://xiaojujing.com/2020/11/12/36_%E5%A4%9A%E7%BA%BF%E7%A8%8B01/","excerpt":"1.实现多线程1.1简单了解多线程【理解】是指从软件或者硬件上实现多个线程并发执行的技术。","text":"1.实现多线程1.1简单了解多线程【理解】是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。 1.2并发和并行【理解】 并行：在同一时刻，有多个指令在多个CPU上同时执行。 并发：在同一时刻，有多个指令在单个CPU上交替执行。 1.3进程和线程【理解】 进程：是正在运行的程序 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的并发性：任何进程都可以同其他进程一起并发执行 线程：是进程中的单个顺序控制流，是一条执行路径 ​ 单线程：一个进程如果只有一条执行路径，则称为单线程程序 ​ 多线程：一个进程如果有多条执行路径，则称为多线程程序 ​ 1.4实现多线程方式一：继承Thread类【应用】 方法介绍 方法名 说明 void run() 在线程开启后，此方法将被调用执行 void start() 使此线程开始执行，Java虚拟机会调用run方法() 实现步骤 定义一个类MyThread继承Thread类 在MyThread类中重写run()方法 创建MyThread类的对象 启动线程 代码演示 123456789101112131415161718192021public class MyThread extends Thread &#123; @Override public void run() &#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(i); &#125; &#125;&#125;public class MyThreadDemo &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); MyThread my2 = new MyThread();// my1.run();// my2.run(); //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法 my1.start(); my2.start(); &#125;&#125; 两个小问题 为什么要重写run()方法？ 因为run()是用来封装被线程执行的代码 run()方法和start()方法的区别？ run()：封装线程执行的代码，直接调用，相当于普通方法的调用 start()：启动线程；然后由JVM调用此线程的run()方法 1.5实现多线程方式二：实现Runnable接口【应用】 Thread构造方法 方法名 说明 Thread(Runnable target) 分配一个新的Thread对象 Thread(Runnable target, String name) 分配一个新的Thread对象 实现步骤 定义一个类MyRunnable实现Runnable接口 在MyRunnable类中重写run()方法 创建MyRunnable类的对象 创建Thread类的对象，把MyRunnable对象作为构造方法的参数 启动线程 代码演示 1234567891011121314151617181920212223242526public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(Thread.currentThread().getName()+\":\"+i); &#125; &#125;&#125;public class MyRunnableDemo &#123; public static void main(String[] args) &#123; //创建MyRunnable类的对象 MyRunnable my = new MyRunnable(); //创建Thread类的对象，把MyRunnable对象作为构造方法的参数 //Thread(Runnable target)// Thread t1 = new Thread(my);// Thread t2 = new Thread(my); //Thread(Runnable target, String name) Thread t1 = new Thread(my,\"坦克\"); Thread t2 = new Thread(my,\"飞机\"); //启动线程 t1.start(); t2.start(); &#125;&#125; 1.6实现多线程方式三: 实现Callable接口【应用】 方法介绍 方法名 说明 V call() 计算结果，如果无法计算结果，则抛出一个异常 FutureTask(Callable callable) 创建一个 FutureTask，一旦运行就执行给定的 Callable V get() 如有必要，等待计算完成，然后获取其结果 实现步骤 定义一个类MyCallable实现Callable接口 在MyCallable类中重写call()方法 创建MyCallable类的对象 创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数 创建Thread类的对象，把FutureTask对象作为构造方法的参数 启动线程 再调用get方法，就可以获取线程结束之后的结果。 代码演示 12345678910111213141516171819202122232425262728293031public class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"跟女孩表白\" + i); &#125; //返回值就表示线程运行完毕之后的结果 return \"答应\"; &#125;&#125;public class Demo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //线程开启之后需要执行里面的call方法 MyCallable mc = new MyCallable(); //Thread t1 = new Thread(mc); //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象 FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(mc); //创建线程对象 Thread t1 = new Thread(ft); String s = ft.get(); //开启线程 t1.start(); //String s = ft.get(); System.out.println(s); &#125;&#125; 三种实现方式的对比 实现Runnable、Callable接口 好处: 扩展性强，实现该接口的同时还可以继承其他的类 缺点: 编程相对复杂，不能直接使用Thread类中的方法 继承Thread类 好处: 编程比较简单，可以直接使用Thread类中的方法 缺点: 可以扩展性较差，不能再继承其他的类 1.7设置和获取线程名称【应用】 方法介绍 方法名 说明 void setName(String name) 将此线程的名称更改为等于参数name String getName() 返回此线程的名称 Thread currentThread() 返回对当前正在执行的线程对象的引用 代码演示 123456789101112131415161718192021222324252627282930313233public class MyThread extends Thread &#123; public MyThread() &#123;&#125; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(getName()+\":\"+i); &#125; &#125;&#125;public class MyThreadDemo &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); MyThread my2 = new MyThread(); //void setName(String name)：将此线程的名称更改为等于参数 name my1.setName(\"高铁\"); my2.setName(\"飞机\"); //Thread(String name) MyThread my1 = new MyThread(\"高铁\"); MyThread my2 = new MyThread(\"飞机\"); my1.start(); my2.start(); //static Thread currentThread() 返回对当前正在执行的线程对象的引用 System.out.println(Thread.currentThread().getName()); &#125;&#125; 1.8线程休眠【应用】 相关方法 方法名 说明 static void sleep(long millis) 使当前正在执行的线程停留（暂停执行）指定的毫秒数 代码演示 1234567891011121314151617181920212223242526272829public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"---\" + i); &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) throws InterruptedException &#123; /*System.out.println(\"睡觉前\"); Thread.sleep(3000); System.out.println(\"睡醒了\");*/ MyRunnable mr = new MyRunnable(); Thread t1 = new Thread(mr); Thread t2 = new Thread(mr); t1.start(); t2.start(); &#125;&#125; 1.9线程优先级【应用】 线程调度 两种调度方式 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些 Java使用的是抢占式调度模型 随机性 假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的 优先级相关方法 方法名 说明 final int getPriority() 返回此线程的优先级 final void setPriority(int newPriority) 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 代码演示 123456789101112131415161718192021222324252627282930313233public class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + \"---\" + i); &#125; return \"线程执行完毕了\"; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; //优先级: 1 - 10 默认值:5 MyCallable mc = new MyCallable(); FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(mc); Thread t1 = new Thread(ft); t1.setName(\"飞机\"); t1.setPriority(10); //System.out.println(t1.getPriority());//5 t1.start(); MyCallable mc2 = new MyCallable(); FutureTask&lt;String&gt; ft2 = new FutureTask&lt;&gt;(mc2); Thread t2 = new Thread(ft2); t2.setName(\"坦克\"); t2.setPriority(1); //System.out.println(t2.getPriority());//5 t2.start(); &#125;&#125; 1.10守护线程【应用】 相关方法 方法名 说明 void setDaemon(boolean on) 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 代码演示 1234567891011121314151617181920212223242526272829303132public class MyThread1 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + \"---\" + i); &#125; &#125;&#125;public class MyThread2 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(getName() + \"---\" + i); &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); MyThread2 t2 = new MyThread2(); t1.setName(\"女神\"); t2.setName(\"备胎\"); //把第二个线程设置为守护线程 //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了. t2.setDaemon(true); t1.start(); t2.start(); &#125;&#125; 2.线程同步2.1卖票【应用】 案例需求 某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票 实现步骤 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100; 在SellTicket类中重写run()方法实现卖票，代码步骤如下 判断票数大于0，就卖票，并告知是哪个窗口卖的 卖了票之后，总票数要减1 票卖没了，线程停止 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下 创建SellTicket类的对象 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 启动线程 代码实现 12345678910111213141516171819202122232425262728293031323334353637public class SellTicket implements Runnable &#123; private int tickets = 100; //在SellTicket类中重写run()方法实现卖票，代码步骤如下 @Override public void run() &#123; while (true) &#123; if(ticket &lt;= 0)&#123; //卖完了 break; &#125;else&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ticket--; System.out.println(Thread.currentThread().getName() + \"在卖票,还剩下\" + ticket + \"张票\"); &#125; &#125; &#125;&#125;public class SellTicketDemo &#123; public static void main(String[] args) &#123; //创建SellTicket类的对象 SellTicket st = new SellTicket(); //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 Thread t1 = new Thread(st,\"窗口1\"); Thread t2 = new Thread(st,\"窗口2\"); Thread t3 = new Thread(st,\"窗口3\"); //启动线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 2.2卖票案例的问题【理解】 卖票出现了问题 相同的票出现了多次 出现了负数的票 问题产生原因 线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题 2.3同步代码块解决数据安全问题【应用】 安全问题出现的条件 是多线程环境 有共享数据 有多条语句操作共享数据 如何解决多线程安全问题呢? 基本思想：让程序没有安全问题的环境 怎么实现呢? 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可 Java提供了同步代码块的方式来解决 同步代码块格式： 123synchronized(任意对象) &#123; 多条语句操作共享数据的代码 &#125; synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁 同步的好处和弊端 好处：解决了多线程的数据安全问题 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率 代码演示 123456789101112131415161718192021222324252627282930313233343536373839public class SellTicket implements Runnable &#123; private int tickets = 100; private Object obj = new Object(); @Override public void run() &#123; while (true) &#123; synchronized (obj) &#123; // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁 //t1进来后，就会把这段代码给锁起来 if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); //t1休息100毫秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //窗口1正在出售第100张票 System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; //tickets = 99; &#125; &#125; //t1出来了，这段代码的锁就被释放了 &#125; &#125;&#125;public class SellTicketDemo &#123; public static void main(String[] args) &#123; SellTicket st = new SellTicket(); Thread t1 = new Thread(st, \"窗口1\"); Thread t2 = new Thread(st, \"窗口2\"); Thread t3 = new Thread(st, \"窗口3\"); t1.start(); t2.start(); t3.start(); &#125;&#125; 2.4同步方法解决数据安全问题【应用】 同步方法的格式 同步方法：就是把synchronized关键字加到方法上 123修饰符 synchronized 返回值类型 方法名(方法参数) &#123; 方法体；&#125; 同步方法的锁对象是什么呢? ​ this 静态同步方法 同步静态方法：就是把synchronized关键字加到静态方法上 123修饰符 static synchronized 返回值类型 方法名(方法参数) &#123; 方法体；&#125; 同步静态方法的锁对象是什么呢? ​ 类名.class 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyRunnable implements Runnable &#123; private static int ticketCount = 100; @Override public void run() &#123; while(true)&#123; if(\"窗口一\".equals(Thread.currentThread().getName()))&#123; //同步方法 boolean result = synchronizedMthod(); if(result)&#123; break; &#125; &#125; if(\"窗口二\".equals(Thread.currentThread().getName()))&#123; //同步代码块 synchronized (MyRunnable.class)&#123; if(ticketCount == 0)&#123; break; &#125;else&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ticketCount--; System.out.println(Thread.currentThread().getName() + \"在卖票,还剩下\" + ticketCount + \"张票\"); &#125; &#125; &#125; &#125; &#125; private static synchronized boolean synchronizedMthod() &#123; if(ticketCount == 0)&#123; return true; &#125;else&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ticketCount--; System.out.println(Thread.currentThread().getName() + \"在卖票,还剩下\" + ticketCount + \"张票\"); return false; &#125; &#125;&#125; public class Demo { public static void main(String[] args) { MyRunnable mr = new MyRunnable(); Thread t1 = new Thread(mr); Thread t2 = new Thread(mr); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t1.start(); t2.start(); } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869### 2.5Lock锁【应用】虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象LockLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化- ReentrantLock构造方法 | 方法名 | 说明 | | --------------- | -------------------- | | ReentrantLock() | 创建一个ReentrantLock的实例 |- 加锁解锁方法 | 方法名 | 说明 | | ------------- | ---- | | void lock() | 获得锁 | | void unlock() | 释放锁 |- 代码演示 &#96;&#96;&#96;java public class Ticket implements Runnable &#123; &#x2F;&#x2F;票的数量 private int ticket &#x3D; 100; private Object obj &#x3D; new Object(); private ReentrantLock lock &#x3D; new ReentrantLock(); @Override public void run() &#123; while (true) &#123; &#x2F;&#x2F;synchronized (obj)&#123;&#x2F;&#x2F;多个线程必须使用同一把锁. try &#123; lock.lock(); if (ticket &lt;&#x3D; 0) &#123; &#x2F;&#x2F;卖完了 break; &#125; else &#123; Thread.sleep(100); ticket--; System.out.println(Thread.currentThread().getName() + &quot;在卖票,还剩下&quot; + ticket + &quot;张票&quot;); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#x2F;&#x2F; &#125; &#125; &#125; &#125; public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket &#x3D; new Ticket(); Thread t1 &#x3D; new Thread(ticket); Thread t2 &#x3D; new Thread(ticket); Thread t3 &#x3D; new Thread(ticket); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125; &#125; 2.6死锁【理解】 概述 线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行 什么情况下会产生死锁 资源有限 同步嵌套 代码演示 12345678910111213141516171819202122232425262728public class Demo &#123; public static void main(String[] args) &#123; Object objA = new Object(); Object objB = new Object(); new Thread(()-&gt;&#123; while(true)&#123; synchronized (objA)&#123; //线程一 synchronized (objB)&#123; System.out.println(\"小康同学正在走路\"); &#125; &#125; &#125; &#125;).start(); new Thread(()-&gt;&#123; while(true)&#123; synchronized (objB)&#123; //线程二 synchronized (objA)&#123; System.out.println(\"小薇同学正在走路\"); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 3.生产者消费者3.1生产者和消费者模式概述【应用】 概述 生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。 所谓生产者消费者问题，实际上主要是包含了两类线程： ​ 一类是生产者线程用于生产数据 ​ 一类是消费者线程用于消费数据 为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库 生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为 消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为 Object类的等待和唤醒方法 方法名 说明 void wait() 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 void notify() 唤醒正在等待对象监视器的单个线程 void notifyAll() 唤醒正在等待对象监视器的所有线程 3.2生产者和消费者案例【应用】 案例需求 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务 1.判断是否有包子,决定当前线程是否执行 2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子 3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务 1.判断是否有包子,决定当前线程是否执行 2.如果没有包子,就进入等待状态,如果有包子,就消费包子 3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子 测试类(Demo)：里面有main方法，main方法中的代码步骤如下 创建生产者线程和消费者线程对象 分别开启两个线程 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class Desk &#123; //定义一个标记 //true 就表示桌子上有汉堡包的,此时允许吃货执行 //false 就表示桌子上没有汉堡包的,此时允许厨师执行 public static boolean flag = false; //汉堡包的总数量 public static int count = 10; //锁对象 public static final Object lock = new Object();&#125;public class Cooker extends Thread &#123;// 生产者步骤：// 1，判断桌子上是否有汉堡包// 如果有就等待，如果没有才生产。// 2，把汉堡包放在桌子上。// 3，叫醒等待的消费者开吃。 @Override public void run() &#123; while(true)&#123; synchronized (Desk.lock)&#123; if(Desk.count == 0)&#123; break; &#125;else&#123; if(!Desk.flag)&#123; //生产 System.out.println(\"厨师正在生产汉堡包\"); Desk.flag = true; Desk.lock.notifyAll(); &#125;else&#123; try &#123; Desk.lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Foodie extends Thread &#123; @Override public void run() &#123;// 1，判断桌子上是否有汉堡包。// 2，如果没有就等待。// 3，如果有就开吃// 4，吃完之后，桌子上的汉堡包就没有了// 叫醒等待的生产者继续生产// 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while(true)&#123; synchronized (Desk.lock)&#123; if(Desk.count == 0)&#123; break; &#125;else&#123; if(Desk.flag)&#123; //有 System.out.println(\"吃货在吃汉堡包\"); Desk.flag = false; Desk.lock.notifyAll(); Desk.count--; &#125;else&#123; //没有就等待 //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法. try &#123; Desk.lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; /*消费者步骤： 1，判断桌子上是否有汉堡包。 2，如果没有就等待。 3，如果有就开吃 4，吃完之后，桌子上的汉堡包就没有了 叫醒等待的生产者继续生产 汉堡包的总数量减一*/ /*生产者步骤： 1，判断桌子上是否有汉堡包 如果有就等待，如果没有才生产。 2，把汉堡包放在桌子上。 3，叫醒等待的消费者开吃。*/ Foodie f = new Foodie(); Cooker c = new Cooker(); f.start(); c.start(); &#125;&#125; 3.3生产者和消费者案例优化【应用】 需求 将Desk类中的变量,采用面向对象的方式封装起来 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用 创建生产者和消费者线程对象,构造方法中传入Desk类对象 开启两个线程 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171public class Desk &#123; //定义一个标记 //true 就表示桌子上有汉堡包的,此时允许吃货执行 //false 就表示桌子上没有汉堡包的,此时允许厨师执行 //public static boolean flag = false; private boolean flag; //汉堡包的总数量 //public static int count = 10; //以后我们在使用这种必须有默认值的变量 // private int count = 10; private int count; //锁对象 //public static final Object lock = new Object(); private final Object lock = new Object(); public Desk() &#123; this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了 &#125; public Desk(boolean flag, int count) &#123; this.flag = flag; this.count = count; &#125; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; public Object getLock() &#123; return lock; &#125; @Override public String toString() &#123; return \"Desk&#123;\" + \"flag=\" + flag + \", count=\" + count + \", lock=\" + lock + '&#125;'; &#125;&#125;public class Cooker extends Thread &#123; private Desk desk; public Cooker(Desk desk) &#123; this.desk = desk; &#125;// 生产者步骤：// 1，判断桌子上是否有汉堡包// 如果有就等待，如果没有才生产。// 2，把汉堡包放在桌子上。// 3，叫醒等待的消费者开吃。 @Override public void run() &#123; while(true)&#123; synchronized (desk.getLock())&#123; if(desk.getCount() == 0)&#123; break; &#125;else&#123; //System.out.println(\"验证一下是否执行了\"); if(!desk.isFlag())&#123; //生产 System.out.println(\"厨师正在生产汉堡包\"); desk.setFlag(true); desk.getLock().notifyAll(); &#125;else&#123; try &#123; desk.getLock().wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Foodie extends Thread &#123; private Desk desk; public Foodie(Desk desk) &#123; this.desk = desk; &#125; @Override public void run() &#123;// 1，判断桌子上是否有汉堡包。// 2，如果没有就等待。// 3，如果有就开吃// 4，吃完之后，桌子上的汉堡包就没有了// 叫醒等待的生产者继续生产// 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while(true)&#123; synchronized (desk.getLock())&#123; if(desk.getCount() == 0)&#123; break; &#125;else&#123; //System.out.println(\"验证一下是否执行了\"); if(desk.isFlag())&#123; //有 System.out.println(\"吃货在吃汉堡包\"); desk.setFlag(false); desk.getLock().notifyAll(); desk.setCount(desk.getCount() - 1); &#125;else&#123; //没有就等待 //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法. try &#123; desk.getLock().wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; /*消费者步骤： 1，判断桌子上是否有汉堡包。 2，如果没有就等待。 3，如果有就开吃 4，吃完之后，桌子上的汉堡包就没有了 叫醒等待的生产者继续生产 汉堡包的总数量减一*/ /*生产者步骤： 1，判断桌子上是否有汉堡包 如果有就等待，如果没有才生产。 2，把汉堡包放在桌子上。 3，叫醒等待的消费者开吃。*/ Desk desk = new Desk(); Foodie f = new Foodie(desk); Cooker c = new Cooker(desk); f.start(); c.start(); &#125;&#125; 3.4阻塞队列基本使用【理解】 阻塞队列继承结构 常见BlockingQueue: ArrayBlockingQueue: 底层是数组,有界 LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值 BlockingQueue的核心方法: put(anObject): 将参数放入队列,如果放不进去会阻塞 take(): 取出第一个数据,取不到会阻塞 代码示例 123456789101112131415public class Demo02 &#123; public static void main(String[] args) throws Exception &#123; // 创建阻塞队列的对象,容量为 1 ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(1); // 存储元素 arrayBlockingQueue.put(\"汉堡包\"); // 取元素 System.out.println(arrayBlockingQueue.take()); System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞 System.out.println(\"程序结束了\"); &#125;&#125; 3.5阻塞队列实现等待唤醒机制【理解】 案例需求 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务 1.构造方法中接收一个阻塞队列对象 2.在run方法中循环向阻塞队列中添加包子 3.打印添加结果 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务 1.构造方法中接收一个阻塞队列对象 2.在run方法中循环获取阻塞队列中的包子 3.打印获取结果 测试类(Demo)：里面有main方法，main方法中的代码步骤如下 创建阻塞队列对象 创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象 分别开启两个线程 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Cooker extends Thread &#123; private ArrayBlockingQueue&lt;String&gt; bd; public Cooker(ArrayBlockingQueue&lt;String&gt; bd) &#123; this.bd = bd; &#125;// 生产者步骤：// 1，判断桌子上是否有汉堡包// 如果有就等待，如果没有才生产。// 2，把汉堡包放在桌子上。// 3，叫醒等待的消费者开吃。 @Override public void run() &#123; while (true) &#123; try &#123; bd.put(\"汉堡包\"); System.out.println(\"厨师放入一个汉堡包\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Foodie extends Thread &#123; private ArrayBlockingQueue&lt;String&gt; bd; public Foodie(ArrayBlockingQueue&lt;String&gt; bd) &#123; this.bd = bd; &#125; @Override public void run() &#123;// 1，判断桌子上是否有汉堡包。// 2，如果没有就等待。// 3，如果有就开吃// 4，吃完之后，桌子上的汉堡包就没有了// 叫醒等待的生产者继续生产// 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while (true) &#123; try &#123; String take = bd.take(); System.out.println(\"吃货将\" + take + \"拿出来吃了\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; ArrayBlockingQueue&lt;String&gt; bd = new ArrayBlockingQueue&lt;&gt;(1); Foodie f = new Foodie(bd); Cooker c = new Cooker(bd); f.start(); c.start(); &#125;&#125;","categories":[],"tags":[]},{"title":"22_IO流02","slug":"35_IO流02","date":"2020-11-11T06:31:17.000Z","updated":"2020-11-11T06:40:06.228Z","comments":true,"path":"2020/11/11/35_IO流02/","link":"","permalink":"http://xiaojujing.com/2020/11/11/35_IO%E6%B5%8102/","excerpt":"1.字符流1.1为什么会出现字符流【理解】 字符流的介绍","text":"1.字符流1.1为什么会出现字符流【理解】 字符流的介绍 由于字节流操作中文不是特别的方便，所以Java就提供字符流 字符流 = 字节流 + 编码表 中文的字节存储方式 用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？ 汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数 1.2编码表【理解】 什么是字符集 是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等 常见的字符集 ASCII字符集： lASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) 基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 GBXXX字符集： GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等 Unicode字符集： UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码 编码规则： 128个US-ASCII字符，只需一个字节编码 拉丁文等字符，需要二个字节编码 大部分常用字（含中文），使用三个字节编码 其他极少使用的Unicode辅助字符，使用四字节编码 1.3字符串中的编码解码问题【应用】 相关方法 方法名 说明 byte[] getBytes() 使用平台的默认字符集将该 String编码为一系列字节 byte[] getBytes(String charsetName) 使用指定的字符集将该 String编码为一系列字节 String(byte[] bytes) 使用平台的默认字符集解码指定的字节数组来创建字符串 String(byte[] bytes, String charsetName) 通过指定的字符集解码指定的字节数组来创建字符串 代码演示 12345678910111213141516public class StringDemo &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; //定义一个字符串 String s = \"中国\"; //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67] //byte[] bys = s.getBytes(\"UTF-8\"); //[-28, -72, -83, -27, -101, -67] byte[] bys = s.getBytes(\"GBK\"); //[-42, -48, -71, -6] System.out.println(Arrays.toString(bys)); //String ss = new String(bys); //String ss = new String(bys,\"UTF-8\"); String ss = new String(bys,\"GBK\"); System.out.println(ss); &#125;&#125; 1.4字符流写数据【应用】 介绍 Writer: 用于写入字符流的抽象父类 FileWriter: 用于写入字符流的常用子类 构造方法 方法名 说明 FileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象 FileWriter(File file, boolean append) 根据给定的 File 对象构造一个 FileWriter 对象 FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象 FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象 成员方法 方法名 说明 void write(int c) 写一个字符 void write(char[] cbuf) 写入一个字符数组 void write(char[] cbuf, int off, int len) 写入字符数组的一部分 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分 刷新和关闭的方法 方法名 说明 flush() 刷新流，之后还可以继续写数据 close() 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 代码演示 12345678910111213141516171819202122232425262728public class OutputStreamWriterDemo &#123; public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWriter(\"myCharStream\\\\a.txt\"); //void write(int c)：写一个字符// fw.write(97);// fw.write(98);// fw.write(99); //void writ(char[] cbuf)：写入一个字符数组 char[] chs = &#123;'a', 'b', 'c', 'd', 'e'&#125;;// fw.write(chs); //void write(char[] cbuf, int off, int len)：写入字符数组的一部分// fw.write(chs, 0, chs.length);// fw.write(chs, 1, 3); //void write(String str)：写一个字符串// fw.write(\"abcde\"); //void write(String str, int off, int len)：写一个字符串的一部分// fw.write(\"abcde\", 0, \"abcde\".length()); fw.write(\"abcde\", 1, 3); //释放资源 fw.close(); &#125;&#125; 1.5字符流读数据【应用】 介绍 Reader: 用于读取字符流的抽象父类 FileReader: 用于读取字符流的常用子类 构造方法 方法名 说明 FileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader 成员方法 方法名 说明 int read() 一次读一个字符数据 int read(char[] cbuf) 一次读一个字符数组数据 代码演示 12345678910111213141516171819202122public class InputStreamReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader(\"myCharStream\\\\b.txt\"); //int read()：一次读一个字符数据// int ch;// while ((ch=fr.read())!=-1) &#123;// System.out.print((char)ch);// &#125; //int read(char[] cbuf)：一次读一个字符数组数据 char[] chs = new char[1024]; int len; while ((len = fr.read(chs)) != -1) &#123; System.out.print(new String(chs, 0, len)); &#125; //释放资源 fr.close(); &#125;&#125; 1.6字符流用户注册案例【应用】 案例需求 将键盘录入的用户名和密码保存到本地实现永久化存储 实现步骤 获取用户输入的用户名和密码 将用户输入的用户名和密码写入到本地文件中 关流,释放资源 代码实现 1234567891011121314151617181920212223242526public class CharStreamDemo8 &#123; public static void main(String[] args) throws IOException &#123; //需求: 将键盘录入的用户名和密码保存到本地实现永久化存储 //要求：用户名独占一行，密码独占一行 //分析： //1，实现键盘录入，把用户名和密码录入进来 Scanner sc = new Scanner(System.in); System.out.println(\"请录入用户名\"); String username = sc.next(); System.out.println(\"请录入密码\"); String password = sc.next(); //2.分别把用户名和密码写到本地文件。 FileWriter fw = new FileWriter(\"charstream\\\\a.txt\"); //将用户名和密码写到文件中 fw.write(username); //表示写出一个回车换行符 windows \\r\\n MacOS \\r Linux \\n fw.write(\"\\r\\n\"); fw.write(password); //刷新流 fw.flush(); //3.关流,释放资源 fw.close(); &#125;&#125; 1.7字符缓冲流【应用】 字符缓冲流介绍 BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途 BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途 构造方法 方法名 说明 BufferedWriter(Writer out) 创建字符缓冲输出流对象 BufferedReader(Reader in) 创建字符缓冲输入流对象 代码演示 123456789101112131415161718192021222324252627public class BufferedStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //BufferedWriter(Writer out) BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); bw.write(\"hello\\r\\n\"); bw.write(\"world\\r\\n\"); bw.close(); //BufferedReader(Reader in) BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); //一次读取一个字符数据// int ch;// while ((ch=br.read())!=-1) &#123;// System.out.print((char)ch);// &#125; //一次读取一个字符数组数据 char[] chs = new char[1024]; int len; while ((len=br.read(chs))!=-1) &#123; System.out.print(new String(chs,0,len)); &#125; br.close(); &#125;&#125; 1.8字符缓冲流特有功能【应用】 方法介绍 BufferedWriter： 方法名 说明 void newLine() 写一行行分隔符，行分隔符字符串由系统属性定义 BufferedReader: 方法名 说明 String readLine() 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null 代码演示 12345678910111213141516171819202122232425262728public class BufferedStreamDemo02 &#123; public static void main(String[] args) throws IOException &#123; //创建字符缓冲输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); //写数据 for (int i = 0; i &lt; 10; i++) &#123; bw.write(\"hello\" + i); //bw.write(\"\\r\\n\"); bw.newLine(); bw.flush(); &#125; //释放资源 bw.close(); //创建字符缓冲输入流 BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); String line; while ((line=br.readLine())!=null) &#123; System.out.println(line); &#125; br.close(); &#125;&#125; 1.9字符缓冲流操作文件中数据排序案例【应用】 案例需求 使用字符缓冲流读取文件中的数据，排序后再次写到本地文件 实现步骤 将文件中的数据读取到程序中 对读取到的数据进行处理 将处理后的数据添加到集合中 对集合中的数据进行排序 将排序后的集合中的数据写入到文件中 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041public class CharStreamDemo14 &#123; public static void main(String[] args) throws IOException &#123; //需求：读取文件中的数据，排序后再次写到本地文件 //分析： //1.要把文件中的数据读取进来。 BufferedReader br = new BufferedReader(new FileReader(\"charstream\\\\sort.txt\")); //输出流一定不能写在这里，因为会清空文件中的内容 //BufferedWriter bw = new BufferedWriter(new FileWriter(\"charstream\\\\sort.txt\")); String line = br.readLine(); System.out.println(\"读取到的数据为\" + line); br.close(); //2.按照空格进行切割 String[] split = line.split(\" \");//9 1 2 5 3 10 4 6 7 8 //3.把字符串类型的数组变成int类型 int [] arr = new int[split.length]; //遍历split数组，可以进行类型转换。 for (int i = 0; i &lt; split.length; i++) &#123; String smallStr = split[i]; //类型转换 int number = Integer.parseInt(smallStr); //把转换后的结果存入到arr中 arr[i] = number; &#125; //4.排序 Arrays.sort(arr); System.out.println(Arrays.toString(arr)); //5.把排序之后结果写回到本地 1 2 3 4... BufferedWriter bw = new BufferedWriter(new FileWriter(\"charstream\\\\sort.txt\")); //写出 for (int i = 0; i &lt; arr.length; i++) &#123; bw.write(arr[i] + \" \"); bw.flush(); &#125; //释放资源 bw.close(); &#125;&#125; 1.10IO流小结【理解】 IO流小结 2.转换流2.1字符流中和编码解码问题相关的两个类【理解】 InputStreamReader：是从字节流到字符流的桥梁,父类是Reader ​ 它读取字节，并使用指定的编码将其解码为字符 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 OutputStreamWriter：是从字符流到字节流的桥梁,父类是Writer ​ 是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 2.2转换流读写数据【应用】 构造方法 方法名 说明 InputStreamReader(InputStream in) 使用默认字符编码创建InputStreamReader对象 InputStreamReader(InputStream in,String chatset) 使用指定的字符编码创建InputStreamReader对象 OutputStreamWriter(OutputStream out) 使用默认字符编码创建OutputStreamWriter对象 OutputStreamWriter(OutputStream out,String charset) 使用指定的字符编码创建OutputStreamWriter对象 代码演示 1234567891011121314151617public class ConversionStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\")); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); osw.write(\"中国\"); osw.close(); //InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\")); InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); //一次读取一个字符数据 int ch; while ((ch=isr.read())!=-1) &#123; System.out.print((char)ch); &#125; isr.close(); &#125;&#125; 3.对象操作流3.1对象序列化流【应用】 对象序列化介绍 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化 对象序列化流： ObjectOutputStream 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 构造方法 方法名 说明 ObjectOutputStream(OutputStream out) 创建一个写入指定的OutputStream的ObjectOutputStream 序列化对象的方法 方法名 说明 void writeObject(Object obj) 将指定的对象写入ObjectOutputStream 示例代码 学生类 123456789101112131415161718192021222324252627282930313233343536public class Student implements Serializable &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类 123456789101112131415public class ObjectOutputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); //创建对象 Student s = new Student(\"佟丽娅\",30); //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream oos.writeObject(s); //释放资源 oos.close(); &#125;&#125; 注意事项 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口 Serializable是一个标记接口，实现该接口，不需要重写任何方法 3.2对象反序列化流【应用】 对象反序列化流： ObjectInputStream ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象 构造方法 方法名 说明 ObjectInputStream(InputStream in) 创建从指定的InputStream读取的ObjectInputStream 反序列化对象的方法 方法名 说明 Object readObject() 从ObjectInputStream读取一个对象 示例代码 1234567891011121314public class ObjectInputStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); //Object readObject()：从ObjectInputStream读取一个对象 Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); &#125;&#125; 3.3serialVersionUID&amp;transient【应用】 serialVersionUID 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？ 会出问题，会抛出InvalidClassException异常 如果出问题了，如何解决呢？ 重新序列化 给对象所属的类加一个serialVersionUID private static final long serialVersionUID = 42L; transient 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？ 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程 示例代码 学生类 1234567891011121314151617181920212223242526272829303132333435363738public class Student implements Serializable &#123; private static final long serialVersionUID = 42L; private String name;// private int age; private transient int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;// @Override// public String toString() &#123;// return \"Student&#123;\" +// \"name='\" + name + '\\'' +// \", age=\" + age +// '&#125;';// &#125;&#125; 测试类 1234567891011121314151617181920212223public class ObjectStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123;// write(); read(); &#125; //反序列化 private static void read() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); &#125; //序列化 private static void write() throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); Student s = new Student(\"佟丽娅\", 30); oos.writeObject(s); oos.close(); &#125;&#125; 3.4对象操作流练习【应用】 案例需求 创建多个学生类对象写到文件中,再次读取到内存中 实现步骤 创建序列化流对象 创建多个学生对象 将学生对象添加到集合中 将集合对象序列化到文件中 创建反序列化流对象 将文件中的对象数据,读取到内存中 代码实现 学生类 12345678910111213141516171819202122232425262728293031public class Student implements Serializable&#123; private static final long serialVersionUID = 2L; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738public class Demo03 &#123; /** * read(): * 读取到文件末尾返回值是 -1 * readLine(): * 读取到文件的末尾返回值 null * readObject(): * 读取到文件的末尾 直接抛出异常 * 如果要序列化的对象有多个,不建议直接将多个对象序列化到文件中,因为反序列化时容易出异常 * 建议: 将要序列化的多个对象存储到集合中,然后将集合序列化到文件中 */ public static void main(String[] args) throws Exception &#123; /*// 序列化 //1.创建序列化流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myCode\\\\oos.txt\")); ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;(); //2.创建多个学生对象 Student s = new Student(\"佟丽娅\",30); Student s01 = new Student(\"佟丽娅\",30); //3.将学生对象添加到集合中 arrayList.add(s); arrayList.add(s01); //4.将集合对象序列化到文件中 oos.writeObject(arrayList); oos.close();*/ // 反序列化 //5.创建反序列化流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myCode\\\\oos.txt\")); //6.将文件中的对象数据,读取到内存中 Object obj = ois.readObject(); ArrayList&lt;Student&gt; arrayList = (ArrayList&lt;Student&gt;)obj; ois.close(); for (Student s : arrayList) &#123; System.out.println(s.getName() + \",\" + s.getAge()); &#125; &#125;&#125; 4.Properties集合4.1Properties作为Map集合的使用【应用】 Properties介绍 是一个Map体系的集合类 Properties可以保存到流中或从流中加载 属性列表中的每个键及其对应的值都是一个字符串 Properties基本使用 12345678910111213141516171819public class PropertiesDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象// Properties&lt;String,String&gt; prop = new Properties&lt;String,String&gt;(); //错误 Properties prop = new Properties(); //存储元素 prop.put(\"itheima001\", \"佟丽娅\"); prop.put(\"itheima002\", \"赵丽颖\"); prop.put(\"itheima003\", \"刘诗诗\"); //遍历集合 Set&lt;Object&gt; keySet = prop.keySet(); for (Object key : keySet) &#123; Object value = prop.get(key); System.out.println(key + \",\" + value); &#125; &#125;&#125; 4.2Properties作为Map集合的特有方法【应用】 特有方法 方法名 说明 Object setProperty(String key, String value) 设置集合的键和值，都是String类型，底层调用 Hashtable方法 put String getProperty(String key) 使用此属性列表中指定的键搜索属性 Set stringPropertyNames() 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 示例代码 12345678910111213141516171819202122232425public class PropertiesDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Properties prop = new Properties(); //Object setProperty(String key, String value)：设置集合的键和值，都是String类型 prop.setProperty(\"itheima001\", \"佟丽娅\"); prop.setProperty(\"itheima002\", \"赵丽颖\"); prop.setProperty(\"itheima003\", \"刘诗诗\"); //String getProperty(String key)：使用此属性列表中指定的键搜索属性// System.out.println(prop.getProperty(\"itheima001\"));// System.out.println(prop.getProperty(\"itheima0011\"));// System.out.println(prop); //Set&lt;String&gt; stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 Set&lt;String&gt; names = prop.stringPropertyNames(); for (String key : names) &#123;// System.out.println(key); String value = prop.getProperty(key); System.out.println(key + \",\" + value); &#125; &#125;&#125; 4.3Properties和IO流相结合的方法【应用】 和IO流结合的方法 方法名 说明 void load(Reader reader) 从输入字符流读取属性列表（键和元素对） void store(Writer writer, String comments) 将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 示例代码 12345678910111213141516171819202122232425262728293031323334public class PropertiesDemo03 &#123; public static void main(String[] args) throws IOException &#123; //把集合中的数据保存到文件// myStore(); //把文件中的数据加载到集合 myLoad(); &#125; private static void myLoad() throws IOException &#123; Properties prop = new Properties(); //void load(Reader reader)： FileReader fr = new FileReader(\"myOtherStream\\\\fw.txt\"); prop.load(fr); fr.close(); System.out.println(prop); &#125; private static void myStore() throws IOException &#123; Properties prop = new Properties(); prop.setProperty(\"itheima001\",\"佟丽娅\"); prop.setProperty(\"itheima002\",\"赵丽颖\"); prop.setProperty(\"itheima003\",\"刘诗诗\"); //void store(Writer writer, String comments)： FileWriter fw = new FileWriter(\"myOtherStream\\\\fw.txt\"); prop.store(fw,null); fw.close(); &#125;&#125; 4.4Properties集合练习【应用】 案例需求 在Properties文件中手动写上姓名和年龄,读取到集合中,将该数据封装成学生对象,写到本地文件 实现步骤 创建Properties集合,将本地文件中的数据加载到集合中 获取集合中的键值对数据,封装到学生对象中 创建序列化流对象,将学生对象序列化到本地文件中 代码实现 学生类 1234567891011121314151617181920212223242526272829303132333435363738public class Student implements Serializable &#123; private static final long serialVersionUID = 1L; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类 123456789101112131415161718public class Test &#123; public static void main(String[] args) throws IOException &#123; //1.创建Properties集合,将本地文件中的数据加载到集合中 Properties prop = new Properties(); FileReader fr = new FileReader(\"prop.properties\"); prop.load(fr); fr.close(); //2.获取集合中的键值对数据,封装到学生对象中 String name = prop.getProperty(\"name\"); int age = Integer.parseInt(prop.getProperty(\"age\")); Student s = new Student(name,age); //3.创建序列化流对象,将学生对象序列化到本地文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"a.txt\")); oos.writeObject(s); oos.close(); &#125;&#125;","categories":[],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://xiaojujing.com/tags/IO%E6%B5%81/"}]},{"title":"21_IO流01","slug":"34_IO流01","date":"2020-11-11T06:31:06.000Z","updated":"2020-11-11T06:39:22.531Z","comments":true,"path":"2020/11/11/34_IO流01/","link":"","permalink":"http://xiaojujing.com/2020/11/11/34_IO%E6%B5%8101/","excerpt":"1.File类1.1File类概述和构造方法【应用】 File类介绍 它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的","text":"1.File类1.1File类概述和构造方法【应用】 File类介绍 它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的 对于File而言,其封装的并不是一个真正存在的文件,仅仅是一个路径名而已.它可以是存在的,也可以是不存在的.将来是要通过具体的操作把这个路径的内容转换为具体存在的 File类的构造方法 方法名 说明 File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例 File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例 示例代码 12345678910111213141516public class FileDemo01 &#123; public static void main(String[] args) &#123; //File(String pathname): 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1); //File(String parent, String child): 从父路径名字符串和子路径名字符串创建新的 File实例 File f2 = new File(\"E:\\\\itcast\",\"java.txt\"); System.out.println(f2); //File(File parent, String child): 从父抽象路径名和子路径名字符串创建新的 File实例 File f3 = new File(\"E:\\\\itcast\"); File f4 = new File(f3,\"java.txt\"); System.out.println(f4); &#125;&#125; 1.2绝对路径和相对路径【理解】 绝对路径 是一个完整的路径,从盘符开始 相对路径 是一个简化的路径,相对当前项目下的路径 示例代码 12345678910public class FileDemo02 &#123; public static void main(String[] args) &#123; // 是一个完整的路径,从盘符开始 File file1 = new File(\"D:\\\\itheima\\\\a.txt\"); // 是一个简化的路径,从当前项目根目录开始 File file2 = new File(\"a.txt\"); File file3 = new File(\"模块名\\\\a.txt\"); &#125;&#125; 1.3File类创建功能【应用】 方法分类 方法名 说明 public boolean createNewFile() 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 public boolean mkdir() 创建由此抽象路径名命名的目录 public boolean mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录 示例代码 123456789101112131415161718192021222324public class FileDemo02 &#123; public static void main(String[] args) throws IOException &#123; //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1.createNewFile()); System.out.println(\"--------\"); //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE File f2 = new File(\"E:\\\\itcast\\\\JavaSE\"); System.out.println(f2.mkdir()); System.out.println(\"--------\"); //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML File f3 = new File(\"E:\\\\itcast\\\\JavaWEB\\\\HTML\");// System.out.println(f3.mkdir()); System.out.println(f3.mkdirs()); System.out.println(\"--------\"); //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt File f4 = new File(\"E:\\\\itcast\\\\javase.txt\");// System.out.println(f4.mkdir()); System.out.println(f4.createNewFile()); &#125;&#125; 1.4File类删除功能【应用】 方法分类 方法名 说明 public boolean delete() 删除由此抽象路径名表示的文件或目录 示例代码 123456789101112131415161718192021222324252627282930public class FileDemo03 &#123; public static void main(String[] args) throws IOException &#123;// File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); //需求1：在当前模块目录下创建java.txt文件 File f1 = new File(\"myFile\\\\java.txt\");// System.out.println(f1.createNewFile()); //需求2：删除当前模块目录下的java.txt文件 System.out.println(f1.delete()); System.out.println(\"--------\"); //需求3：在当前模块目录下创建itcast目录 File f2 = new File(\"myFile\\\\itcast\");// System.out.println(f2.mkdir()); //需求4：删除当前模块目录下的itcast目录 System.out.println(f2.delete()); System.out.println(\"--------\"); //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt File f3 = new File(\"myFile\\\\itcast\");// System.out.println(f3.mkdir()); File f4 = new File(\"myFile\\\\itcast\\\\java.txt\");// System.out.println(f4.createNewFile()); //需求6：删除当前模块下的目录itcast System.out.println(f4.delete()); System.out.println(f3.delete()); &#125;&#125; 1.5File类判断和获取功能【应用】 判断功能 方法名 说明 public boolean isDirectory() 测试此抽象路径名表示的File是否为目录 public boolean isFile() 测试此抽象路径名表示的File是否为文件 public boolean exists() 测试此抽象路径名表示的File是否存在 获取功能 方法名 说明 public String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串 public String getPath() 将此抽象路径名转换为路径名字符串 public String getName() 返回由此抽象路径名表示的文件或目录的名称 public File[] listFiles() 返回此抽象路径名表示的目录中的文件和目录的File对象数组 示例代码 1234567891011121314151617181920212223242526272829303132public class FileDemo04 &#123; public static void main(String[] args) &#123; //创建一个File对象 File f = new File(\"myFile\\\\java.txt\");// public boolean isDirectory()：测试此抽象路径名表示的File是否为目录// public boolean isFile()：测试此抽象路径名表示的File是否为文件// public boolean exists()：测试此抽象路径名表示的File是否存在 System.out.println(f.isDirectory()); System.out.println(f.isFile()); System.out.println(f.exists());// public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串// public String getPath()：将此抽象路径名转换为路径名字符串// public String getName()：返回由此抽象路径名表示的文件或目录的名称 System.out.println(f.getAbsolutePath()); System.out.println(f.getPath()); System.out.println(f.getName()); System.out.println(\"--------\");// public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组 File f2 = new File(\"E:\\\\itcast\"); File[] fileArray = f2.listFiles(); for(File file : fileArray) &#123;// System.out.println(file);// System.out.println(file.getName()); if(file.isFile()) &#123; System.out.println(file.getName()); &#125; &#125; &#125;&#125; 1.6File类练习一【应用】 案例需求 在当前模块下的aaa文件夹中创建一个a.txt文件 实现步骤 创建File对象,指向aaa文件夹 判断aaa文件夹是否存在,如果不存在则创建 创建File对象,指向aaa文件夹下的a.txt文件 创建这个文件 代码实现 1234567891011121314151617181920public class Test1 &#123; public static void main(String[] args) throws IOException &#123; //练习一：在当前模块下的aaa文件夹中创建一个a.txt文件 /* File file = new File(\"filemodule\\\\aaa\\\\a.txt\"); file.createNewFile();*/ //注意点:文件所在的文件夹必须要存在. //1.创建File对象,指向aaa文件夹 File file = new File(\"filemodule\\\\aaa\"); //2.判断aaa文件夹是否存在,如果不存在则创建 if(!file.exists())&#123; //如果文件夹不存在,就创建出来 file.mkdirs(); &#125; //3.创建File对象,指向aaa文件夹下的a.txt文件 File newFile = new File(file,\"a.txt\"); //4.创建这个文件 newFile.createNewFile(); &#125;&#125; 1.7File类练习二【应用】 案例需求 删除一个多级文件夹 实现步骤 定义一个方法,接收一个File对象 遍历这个File对象,获取它下边的每个文件和文件夹对象 判断当前遍历到的File对象是文件还是文件夹 如果是文件,直接删除 如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 代码实现 1234567891011121314151617181920212223242526272829303132333435public class Test2 &#123; public static void main(String[] args) &#123; //练习二：删除一个多级文件夹 //delete方法 //只能删除文件和空文件夹. //如果现在要删除一个有内容的文件夹? //先删掉这个文件夹里面所有的内容. //最后再删除这个文件夹 File src = new File(\"C:\\\\Users\\\\apple\\\\Desktop\\\\src\"); deleteDir(src); &#125; //1.定义一个方法,接收一个File对象 private static void deleteDir(File src) &#123; //先删掉这个文件夹里面所有的内容. //递归 方法在方法体中自己调用自己. //注意: 可以解决所有文件夹和递归相结合的题目 //2.遍历这个File对象,获取它下边的每个文件和文件夹对象 File[] files = src.listFiles(); //3.判断当前遍历到的File对象是文件还是文件夹 for (File file : files) &#123; //4.如果是文件,直接删除 if(file.isFile())&#123; file.delete(); &#125;else&#123; //5.如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 deleteDir(file);//参数一定要是src文件夹里面的文件夹File对象 &#125; &#125; //6.参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 src.delete(); &#125;&#125; 1.8File类练习三【应用】 案例需求 统计一个文件夹中每种文件的个数并打印 打印格式如下： txt:3个 doc:4个 jpg:6个 … 实现步骤 定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 遍历File对象,获取它下边的每一个文件和文件夹对象 判断当前File对象是文件还是文件夹 如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 没出现过,将这种类型文件的后缀名存入集合中,次数存1 出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Test3 &#123; public static void main(String[] args) &#123; //统计一个文件夹中,每种文件出现的次数. //统计 --- 定义一个变量用来统计. ---- 弊端:同时只能统计一种文件 //利用map集合进行数据统计,键 --- 文件后缀名 值 ---- 次数 File file = new File(\"filemodule\"); HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;(); getCount(hm, file); System.out.println(hm); &#125; //1.定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 private static void getCount(HashMap&lt;String, Integer&gt; hm, File file) &#123; //2.遍历File对象,获取它下边的每一个文件和文件夹对象 File[] files = file.listFiles(); for (File f : files) &#123; //3.判断当前File对象是文件还是文件夹 if(f.isFile())&#123; //如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 String fileName = f.getName(); String[] fileNameArr = fileName.split(\"\\\\.\"); if(fileNameArr.length == 2)&#123; String fileEndName = fileNameArr[1]; if(hm.containsKey(fileEndName))&#123; //出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 Integer count = hm.get(fileEndName); //这种文件又出现了一次. count++; //把已经出现的次数给覆盖掉. hm.put(fileEndName,count); &#125;else&#123; // 没出现过,将这种类型文件的后缀名存入集合中,次数存1 hm.put(fileEndName,1); &#125; &#125; &#125;else&#123; //如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象代码实现 getCount(hm,f); &#125; &#125; &#125; &#125; 2.字节流2.1 IO流概述和分类【理解】 IO流介绍 IO：输入/输出(Input/Output) 流：是一种抽象概念,是对数据传输的总称.也就是说数据在设备间的传输称为流,流的本质是数据传输 IO流就是用来处理设备间数据传输问题的.常见的应用: 文件复制; 文件上传; 文件下载 IO流的分类 按照数据的流向 输入流：读数据 输出流：写数据 按照数据类型来分 字节流 字节输入流 字节输出流 字符流 字符输入流 字符输出流 IO流的使用场景 如果操作的是纯文本文件,优先使用字符流 如果操作的是图片、视频、音频等二进制文件,优先使用字节流 如果不确定文件类型,优先使用字节流.字节流是万能的流 2.2字节流写数据【应用】 字节流抽象基类 InputStream：这个抽象类是表示字节输入流的所有类的超类 OutputStream：这个抽象类是表示字节输出流的所有类的超类 子类名特点：子类名称都是以其父类名作为子类名的后缀 字节输出流 FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 使用字节输出流写数据的步骤 创建字节输出流对象(调用系统功能创建了文件,创建字节输出流对象,让字节输出流对象指向文件) 调用字节输出流对象的写数据方法 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源) 示例代码 123456789101112131415161718192021public class FileOutputStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输出流对象 /* 注意点: 1.如果文件不存在,会帮我们创建 2.如果文件存在,会把文件清空 */ //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //void write(int b)：将指定的字节写入此文件输出流 fos.write(97);// fos.write(57);// fos.write(55); //最后都要释放资源 //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。 fos.close(); &#125;&#125; 2.3字节流写数据的三种方式【应用】 写数据的方法分类 方法名 说明 void write(int b) 将指定的字节写入此文件输出流 一次写一个字节数据 void write(byte[] b) 将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据 void write(byte[] b, int off, int len) 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一次写一个字节数组的部分数据 示例代码 12345678910111213141516171819202122232425262728public class FileOutputStreamDemo02 &#123; public static void main(String[] args) throws IOException &#123; //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件// FileOutputStream fos = new FileOutputStream(new File(\"myByteStream\\\\fos.txt\")); //void write(int b)：将指定的字节写入此文件输出流// fos.write(97);// fos.write(98);// fos.write(99);// fos.write(100);// fos.write(101);// void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流// byte[] bys = &#123;97, 98, 99, 100, 101&#125;; //byte[] getBytes()：返回字符串对应的字节数组 byte[] bys = \"abcde\".getBytes();// fos.write(bys); //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流// fos.write(bys,0,bys.length); fos.write(bys,1,3); //释放资源 fos.close(); &#125;&#125; 2.4字节流写数据的两个小问题【应用】 字节流写数据如何实现换行 windows:\\r\\n linux:\\n mac:\\r 字节流写数据如何实现追加写入 public FileOutputStream(String name,boolean append) 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头 示例代码 12345678910111213141516public class FileOutputStreamDemo03 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输出流对象// FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\",true); //写数据 for (int i = 0; i &lt; 10; i++) &#123; fos.write(\"hello\".getBytes()); fos.write(\"\\r\\n\".getBytes()); &#125; //释放资源 fos.close(); &#125;&#125; 2.5字节流写数据加异常处理【应用】 异常处理格式 try-catch-finally 1234567try&#123; 可能出现异常的代码;&#125;catch(异常类名 变量名)&#123; 异常的处理代码;&#125;finally&#123; 执行所有清除操作;&#125; finally特点 被finally控制的语句一定会执行，除非JVM退出 示例代码 1234567891011121314151617181920public class FileOutputStreamDemo04 &#123; public static void main(String[] args) &#123; //加入finally来实现释放资源 FileOutputStream fos = null; try &#123; fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); fos.write(\"hello\".getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 2.6字节流读数据(一次读一个字节数据)【应用】 字节输入流 FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream,该文件由文件系统中的路径名name命名 字节输入流读取数据的步骤 创建字节输入流对象 调用字节输入流对象的读数据方法 释放资源 示例代码 1234567891011121314151617181920public class FileInputStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输入流对象 //FileInputStream(String name) FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); int by; /* fis.read()：读数据 by=fis.read()：把读取到的数据赋值给by by != -1：判断读取到的数据是否是-1 */ while ((by=fis.read())!=-1) &#123; System.out.print((char)by); &#125; //释放资源 fis.close(); &#125;&#125; 2.7字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt” (文件可以是任意文件) 实现步骤 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地) 数据源： ​ E:\\itcast\\窗里窗外.txt — 读数据 — InputStream — FileInputStream 目的地： ​ myByteStream\\窗里窗外.txt — 写数据 — OutputStream — FileOutputStream 代码实现 123456789101112131415161718public class CopyTxtDemo &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\窗里窗外.txt\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\窗里窗外.txt\"); //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节) int by; while ((by=fis.read())!=-1) &#123; fos.write(by); &#125; //释放资源 fos.close(); fis.close(); &#125;&#125; 2.8字节流读数据(一次读一个字节数组数据)【应用】 一次读一个字节数组的方法 public int read(byte[] b)：从输入流读取最多b.length个字节的数据 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数 示例代码 12345678910111213141516public class FileInputStreamDemo02 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输入流对象 FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); byte[] bys = new byte[1024]; //1024及其整数倍 int len; //循环读取 while ((len=fis.read(bys))!=-1) &#123; System.out.print(new String(bys,0,len)); &#125; //释放资源 fis.close(); &#125;&#125; 2.9字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\mn.jpg”复制到模块目录下的“mn.jpg” (文件可以是任意文件去) 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) 释放资源 代码实现 12345678910111213141516171819public class CopyJpgDemo &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\mn.jpg\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\mn.jpg\"); //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) byte[] bys = new byte[1024]; int len; while ((len=fis.read(bys))!=-1) &#123; fos.write(bys,0,len); &#125; //释放资源 fos.close(); fis.close(); &#125;&#125; 3.字节缓冲流3.1字节缓冲流构造方法【应用】 字节缓冲流介绍 lBufferOutputStream：该类实现缓冲输出流.通过设置这样的输出流,应用程序可以向底层输出流写入字节,而不必为写入的每个字节导致底层系统的调用 lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组.当从流中读取或跳过字节时,内部缓冲区将根据需要从所包含的输入流中重新填充,一次很多字节 构造方法： 方法名 说明 BufferedOutputStream(OutputStream out) 创建字节缓冲输出流对象 BufferedInputStream(InputStream in) 创建字节缓冲输入流对象 示例代码 1234567891011121314151617181920212223242526272829303132public class BufferStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //字节缓冲输出流：BufferedOutputStream(OutputStream out) BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\bos.txt\")); //写数据 bos.write(\"hello\\r\\n\".getBytes()); bos.write(\"world\\r\\n\".getBytes()); //释放资源 bos.close(); //字节缓冲输入流：BufferedInputStream(InputStream in) BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"myByteStream\\\\bos.txt\")); //一次读取一个字节数据// int by;// while ((by=bis.read())!=-1) &#123;// System.out.print((char)by);// &#125; //一次读取一个字节数组数据 byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) &#123; System.out.print(new String(bys,0,len)); &#125; //释放资源 bis.close(); &#125;&#125; 3.2字节缓冲流复制视频【应用】 案例需求 把“E:\\itcast\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi” 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制视频 释放资源 代码实现 123456789101112131415161718192021222324252627282930313233343536373839public class CopyAviDemo &#123; public static void main(String[] args) throws IOException &#123; //复制视频// method1(); method2(); &#125; //字节缓冲流一次读写一个字节数组 public static void method2() throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) &#123; bos.write(bys,0,len); &#125; bos.close(); bis.close(); &#125; //字节缓冲流一次读写一个字节 public static void method1() throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); int by; while ((by=bis.read())!=-1) &#123; bos.write(by); &#125; bos.close(); bis.close(); &#125;&#125;","categories":[],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://xiaojujing.com/tags/IO%E6%B5%81/"}]},{"title":"20_集合04","slug":"33_集合04","date":"2020-11-10T09:01:27.000Z","updated":"2020-11-10T09:02:44.817Z","comments":true,"path":"2020/11/10/33_集合04/","link":"","permalink":"http://xiaojujing.com/2020/11/10/33_%E9%9B%86%E5%90%8804/","excerpt":"1.可变参数1.1可变参数【应用】 可变参数介绍 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了","text":"1.可变参数1.1可变参数【应用】 可变参数介绍 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了 方法的参数类型已经确定,个数不确定,我们可以使用可变参数 可变参数定义格式 1修饰符 返回值类型 方法名(数据类型… 变量名) &#123; &#125; 可变参数的注意事项 这里的变量其实是一个数组 如果一个方法有多个参数，包含可变参数，可变参数要放在最后 可变参数的基本使用 123456789101112131415161718192021222324public class ArgsDemo01 &#123; public static void main(String[] args) &#123; System.out.println(sum(10, 20)); System.out.println(sum(10, 20, 30)); System.out.println(sum(10, 20, 30, 40)); System.out.println(sum(10,20,30,40,50)); System.out.println(sum(10,20,30,40,50,60)); System.out.println(sum(10,20,30,40,50,60,70)); System.out.println(sum(10,20,30,40,50,60,70,80,90,100)); &#125;// public static int sum(int b,int... a) &#123;// return 0;// &#125; public static int sum(int... a) &#123; int sum = 0; for(int i : a) &#123; sum += i; &#125; return sum; &#125;&#125; 1.2创建不可变集合【理解】 方法介绍 在List、Set、Map接口中,都存在of方法,可以创建一个不可变的集合 这个集合不能添加,不能删除,不能修改 但是可以结合集合的带参构造,实现集合的批量添加 在Map接口中,还有一个ofEntries方法可以提高代码的阅读性 首先会把键值对封装成一个Entry对象,再把这个Entry对象添加到集合当中 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyVariableParameter4 &#123; public static void main(String[] args) &#123; // static &lt;E&gt; List&lt;E&gt; of(E…elements) 创建一个具有指定元素的List集合对象 //static &lt;E&gt; Set&lt;E&gt; of(E…elements) 创建一个具有指定元素的Set集合对象 //static &lt;K , V&gt; Map&lt;K，V&gt; of(E…elements) 创建一个具有指定元素的Map集合对象 //method1(); //method2(); //method3(); //method4(); &#125; private static void method4() &#123; Map&lt;String, String&gt; map = Map.ofEntries( Map.entry(\"zhangsan\", \"江苏\"), Map.entry(\"lisi\", \"北京\")); System.out.println(map); &#125; private static void method3() &#123; Map&lt;String, String&gt; map = Map.of(\"zhangsan\", \"江苏\", \"lisi\", \"北京\", \"wangwu\", \"天津\"); System.out.println(map); &#125; private static void method2() &#123; //传递的参数当中，不能存在重复的元素。 Set&lt;String&gt; set = Set.of(\"a\", \"b\", \"c\", \"d\",\"a\"); System.out.println(set); &#125; private static void method1() &#123; List&lt;String&gt; list = List.of(\"a\", \"b\", \"c\", \"d\"); System.out.println(list); //list.add(\"Q\"); //list.remove(\"a\"); //list.set(0,\"A\"); //System.out.println(list);// ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();// list2.add(\"aaa\");// list2.add(\"aaa\");// list2.add(\"aaa\");// list2.add(\"aaa\"); //集合的批量添加。 //首先是通过调用List.of方法来创建一个不可变的集合，of方法的形参就是一个可变参数。 //再创建一个ArrayList集合，并把这个不可变的集合中所有的数据，都添加到ArrayList中。 ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(List.of(\"a\", \"b\", \"c\", \"d\")); System.out.println(list3); &#125;&#125; 2.Stream流2.1体验Stream流【理解】 案例需求 按照下面的要求完成集合的创建和遍历 创建一个集合，存储多个字符串元素 把集合中所有以”张”开头的元素存储到一个新的集合 把”张”开头的集合中的长度为3的元素存储到一个新的集合 遍历上一步得到的集合 原始方式示例代码 12345678910111213141516171819202122232425public class MyStream1 &#123; public static void main(String[] args) &#123; //集合的批量添加 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\")); //list.add() //遍历list1把以张开头的元素添加到list2中。 ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); for (String s : list1) &#123; if(s.startsWith(\"张\"))&#123; list2.add(s); &#125; &#125; //遍历list2集合，把其中长度为3的元素，再添加到list3中。 ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(); for (String s : list2) &#123; if(s.length() == 3)&#123; list3.add(s); &#125; &#125; for (String s : list3) &#123; System.out.println(s); &#125; &#125;&#125; 使用Stream流示例代码 1234567891011public class StreamDemo &#123; public static void main(String[] args) &#123; //集合的批量添加 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\")); //Stream流 list1.stream().filter(s-&gt;s.startsWith(\"张\")) .filter(s-&gt;s.length() == 3) .forEach(s-&gt; System.out.println(s)); &#125;&#125; Stream流的好处 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印 Stream流把真正的函数式编程风格引入到Java中 代码简洁 2.2Stream流的常见生成方式【应用】 Stream流的思想 Stream流的三类方法 获取Stream流 创建一条流水线,并把数据放到流水线上准备进行操作 中间方法 流水线上的操作 一次操作完毕之后,还可以继续进行其他操作 终结方法 一个Stream流只能有一个终结方法 是流水线上的最后一个操作 生成Stream流的方式 Collection体系集合 使用默认方法stream()生成流， default Stream stream() Map体系集合 把Map转成Set集合，间接的生成流 数组 通过Arrays中的静态方法stream生成流 同种数据类型的多个数据 通过Stream接口的静态方法of(T… values)生成流 代码演示 123456789101112131415161718192021222324public class StreamDemo &#123; public static void main(String[] args) &#123; //Collection体系的集合可以使用默认方法stream()生成流 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Stream&lt;String&gt; listStream = list.stream(); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); Stream&lt;String&gt; setStream = set.stream(); //Map体系的集合间接的生成流 Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;Integer&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream(); //数组可以通过Arrays中的静态方法stream生成流 String[] strArray = &#123;\"hello\",\"world\",\"java\"&#125;; Stream&lt;String&gt; strArrayStream = Arrays.stream(strArray); //同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流 Stream&lt;String&gt; strArrayStream2 = Stream.of(\"hello\", \"world\", \"java\"); Stream&lt;Integer&gt; intStream = Stream.of(10, 20, 30); &#125;&#125; 2.3Stream流中间操作方法【应用】 概念 中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作 常见方法 方法名 说明 Stream filter(Predicate predicate) 用于对流中的数据进行过滤 Stream limit(long maxSize) 返回此流中的元素组成的流，截取前指定参数个数的数据 Stream skip(long n) 跳过指定参数个数的数据，返回由该流的剩余元素组成的流 static Stream concat(Stream a, Stream b) 合并a和b两个流为一个流 Stream distinct() 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 filter代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyStream3 &#123; public static void main(String[] args) &#123;// Stream&lt;T&gt; filter(Predicate predicate)：过滤// Predicate接口中的方法 boolean test(T t)：对给定的参数进行判断，返回一个布尔值 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张三丰\"); list.add(\"张无忌\"); list.add(\"张翠山\"); list.add(\"王二麻子\"); list.add(\"张良\"); list.add(\"谢广坤\"); //filter方法获取流中的 每一个数据. //而test方法中的s,就依次表示流中的每一个数据. //我们只要在test方法中对s进行判断就可以了. //如果判断的结果为true,则当前的数据留下 //如果判断的结果为false,则当前数据就不要.// list.stream().filter(// new Predicate&lt;String&gt;() &#123;// @Override// public boolean test(String s) &#123;// boolean result = s.startsWith(\"张\");// return result;// &#125;// &#125;// ).forEach(s-&gt; System.out.println(s)); //因为Predicate接口中只有一个抽象方法test //所以我们可以使用lambda表达式来简化// list.stream().filter(// (String s)-&gt;&#123;// boolean result = s.startsWith(\"张\");// return result;// &#125;// ).forEach(s-&gt; System.out.println(s)); list.stream().filter(s -&gt;s.startsWith(\"张\")).forEach(s-&gt; System.out.println(s)); &#125;&#125; limit&amp;skip代码演示 123456789101112131415161718192021222324public class StreamDemo02 &#123; public static void main(String[] args) &#123; //创建一个集合，存储多个字符串元素 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：取前3个数据在控制台输出 list.stream().limit(3).forEach(s-&gt; System.out.println(s)); System.out.println(\"--------\"); //需求2：跳过3个元素，把剩下的元素在控制台输出 list.stream().skip(3).forEach(s-&gt; System.out.println(s)); System.out.println(\"--------\"); //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出 list.stream().skip(2).limit(2).forEach(s-&gt; System.out.println(s)); &#125;&#125; concat&amp;distinct代码演示 12345678910111213141516171819202122232425public class StreamDemo03 &#123; public static void main(String[] args) &#123; //创建一个集合，存储多个字符串元素 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：取前4个数据组成一个流 Stream&lt;String&gt; s1 = list.stream().limit(4); //需求2：跳过2个数据组成一个流 Stream&lt;String&gt; s2 = list.stream().skip(2); //需求3：合并需求1和需求2得到的流，并把结果在控制台输出// Stream.concat(s1,s2).forEach(s-&gt; System.out.println(s)); //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复 Stream.concat(s1,s2).distinct().forEach(s-&gt; System.out.println(s)); &#125;&#125; 2.4Stream流终结操作方法【应用】 概念 终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作 常见方法 方法名 说明 void forEach(Consumer action) 对此流的每个元素执行操作 long count() 返回此流中的元素数 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyStream5 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张三丰\"); list.add(\"张无忌\"); list.add(\"张翠山\"); list.add(\"王二麻子\"); list.add(\"张良\"); list.add(\"谢广坤\"); //method1(list); // long count()：返回此流中的元素数 long count = list.stream().count(); System.out.println(count); &#125; private static void method1(ArrayList&lt;String&gt; list) &#123; // void forEach(Consumer action)：对此流的每个元素执行操作 // Consumer接口中的方法void accept(T t)：对给定的参数执行此操作 //在forEach方法的底层,会循环获取到流中的每一个数据. //并循环调用accept方法,并把每一个数据传递给accept方法 //s就依次表示了流中的每一个数据. //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了. list.stream().forEach( new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125; ); System.out.println(\"====================\"); //lambda表达式的简化格式 //是因为Consumer接口中,只有一个accept方法 list.stream().forEach( (String s)-&gt;&#123; System.out.println(s); &#125; ); System.out.println(\"====================\"); //lambda表达式还是可以进一步简化的. list.stream().forEach(s-&gt;System.out.println(s)); &#125;&#125; 2.5Stream流的收集操作【应用】 概念 对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中 常用方法 方法名 说明 R collect(Collector collector) 把结果收集到集合中 工具类Collectors提供了具体的收集方式 方法名 说明 public static Collector toList() 把元素收集到List集合中 public static Collector toSet() 把元素收集到Set集合中 public static Collector toMap(Function keyMapper,Function valueMapper) 把元素收集到Map集合中 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// toList和toSet方法演示 public class MyStream7 &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; list1.add(i); &#125; list1.add(10); list1.add(10); list1.add(10); list1.add(10); list1.add(10); //filter负责过滤数据的. //collect负责收集数据. //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中. //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中. List&lt;Integer&gt; list = list1.stream().filter(number -&gt; number % 2 == 0) .collect(Collectors.toList()); System.out.println(list); Set&lt;Integer&gt; set = list1.stream().filter(number -&gt; number % 2 == 0) .collect(Collectors.toSet()); System.out.println(set);&#125;&#125;/**Stream流的收集方法 toMap方法演示创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄\"zhangsan,23\"\"lisi,24\"\"wangwu,25\"保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值*/public class MyStream8 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"zhangsan,23\"); list.add(\"lisi,24\"); list.add(\"wangwu,25\"); Map&lt;String, Integer&gt; map = list.stream().filter( s -&gt; &#123; String[] split = s.split(\",\"); int age = Integer.parseInt(split[1]); return age &gt;= 24; &#125; // collect方法只能获取到流中剩余的每一个数据. //在底层不能创建容器,也不能把数据添加到容器当中 //Collectors.toMap 创建一个map集合并将数据添加到集合当中 // s 依次表示流中的每一个数据 //第一个lambda表达式就是如何获取到Map中的键 //第二个lambda表达式就是如何获取Map中的值 ).collect(Collectors.toMap( s -&gt; s.split(\",\")[0], s -&gt; Integer.parseInt(s.split(\",\")[1]) )); System.out.println(map); &#125;&#125; 5.6Stream流综合练习【应用】 案例需求 现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作 男演员只要名字为3个字的前三人 女演员只要姓林的，并且不要第一个 把过滤后的男演员姓名和女演员姓名合并到一起 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据 演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法 代码实现 演员类 123456789101112131415public class Actor &#123; private String name; public Actor(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435public class StreamTest &#123; public static void main(String[] args) &#123; //创建集合 ArrayList&lt;String&gt; manList = new ArrayList&lt;String&gt;(); manList.add(\"周润发\"); manList.add(\"成龙\"); manList.add(\"刘德华\"); manList.add(\"吴京\"); manList.add(\"周星驰\"); manList.add(\"李连杰\"); ArrayList&lt;String&gt; womanList = new ArrayList&lt;String&gt;(); womanList.add(\"林心如\"); womanList.add(\"张曼玉\"); womanList.add(\"林青霞\"); womanList.add(\"柳岩\"); womanList.add(\"林志玲\"); womanList.add(\"王祖贤\"); //男演员只要名字为3个字的前三人 Stream&lt;String&gt; manStream = manList.stream().filter(s -&gt; s.length() == 3).limit(3); //女演员只要姓林的，并且不要第一个 Stream&lt;String&gt; womanStream = womanList.stream().filter(s -&gt; s.startsWith(\"林\")).skip(1); //把过滤后的男演员姓名和女演员姓名合并到一起 Stream&lt;String&gt; stream = Stream.concat(manStream, womanStream); // 将流中的数据封装成Actor对象之后打印 stream.forEach(name -&gt; &#123; Actor actor = new Actor(name); System.out.println(actor); &#125;); &#125;&#125;","categories":[],"tags":[]},{"title":"19_集合03","slug":"32_集合03","date":"2020-11-10T09:01:15.000Z","updated":"2020-11-10T09:02:56.560Z","comments":true,"path":"2020/11/10/32_集合03/","link":"","permalink":"http://xiaojujing.com/2020/11/10/32_%E9%9B%86%E5%90%8803/","excerpt":"1.红黑树1.1概述【理解】 红黑树的特点 平衡二叉B树 每一个节点可以是红或者黑","text":"1.红黑树1.1概述【理解】 红黑树的特点 平衡二叉B树 每一个节点可以是红或者黑 红黑树不是高度平衡的,它的平衡是通过”自己的红黑规则”进行实现的 红黑树的红黑规则有哪些 每一个节点或是红色的,或者是黑色的 根节点必须是黑色 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况) 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点 红黑树添加节点的默认颜色 添加节点时,默认为红色,效率高 红黑树添加节点后如何保持红黑规则 根节点位置 直接变为黑色 非根节点位置 父节点为黑色 不需要任何操作,默认红色即可 父节点为红色 叔叔节点为红色 将”父节点”设为黑色,将”叔叔节点”设为黑色 将”祖父节点”设为红色 如果”祖父节点”为根节点,则将根节点再次变成黑色 叔叔节点为黑色 将”父节点”设为黑色 将”祖父节点”设为红色 以”祖父节点”为支点进行旋转 1.2成绩排序案例【应用】 案例需求 用TreeSet集合存储多个学生信息(姓名,语文成绩,数学成绩,英语成绩),并遍历该集合 要求: 按照总分从高到低出现 代码实现 学生类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Student implements Comparable&lt;Student&gt; &#123; private String name; private int chinese; private int math; private int english; public Student() &#123; &#125; public Student(String name, int chinese, int math, int english) &#123; this.name = name; this.chinese = chinese; this.math = math; this.english = english; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getChinese() &#123; return chinese; &#125; public void setChinese(int chinese) &#123; this.chinese = chinese; &#125; public int getMath() &#123; return math; &#125; public void setMath(int math) &#123; this.math = math; &#125; public int getEnglish() &#123; return english; &#125; public void setEnglish(int english) &#123; this.english = english; &#125; public int getSum() &#123; return this.chinese + this.math + this.english; &#125; @Override public int compareTo(Student o) &#123; // 主要条件: 按照总分进行排序 int result = o.getSum() - this.getSum(); // 次要条件: 如果总分一样,就按照语文成绩排序 result = result == 0 ? o.getChinese() - this.getChinese() : result; // 如果语文成绩也一样,就按照数学成绩排序 result = result == 0 ? o.getMath() - this.getMath() : result; // 如果总分一样,各科成绩也都一样,就按照姓名排序 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; &#125;&#125; 测试类 12345678910111213141516171819public class TreeSetDemo &#123; public static void main(String[] args) &#123; //创建TreeSet集合对象，通过比较器排序进行排序 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(); //创建学生对象 Student s1 = new Student(\"jack\", 98, 100, 95); Student s2 = new Student(\"rose\", 95, 95, 95); Student s3 = new Student(\"sam\", 100, 93, 98); //把学生对象添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); //遍历集合 for (Student s : ts) &#123; System.out.println(s.getName() + \",\" + s.getChinese() + \",\" + s.getMath() + \",\" + s.getEnglish() + \",\" + s.getSum()); &#125; &#125;&#125; 2.HashSet集合2.1HashSet集合概述和特点【应用】 底层数据结构是哈希表 存取无序 不可以存储重复元素 没有索引,不能使用普通for循环遍历 2.2HashSet集合的基本应用【应用】存储字符串并遍历 123456789101112131415161718public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建集合对象 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(\"hello\"); set.add(\"world\"); set.add(\"java\"); //不包含重复元素的集合 set.add(\"world\"); //遍历 for(String s : set) &#123; System.out.println(s); &#125; &#125;&#125; 2.3哈希值【理解】 哈希值简介 ​ 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值 如何获取哈希值 ​ Object类中的public int hashCode()：返回对象的哈希码值 哈希值的特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同 2.4哈希表结构【理解】 JDK1.8以前 ​ 数组 + 链表 JDK1.8以后 节点个数少于等于8个 ​ 数组 + 链表 节点个数多于8个 ​ 数组 + 红黑树 2.5HashSet集合存储学生对象并遍历【应用】 案例需求 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合 要求：学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125;&#125; 测试类 123456789101112131415161718192021222324public class HashSetDemo02 &#123; public static void main(String[] args) &#123; //创建HashSet集合对象 HashSet&lt;Student&gt; hs = new HashSet&lt;Student&gt;(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"张曼玉\", 35); Student s3 = new Student(\"王祖贤\", 33); Student s4 = new Student(\"王祖贤\", 33); //把学生添加到集合 hs.add(s1); hs.add(s2); hs.add(s3); hs.add(s4); //遍历集合(增强for) for (Student s : hs) &#123; System.out.println(s.getName() + \",\" + s.getAge()); &#125; &#125;&#125; 总结 ​ HashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法 3.Map集合3.1Map集合概述和特点【理解】 Map集合概述 1interface Map&lt;K,V&gt; K：键的类型；V：值的类型 Map集合的特点 双列集合,一个键对应一个值 键不可以重复,值可以重复 Map集合的基本使用 123456789101112131415public class MapDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //V put(K key, V value) 将指定的值与该映射中的指定键相关联 map.put(\"itheima001\",\"林青霞\"); map.put(\"itheima002\",\"张曼玉\"); map.put(\"itheima003\",\"王祖贤\"); map.put(\"itheima003\",\"柳岩\"); //输出集合对象 System.out.println(map); &#125;&#125; 3.2Map集合的基本功能【应用】 方法介绍 方法名 说明 V put(K key,V value) 添加元素 V remove(Object key) 根据键删除键值对元素 void clear() 移除所有的键值对元素 boolean containsKey(Object key) 判断集合是否包含指定的键 boolean containsValue(Object value) 判断集合是否包含指定的值 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中键值对的个数 示例代码 12345678910111213141516171819202122232425262728293031public class MapDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //V put(K key,V value)：添加元素 map.put(\"张无忌\",\"赵敏\"); map.put(\"郭靖\",\"黄蓉\"); map.put(\"杨过\",\"小龙女\"); //V remove(Object key)：根据键删除键值对元素// System.out.println(map.remove(\"郭靖\"));// System.out.println(map.remove(\"郭襄\")); //void clear()：移除所有的键值对元素// map.clear(); //boolean containsKey(Object key)：判断集合是否包含指定的键// System.out.println(map.containsKey(\"郭靖\"));// System.out.println(map.containsKey(\"郭襄\")); //boolean isEmpty()：判断集合是否为空// System.out.println(map.isEmpty()); //int size()：集合的长度，也就是集合中键值对的个数 System.out.println(map.size()); //输出集合对象 System.out.println(map); &#125;&#125; 3.3Map集合的获取功能【应用】 方法介绍 方法名 说明 V get(Object key) 根据键获取值 Set keySet() 获取所有键的集合 Collection values() 获取所有值的集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 获取所有键值对对象的集合 示例代码 123456789101112131415161718192021222324252627public class MapDemo03 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //V get(Object key):根据键获取值// System.out.println(map.get(\"张无忌\"));// System.out.println(map.get(\"张三丰\")); //Set&lt;K&gt; keySet():获取所有键的集合// Set&lt;String&gt; keySet = map.keySet();// for(String key : keySet) &#123;// System.out.println(key);// &#125; //Collection&lt;V&gt; values():获取所有值的集合 Collection&lt;String&gt; values = map.values(); for(String value : values) &#123; System.out.println(value); &#125; &#125;&#125; 3.4Map集合的遍历(方式1)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 把所有的丈夫给集中起来 遍历丈夫的集合，获取到每一个丈夫 根据丈夫去找对应的妻子 步骤分析 获取所有键的集合。用keySet()方法实现 遍历键的集合，获取到每一个键。用增强for实现 根据键去找值。用get(Object key)方法实现 代码实现 1234567891011121314151617181920public class MapDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //获取所有键的集合。用keySet()方法实现 Set&lt;String&gt; keySet = map.keySet(); //遍历键的集合，获取到每一个键。用增强for实现 for (String key : keySet) &#123; //根据键去找值。用get(Object key)方法实现 String value = map.get(key); System.out.println(key + \",\" + value); &#125; &#125;&#125; 3.5Map集合的遍历(方式2)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 获取所有结婚证的集合 遍历结婚证的集合，得到每一个结婚证 根据结婚证获取丈夫和妻子 步骤分析 获取所有键值对对象的集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取所有键值对对象的集合 遍历键值对对象的集合，得到每一个键值对对象 用增强for实现，得到每一个Map.Entry 根据键值对对象获取键和值 用getKey()得到键 用getValue()得到值 代码实现 123456789101112131415161718192021public class MapDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //获取所有键值对对象的集合 Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); //遍历键值对对象的集合，得到每一个键值对对象 for (Map.Entry&lt;String, String&gt; me : entrySet) &#123; //根据键值对对象获取键和值 String key = me.getKey(); String value = me.getValue(); System.out.println(key + \",\" + value); &#125; &#125;&#125; 4.HashMap集合4.1HashMap集合概述和特点【理解】 HashMap底层是哈希表结构的 依赖hashCode方法和equals方法保证键的唯一 如果键要存储的是自定义对象，需要重写hashCode和equals方法 4.2HashMap集合应用案例【应用】 案例需求 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125;&#125; 测试类 12345678910111213141516171819202122232425public class HashMapDemo &#123; public static void main(String[] args) &#123; //创建HashMap集合对象 HashMap&lt;Student, String&gt; hm = new HashMap&lt;Student, String&gt;(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"张曼玉\", 35); Student s3 = new Student(\"王祖贤\", 33); Student s4 = new Student(\"王祖贤\", 33); //把学生添加到集合 hm.put(s1, \"西安\"); hm.put(s2, \"武汉\"); hm.put(s3, \"郑州\"); hm.put(s4, \"北京\"); //遍历集合 Set&lt;Student&gt; keySet = hm.keySet(); for (Student key : keySet) &#123; String value = hm.get(key); System.out.println(key.getName() + \",\" + key.getAge() + \",\" + value); &#125; &#125;&#125; 5.TreeMap集合5.1TreeMap集合概述和特点【理解】 TreeMap底层是红黑树结构 依赖自然排序或者比较器排序,对键进行排序 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则 5.2TreeMap集合应用案例【应用】 案例需求 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序 代码实现 学生类 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; @Override public int compareTo(Student o) &#123; //按照年龄进行排序 int result = o.getAge() - this.getAge(); //次要条件，按照姓名排序。 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; &#125;&#125; 测试类 1234567891011121314151617181920212223public class Test1 &#123; public static void main(String[] args) &#123; // 创建TreeMap集合对象 TreeMap&lt;Student,String&gt; tm = new TreeMap&lt;&gt;(); // 创建学生对象 Student s1 = new Student(\"xiaohei\",23); Student s2 = new Student(\"dapang\",22); Student s3 = new Student(\"xiaomei\",22); // 将学生对象添加到TreeMap集合中 tm.put(s1,\"江苏\"); tm.put(s2,\"北京\"); tm.put(s3,\"天津\"); // 遍历TreeMap集合,打印每个学生的信息 tm.forEach( (Student key, String value)-&gt;&#123; System.out.println(key + \"---\" + value); &#125; ); &#125;&#125;","categories":[],"tags":[]},{"title":"18_集合02","slug":"31_集合02","date":"2020-11-09T15:40:41.000Z","updated":"2020-11-09T15:41:50.074Z","comments":true,"path":"2020/11/09/31_集合02/","link":"","permalink":"http://xiaojujing.com/2020/11/09/31_%E9%9B%86%E5%90%8802/","excerpt":"1.泛型1.1泛型概述【理解】 泛型的介绍 ​ 泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制 泛型的好处","text":"1.泛型1.1泛型概述【理解】 泛型的介绍 ​ 泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制 泛型的好处 把运行时期的问题提前到了编译期间 避免了强制类型转换 泛型的定义格式 &lt;类型&gt;: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: &lt;类型1,类型2…&gt;: 指定多种类型的格式,多种类型之间用逗号隔开.例如: &lt;E,T&gt; &lt;K,V&gt; 1.2泛型类【应用】 定义格式 1修饰符 class 类名&lt;类型&gt; &#123; &#125; 示例代码 泛型类 1234567891011public class Generic&lt;T&gt; &#123; private T t; public T getT() &#123; return t; &#125; public void setT(T t) &#123; this.t = t; &#125;&#125; 测试类 123456789101112131415public class GenericDemo1 &#123; public static void main(String[] args) &#123; Generic&lt;String&gt; g1 = new Generic&lt;String&gt;(); g1.setT(\"杨幂\"); System.out.println(g1.getT()); Generic&lt;Integer&gt; g2 = new Generic&lt;Integer&gt;(); g2.setT(30); System.out.println(g2.getT()); Generic&lt;Boolean&gt; g3 = new Generic&lt;Boolean&gt;(); g3.setT(true); System.out.println(g3.getT()); &#125;&#125; 1.3泛型方法【应用】 定义格式 1修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名) &#123; &#125; 示例代码 带有泛型方法的类 12345public class Generic &#123; public &lt;T&gt; void show(T t) &#123; System.out.println(t); &#125;&#125; 测试类 123456789public class GenericDemo2 &#123; public static void main(String[] args) &#123; Generic g = new Generic(); g.show(\"柳岩\"); g.show(30); g.show(true); g.show(12.34); &#125;&#125; 1.4泛型接口【应用】 定义格式 1修饰符 interface 接口名&lt;类型&gt; &#123; &#125; 示例代码 泛型接口 123public interface Generic&lt;T&gt; &#123; void show(T t);&#125; 泛型接口实现类1 ​ 定义实现类时,定义和接口相同泛型,创建实现类对象时明确泛型的具体类型 123456public class GenericImpl1&lt;T&gt; implements Generic&lt;T&gt; &#123; @Override public void show(T t) &#123; System.out.println(t); &#125;&#125; 泛型接口实现类2 ​ 定义实现类时,直接明确泛型的具体类型 123456public class GenericImpl2 implements Generic&lt;Integer&gt;&#123; @Override public void show(Integer t) &#123; System.out.println(t); &#125;&#125; 测试类 1234567891011public class GenericDemo3 &#123; public static void main(String[] args) &#123; GenericImpl1&lt;String&gt; g1 = new GenericImpl&lt;String&gt;(); g1.show(\"林青霞\"); GenericImpl1&lt;Integer&gt; g2 = new GenericImpl&lt;Integer&gt;(); g2.show(30); GenericImpl2 g3 = new GenericImpl2(); g3.show(10); &#125;&#125; 1.5类型通配符 类型通配符: &lt;?&gt; ArrayList&lt;?&gt;: 表示元素类型未知的ArrayList,它的元素可以匹配任何的类型 但是并不能把元素添加到ArrayList中了,获取出来的也是父类类型 类型通配符上限: &lt;? extends 类型&gt; ArrayListList &lt;? extends Number&gt;: 它表示的类型是Number或者其子类型 类型通配符下限: &lt;? super 类型&gt; ArrayListList &lt;? super Number&gt;: 它表示的类型是Number或者其父类型 泛型通配符的使用 12345678910111213141516171819202122232425262728293031public class GenericDemo4 &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); ArrayList&lt;Number&gt; list3 = new ArrayList&lt;&gt;(); ArrayList&lt;Object&gt; list4 = new ArrayList&lt;&gt;(); method(list1); method(list2); method(list3); method(list4); getElement1(list1); getElement1(list2);//报错 getElement1(list3); getElement1(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125; // 泛型通配符: 此时的泛型?,可以是任意类型 public static void method(ArrayList&lt;?&gt; list)&#123;&#125; // 泛型的上限: 此时的泛型?,必须是Number类型或者Number类型的子类 public static void getElement1(ArrayList&lt;? extends Number&gt; list)&#123;&#125; // 泛型的下限: 此时的泛型?,必须是Number类型或者Number类型的父类 public static void getElement2(ArrayList&lt;? super Number&gt; list)&#123;&#125;&#125; 2.Set集合2.1Set集合概述和特点【应用】 不可以存储重复元素 没有索引,不能使用普通for循环遍历 2.2Set集合的使用【应用】存储字符串并遍历 1234567891011121314151617181920212223242526public class MySet1 &#123; public static void main(String[] args) &#123; //创建集合对象 Set&lt;String&gt; set = new TreeSet&lt;&gt;(); //添加元素 set.add(\"ccc\"); set.add(\"aaa\"); set.add(\"aaa\"); set.add(\"bbb\");// for (int i = 0; i &lt; set.size(); i++) &#123;// //Set集合是没有索引的，所以不能使用通过索引获取元素的方法// &#125; //遍历集合 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; System.out.println(\"-----------------------------------\"); for (String s : set) &#123; System.out.println(s); &#125; &#125;&#125; 3.TreeSet集合3.1TreeSet集合概述和特点【应用】 不可以存储重复元素 没有索引 可以将元素按照规则进行排序 TreeSet()：根据其元素的自然排序进行排序 TreeSet(Comparator comparator) ：根据指定的比较器进行排序 3.2TreeSet集合基本使用【应用】存储Integer类型的整数并遍历 1234567891011121314151617181920public class TreeSetDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Integer&gt; ts = new TreeSet&lt;Integer&gt;(); //添加元素 ts.add(10); ts.add(40); ts.add(30); ts.add(50); ts.add(20); ts.add(30); //遍历集合 for(Integer i : ts) &#123; System.out.println(i); &#125; &#125;&#125; 3.3自然排序Comparable的使用【应用】 案例需求 存储学生对象并遍历，创建TreeSet集合使用无参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 使用空参构造创建TreeSet集合 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的 自定义的Student类实现Comparable接口 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法 重写接口中的compareTo方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; @Override public int compareTo(Student o) &#123; //按照对象的年龄进行排序 //主要判断条件: 按照年龄从小到大排序 int result = this.age - o.age; //次要判断条件: 年龄相同时，按照姓名的字母顺序排序 result = result == 0 ? this.name.compareTo(o.getName()) : result; return result; &#125;&#125; 测试类 12345678910111213141516171819202122public class MyTreeSet2 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(); //创建学生对象 Student s1 = new Student(\"zhangsan\",28); Student s2 = new Student(\"lisi\",27); Student s3 = new Student(\"wangwu\",29); Student s4 = new Student(\"zhaoliu\",28); Student s5 = new Student(\"qianqi\",30); //把学生添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); //遍历集合 for (Student student : ts) &#123; System.out.println(student); &#125; &#125;&#125; 3.4比较器排序Comparator的使用【应用】 案例需求 存储老师对象并遍历，创建TreeSet集合使用带参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 老师类 123456789101112131415161718192021222324252627282930313233343536public class Teacher &#123; private String name; private int age; public Teacher() &#123; &#125; public Teacher(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Teacher&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132public class MyTreeSet4 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Teacher&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Teacher&gt;() &#123; @Override public int compare(Teacher o1, Teacher o2) &#123; //o1表示现在要存入的那个元素 //o2表示已经存入到集合中的元素 //主要条件 int result = o1.getAge() - o2.getAge(); //次要条件 result = result == 0 ? o1.getName().compareTo(o2.getName()) : result; return result; &#125; &#125;); //创建老师对象 Teacher t1 = new Teacher(\"zhangsan\",23); Teacher t2 = new Teacher(\"lisi\",22); Teacher t3 = new Teacher(\"wangwu\",24); Teacher t4 = new Teacher(\"zhaoliu\",24); //把老师添加到集合 ts.add(t1); ts.add(t2); ts.add(t3); ts.add(t4); //遍历集合 for (Teacher teacher : ts) &#123; System.out.println(teacher); &#125; &#125;&#125; 3.5两种比较方式总结【理解】 两种比较方式小结 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序 两种方式中关于返回值的规则 如果返回值为负数，表示当前存入的元素是较小值，存左边 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存 如果返回值为正数，表示当前存入的元素是较大值，存右边 4.数据结构4.1二叉树【理解】 二叉树的特点 二叉树中,任意一个节点的度要小于等于2 节点: 在树结构中,每一个元素称之为节点 度: 每一个节点的子节点数量称之为度 二叉树结构图 4.2二叉查找树【理解】 二叉查找树的特点 二叉查找树,又称二叉排序树或者二叉搜索树 每一个节点上最多有两个子节点 左子树上所有节点的值都小于根节点的值 右子树上所有节点的值都大于根节点的值 二叉查找树结构图 二叉查找树和二叉树对比结构图 二叉查找树添加节点规则 小的存左边 大的存右边 一样的不存 4.3平衡二叉树【理解】 平衡二叉树的特点 二叉树左右两个子树的高度差不超过1 任意节点的左右两个子树都是一颗平衡二叉树 平衡二叉树旋转 旋转触发时机 当添加一个节点之后,该树不再是一颗平衡二叉树 左旋 就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点 右旋 就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点 平衡二叉树和二叉查找树对比结构图 平衡二叉树旋转的四种情况 左左 左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行右旋即可 左右 左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋 右右 右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行左旋即可 右左 右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋","categories":[],"tags":[]},{"title":"17_集合01","slug":"30_集合01","date":"2020-11-09T15:40:23.000Z","updated":"2020-11-09T15:41:15.926Z","comments":true,"path":"2020/11/09/30_集合01/","link":"","permalink":"http://xiaojujing.com/2020/11/09/30_%E9%9B%86%E5%90%8801/","excerpt":"1.Collection集合1.1数组和集合的区别【理解】 相同点 都是容器,可以存储多个数据","text":"1.Collection集合1.1数组和集合的区别【理解】 相同点 都是容器,可以存储多个数据 不同点 数组的长度是不可变的,集合的长度是可变的 数组可以存基本数据类型和引用数据类型 集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类 1.2集合类体系结构【理解】 1.3Collection 集合概述和使用【应用】 Collection集合概述 是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素 JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现 创建Collection集合的对象 多态的方式 具体的实现类ArrayList Collection集合常用方法 方法名 说明 boolean add(E e) 添加元素 boolean remove(Object o) 从集合中移除指定的元素 boolean removeIf(Object o) 根据条件进行移除 void clear() 清空集合中的元素 boolean contains(Object o) 判断集合中是否存在指定的元素 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中元素的个数 1.4Collection集合的遍历【应用】 迭代器介绍 迭代器,集合的专用遍历方式 Iterator iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到 Iterator中的常用方法 ​ boolean hasNext(): 判断当前位置是否有元素可以被取出​ E next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置 Collection集合的遍历 123456789101112131415161718192021public class IteratorDemo1 &#123; public static void main(String[] args) &#123; //创建集合对象 Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); //添加元素 c.add(\"hello\"); c.add(\"world\"); c.add(\"java\"); c.add(\"javaee\"); //Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到 Iterator&lt;String&gt; it = c.iterator(); //用while循环改进元素的判断和获取 while (it.hasNext()) &#123; String s = it.next(); System.out.println(s); &#125; &#125;&#125; 迭代器中删除的方法 ​ void remove(): 删除迭代器对象当前指向的元素 1234567891011121314151617181920public class IteratorDemo2 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"b\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); if(\"b\".equals(s))&#123; //指向谁,那么此时就删除谁. it.remove(); &#125; &#125; System.out.println(list); &#125;&#125; 1.5增强for循环【应用】 介绍 它是JDK5之后出现的,其内部原理是一个Iterator迭代器 实现Iterable接口的类才可以使用迭代器和增强for 简化数组和Collection集合的遍历 格式 ​ for(集合/数组中元素的数据类型 变量名 : 集合/数组名) { ​ // 已经将当前遍历到的元素封装到变量中了,直接使用变量即可 ​ } 代码 123456789101112131415161718public class MyCollectonDemo1 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\"); list.add(\"f\"); //1,数据类型一定是集合或者数组中元素的类型 //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素 //3,list就是要遍历的集合或者数组 for(String str : list)&#123; System.out.println(str); &#125; &#125;&#125; 2.List集合2.1List集合的概述和特点【记忆】 List集合的概述 有序集合,这里的有序指的是存取顺序 用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素 与Set集合不同,列表通常允许重复的元素 List集合的特点 存取有序 可以重复 有索引 2.2List集合的特有方法【应用】 方法介绍 方法名 描述 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyListDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); //method1(list); //method2(list); //method3(list); //method4(list); &#125; private static void method4(List&lt;String&gt; list) &#123; // E get(int index) 返回指定索引处的元素 String s = list.get(0); System.out.println(s); &#125; private static void method3(List&lt;String&gt; list) &#123; // E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 //被替换的那个元素,在集合中就不存在了. String result = list.set(0, \"qqq\"); System.out.println(result); System.out.println(list); &#125; private static void method2(List&lt;String&gt; list) &#123; // E remove(int index) 删除指定索引处的元素，返回被删除的元素 //在List集合中有两个删除的方法 //第一个 删除指定的元素,返回值表示当前元素是否删除成功 //第二个 删除指定索引的元素,返回值表示实际删除的元素 String s = list.remove(0); System.out.println(s); System.out.println(list); &#125; private static void method1(List&lt;String&gt; list) &#123; // void add(int index,E element) 在此集合中的指定位置插入指定的元素 //原来位置上的元素往后挪一个索引. list.add(0,\"qqq\"); System.out.println(list); &#125;&#125; 3.数据结构3.1数据结构之栈和队列【记忆】 栈结构 ​ 先进后出 队列结构 ​ 先进先出 3.2数据结构之数组和链表【记忆】 数组结构 ​ 查询快、增删慢 队列结构 ​ 查询慢、增删快 4.List集合的实现类4.1List集合子类的特点【记忆】 ArrayList集合 ​ 底层是数组结构实现，查询快、增删慢 LinkedList集合 ​ 底层是链表结构实现，查询慢、增删快 4.2LinkedList集合的特有功能【应用】 特有方法 方法名 说明 public void addFirst(E e) 在该列表开头插入指定的元素 public void addLast(E e) 将指定的元素追加到此列表的末尾 public E getFirst() 返回此列表中的第一个元素 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyLinkedListDemo4 &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\");// public void addFirst(E e) 在该列表开头插入指定的元素 //method1(list);// public void addLast(E e) 将指定的元素追加到此列表的末尾 //method2(list);// public E getFirst() 返回此列表中的第一个元素// public E getLast() 返回此列表中的最后一个元素 //method3(list);// public E removeFirst() 从此列表中删除并返回第一个元素// public E removeLast() 从此列表中删除并返回最后一个元素 //method4(list); &#125; private static void method4(LinkedList&lt;String&gt; list) &#123; String first = list.removeFirst(); System.out.println(first); String last = list.removeLast(); System.out.println(last); System.out.println(list); &#125; private static void method3(LinkedList&lt;String&gt; list) &#123; String first = list.getFirst(); String last = list.getLast(); System.out.println(first); System.out.println(last); &#125; private static void method2(LinkedList&lt;String&gt; list) &#123; list.addLast(\"www\"); System.out.println(list); &#125; private static void method1(LinkedList&lt;String&gt; list) &#123; list.addFirst(\"qqq\"); System.out.println(list); &#125;&#125; ​","categories":[],"tags":[]},{"title":"16-API02","slug":"29_API02","date":"2020-11-08T12:58:52.000Z","updated":"2020-11-08T13:00:15.957Z","comments":true,"path":"2020/11/08/29_API02/","link":"","permalink":"http://xiaojujing.com/2020/11/08/29_API02/","excerpt":"1.时间日期类1.1 Date类（应用） 计算机中时间原点 1970年1月1日 00:00:00","text":"1.时间日期类1.1 Date类（应用） 计算机中时间原点 1970年1月1日 00:00:00 时间换算单位 1秒 = 1000毫秒 Date类概述 Date 代表了一个特定的时间，精确到毫秒 Date类构造方法 方法名 说明 public Date() 分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 public Date(long date) 分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 示例代码 123456789101112public class DateDemo01 &#123; public static void main(String[] args) &#123; //public Date()：分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 Date d1 = new Date(); System.out.println(d1); //public Date(long date)：分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 long date = 1000*60*60; Date d2 = new Date(date); System.out.println(d2); &#125;&#125; 1.2 Date类常用方法（应用） 常用方法 方法名 说明 public long getTime() 获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 public void setTime(long time) 设置时间，给的是毫秒值 示例代码 1234567891011121314151617public class DateDemo02 &#123; public static void main(String[] args) &#123; //创建日期对象 Date d = new Date(); //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值// System.out.println(d.getTime());// System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + \"年\"); //public void setTime(long time):设置时间，给的是毫秒值// long time = 1000*60*60; long time = System.currentTimeMillis(); d.setTime(time); System.out.println(d); &#125;&#125; 1.3 SimpleDateFormat类（应用） SimpleDateFormat类概述 ​ SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。 ​ 我们重点学习日期格式化和解析 SimpleDateFormat类构造方法 方法名 说明 public SimpleDateFormat() 构造一个SimpleDateFormat，使用默认模式和日期格式 public SimpleDateFormat(String pattern) 构造一个SimpleDateFormat使用给定的模式和默认的日期格式 SimpleDateFormat类的常用方法 格式化(从Date到String) public final String format(Date date)：将日期格式化成日期/时间字符串 解析(从String到Date) public Date parse(String source)：从给定字符串的开始解析文本以生成日期 示例代码 123456789101112131415161718public class SimpleDateFormatDemo &#123; public static void main(String[] args) throws ParseException &#123; //格式化：从 Date 到 String Date d = new Date();// SimpleDateFormat sdf = new SimpleDateFormat(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String s = sdf.format(d); System.out.println(s); System.out.println(\"--------\"); //从 String 到 Date String ss = \"2048-08-09 11:11:11\"; //ParseException SimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date dd = sdf2.parse(ss); System.out.println(dd); &#125;&#125; 1.4 时间日期类练习 (应用) 需求 秒杀开始时间是2020年11月11日 00:00:00,结束时间是2020年11月11日 00:10:00,用户小贾下单时间是2020年11月11日 00:03:47,用户小皮下单时间是2020年11月11日 00:10:11,判断用户有没有成功参与秒杀活动 实现步骤 判断下单时间是否在开始到结束的范围内 把字符串形式的时间变成毫秒值 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class DateDemo5 &#123; public static void main(String[] args) throws ParseException &#123; //开始时间：2020年11月11日 0:0:0 //结束时间：2020年11月11日 0:10:0 //小贾2020年11月11日 0:03:47 //小皮2020年11月11日 0:10:11 //1.判断两位同学的下单时间是否在范围之内就可以了。 //2.要把每一个时间都换算成毫秒值。 String start = \"2020年11月11日 0:0:0\"; String end = \"2020年11月11日 0:10:0\"; String jia = \"2020年11月11日 0:03:47\"; String pi = \"2020年11月11日 0:10:11\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); long startTime = sdf.parse(start).getTime(); long endTime = sdf.parse(end).getTime();// System.out.println(startTime);// System.out.println(endTime); long jiaTime = sdf.parse(jia).getTime(); long piTime = sdf.parse(pi).getTime(); if(jiaTime &gt;= startTime &amp;&amp; jiaTime &lt;= endTime)&#123; System.out.println(\"小贾同学参加上了秒杀活动\"); &#125;else&#123; System.out.println(\"小贾同学没有参加上秒杀活动\"); &#125; System.out.println(\"------------------------\"); if(piTime &gt;= startTime &amp;&amp; piTime &lt;= endTime)&#123; System.out.println(\"小皮同学参加上了秒杀活动\"); &#125;else&#123; System.out.println(\"小皮同学没有参加上秒杀活动\"); &#125; &#125; &#125; 2.JDK8时间日期类2.1 JDK8新增日期类 (理解) LocalDate 表示日期（年月日） LocalTime 表示时间（时分秒） LocalDateTime 表示时间+ 日期 （年月日时分秒） 2.2 LocalDateTime创建方法 (应用) 方法说明 方法名 说明 public static LocalDateTime now() 获取当前系统时间 public static LocalDateTime of (年, 月 , 日, 时, 分, 秒) 使用指定年月日和时分秒初始化一个LocalDateTime对象 示例代码 123456789public class JDK8DateDemo2 &#123; public static void main(String[] args) &#123; LocalDateTime now = LocalDateTime.now(); System.out.println(now); LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 11); System.out.println(localDateTime); &#125;&#125; 2.3 LocalDateTime获取方法 (应用) 方法说明 方法名 说明 public int getYear() 获取年 public int getMonthValue() 获取月份（1-12） public int getDayOfMonth() 获取月份中的第几天（1-31） public int getDayOfYear() 获取一年中的第几天（1-366） public DayOfWeek getDayOfWeek() 获取星期 public int getMinute() 获取分钟 public int getHour() 获取小时 示例代码 12345678910111213141516171819202122232425262728293031323334public class JDK8DateDemo3 &#123; public static void main(String[] args) &#123; LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 20); //public int getYear() 获取年 int year = localDateTime.getYear(); System.out.println(\"年为\" +year); //public int getMonthValue() 获取月份（1-12） int month = localDateTime.getMonthValue(); System.out.println(\"月份为\" + month); Month month1 = localDateTime.getMonth();// System.out.println(month1); //public int getDayOfMonth() 获取月份中的第几天（1-31） int day = localDateTime.getDayOfMonth(); System.out.println(\"日期为\" + day); //public int getDayOfYear() 获取一年中的第几天（1-366） int dayOfYear = localDateTime.getDayOfYear(); System.out.println(\"这是一年中的第\" + dayOfYear + \"天\"); //public DayOfWeek getDayOfWeek()获取星期 DayOfWeek dayOfWeek = localDateTime.getDayOfWeek(); System.out.println(\"星期为\" + dayOfWeek); //public int getMinute() 获取分钟 int minute = localDateTime.getMinute(); System.out.println(\"分钟为\" + minute); //public int getHour() 获取小时 int hour = localDateTime.getHour(); System.out.println(\"小时为\" + hour); &#125;&#125; 2.4 LocalDateTime转换方法 (应用) 方法说明 方法名 说明 public LocalDate toLocalDate () 转换成为一个LocalDate对象 public LocalTime toLocalTime () 转换成为一个LocalTime对象 示例代码 123456789101112public class JDK8DateDemo4 &#123; public static void main(String[] args) &#123; LocalDateTime localDateTime = LocalDateTime.of(2020, 12, 12, 8, 10, 12); //public LocalDate toLocalDate () 转换成为一个LocalDate对象 LocalDate localDate = localDateTime.toLocalDate(); System.out.println(localDate); //public LocalTime toLocalTime () 转换成为一个LocalTime对象 LocalTime localTime = localDateTime.toLocalTime(); System.out.println(localTime); &#125;&#125; 2.5 LocalDateTime格式化和解析 (应用) 方法说明 方法名 说明 public String format (指定格式) 把一个LocalDateTime格式化成为一个字符串 public LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象 public static DateTimeFormatter ofPattern(String pattern) 使用指定的日期模板获取一个日期格式化器DateTimeFormatter对象 示例代码 1234567891011121314151617181920212223public class JDK8DateDemo5 &#123; public static void main(String[] args) &#123; //method1(); //method2(); &#125; private static void method2() &#123; //public static LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象 String s = \"2020年11月12日 13:14:15\"; DateTimeFormatter pattern = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss\"); LocalDateTime parse = LocalDateTime.parse(s, pattern); System.out.println(parse); &#125; private static void method1() &#123; LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 12, 13, 14, 15); System.out.println(localDateTime); //public String format (指定格式) 把一个LocalDateTime格式化成为一个字符串 DateTimeFormatter pattern = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss\"); String s = localDateTime.format(pattern); System.out.println(s); &#125;&#125; 2.6 LocalDateTime增加或者减少时间的方法 (应用) 方法说明 方法名 说明 public LocalDateTime plusYears (long years) 添加或者减去年 public LocalDateTime plusMonths(long months) 添加或者减去月 public LocalDateTime plusDays(long days) 添加或者减去日 public LocalDateTime plusHours(long hours) 添加或者减去时 public LocalDateTime plusMinutes(long minutes) 添加或者减去分 public LocalDateTime plusSeconds(long seconds) 添加或者减去秒 public LocalDateTime plusWeeks(long weeks) 添加或者减去周 示例代码 123456789101112131415/** * JDK8 时间类添加或者减去时间的方法 */public class JDK8DateDemo6 &#123; public static void main(String[] args) &#123; //public LocalDateTime plusYears (long years) 添加或者减去年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); //LocalDateTime newLocalDateTime = localDateTime.plusYears(1); //System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.plusYears(-1); System.out.println(newLocalDateTime); &#125;&#125; 2.7 LocalDateTime减少或者增加时间的方法 (应用) 方法说明 方法名 说明 public LocalDateTime minusYears (long years) 减去或者添加年 public LocalDateTime minusMonths(long months) 减去或者添加月 public LocalDateTime minusDays(long days) 减去或者添加日 public LocalDateTime minusHours(long hours) 减去或者添加时 public LocalDateTime minusMinutes(long minutes) 减去或者添加分 public LocalDateTime minusSeconds(long seconds) 减去或者添加秒 public LocalDateTime minusWeeks(long weeks) 减去或者添加周 示例代码 123456789101112131415/** * JDK8 时间类减少或者添加时间的方法 */public class JDK8DateDemo7 &#123; public static void main(String[] args) &#123; //public LocalDateTime minusYears (long years) 减去或者添加年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); //LocalDateTime newLocalDateTime = localDateTime.minusYears(1); //System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.minusYears(-1); System.out.println(newLocalDateTime); &#125;&#125; 2.8 LocalDateTime修改方法 (应用) 方法说明 方法名 说明 public LocalDateTime withYear(int year) 直接修改年 public LocalDateTime withMonth(int month) 直接修改月 public LocalDateTime withDayOfMonth(int dayofmonth) 直接修改日期(一个月中的第几天) public LocalDateTime withDayOfYear(int dayOfYear) 直接修改日期(一年中的第几天) public LocalDateTime withHour(int hour) 直接修改小时 public LocalDateTime withMinute(int minute) 直接修改分钟 public LocalDateTime withSecond(int second) 直接修改秒 示例代码 123456789101112131415/** * JDK8 时间类修改时间 */public class JDK8DateDemo8 &#123; public static void main(String[] args) &#123; //public LocalDateTime withYear(int year) 修改年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); // LocalDateTime newLocalDateTime = localDateTime.withYear(2048); // System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.withMonth(20); System.out.println(newLocalDateTime); &#125;&#125; 2.9 Period (应用) 方法说明 方法名 说明 public static Period between(开始时间,结束时间) 计算两个“时间”的间隔 public int getYears() 获得这段时间的年数 public int getMonths() 获得此期间的月数 public int getDays() 获得此期间的天数 public long toTotalMonths() 获取此期间的总月数 示例代码 123456789101112131415161718192021222324/** * 计算两个时间的间隔 */public class JDK8DateDemo9 &#123; public static void main(String[] args) &#123; //public static Period between(开始时间,结束时间) 计算两个\"时间\"的间隔 LocalDate localDate1 = LocalDate.of(2020, 1, 1); LocalDate localDate2 = LocalDate.of(2048, 12, 12); Period period = Period.between(localDate1, localDate2); System.out.println(period);//P28Y11M11D //public int getYears() 获得这段时间的年数 System.out.println(period.getYears());//28 //public int getMonths() 获得此期间的月数 System.out.println(period.getMonths());//11 //public int getDays() 获得此期间的天数 System.out.println(period.getDays());//11 //public long toTotalMonths() 获取此期间的总月数 System.out.println(period.toTotalMonths());//347 &#125;&#125; 2.10 Duration (应用) 方法说明 方法名 说明 public static Durationbetween(开始时间,结束时间) 计算两个“时间”的间隔 public long toSeconds() 获得此时间间隔的秒 public int toMillis() 获得此时间间隔的毫秒 public int toNanos() 获得此时间间隔的纳秒 示例代码 12345678910111213141516171819/** * 计算两个时间的间隔 */public class JDK8DateDemo10 &#123; public static void main(String[] args) &#123; //public static Duration between(开始时间,结束时间) 计算两个“时间\"的间隔 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 1, 13, 14, 15); LocalDateTime localDateTime2 = LocalDateTime.of(2020, 1, 2, 11, 12, 13); Duration duration = Duration.between(localDateTime1, localDateTime2); System.out.println(duration);//PT21H57M58S //public long toSeconds() 获得此时间间隔的秒 System.out.println(duration.toSeconds());//79078 //public int toMillis() 获得此时间间隔的毫秒 System.out.println(duration.toMillis());//79078000 //public int toNanos() 获得此时间间隔的纳秒 System.out.println(duration.toNanos());//79078000000000 &#125;&#125; 3.异常3.1 异常（记忆） 异常的概述 ​ 异常就是程序出现了不正常的情况 异常的体系结构 3.2 编译时异常和运行时异常的区别（记忆） 编译时异常 都是Exception类及其子类 必须显示处理，否则程序就会发生错误，无法通过编译 运行时异常 都是RuntimeException类及其子类 无需显示处理，也可以和编译时异常一样处理 图示 3.3 JVM默认处理异常的方式（理解） 如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤： 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台 程序停止执行 3.4 查看异常信息 (理解)控制台在打印异常信息时,会打印异常类名,异常出现的原因,异常出现的位置 我们调bug时,可以根据提示,找到异常出现的位置,分析原因,修改异常代码 3.5 throws方式处理异常（应用） 定义格式 123public void 方法() throws 异常类名 &#123; &#125; 示例代码 1234567891011121314151617181920212223public class ExceptionDemo &#123; public static void main(String[] args) throws ParseException&#123; System.out.println(\"开始\");// method(); method2(); System.out.println(\"结束\"); &#125; //编译时异常 public static void method2() throws ParseException &#123; String s = \"2048-08-09\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date d = sdf.parse(s); System.out.println(d); &#125; //运行时异常 public static void method() throws ArrayIndexOutOfBoundsException &#123; int[] arr = &#123;1, 2, 3&#125;; System.out.println(arr[3]); &#125;&#125; 注意事项 这个throws格式是跟在方法的括号后面的 编译时异常必须要进行处理，两种处理方案：try…catch …或者 throws，如果采用 throws 这种方案，在方法上进行显示声明,将来谁调用这个方法谁处理 运行时异常因为在运行时才会发生,所以在方法后面可以不写,运行时出现异常默认交给jvm处理 3.6 throw抛出异常 (应用) 格式 throw new 异常(); 注意 这个格式是在方法内的，表示当前代码手动抛出一个异常，下面的代码不用再执行了 throws和throw的区别 throws throw 用在方法声明后面，跟的是异常类名 用在方法体内，跟的是异常对象名 表示声明异常，调用该方法有可能会出现这样的异常 表示手动抛出异常对象，由方法体内的语句处理 示例代码 12345678910111213141516171819202122public class ExceptionDemo8 &#123; public static void main(String[] args) &#123; //int [] arr = &#123;1,2,3,4,5&#125;; int [] arr = null; printArr(arr);//就会 接收到一个异常. //我们还需要自己处理一下异常. &#125; private static void printArr(int[] arr) &#123; if(arr == null)&#123; //调用者知道成功打印了吗? //System.out.println(\"参数不能为null\"); throw new NullPointerException(); //当参数为null的时候 //手动创建了一个异常对象,抛给了调用者,产生了一个异常 &#125;else&#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; &#125;&#125; 3.7 try-catch方式处理异常（应用） 定义格式 12345try &#123; 可能出现异常的代码;&#125; catch(异常类名 变量名) &#123; 异常的处理代码;&#125; 执行流程 程序从 try 里面的代码开始执行 出现异常，就会跳转到对应的 catch 里面去执行 执行完毕之后，程序还可以继续往下执行 示例代码 1234567891011121314151617public class ExceptionDemo01 &#123; public static void main(String[] args) &#123; System.out.println(\"开始\"); method(); System.out.println(\"结束\"); &#125; public static void method() &#123; try &#123; int[] arr = &#123;1, 2, 3&#125;; System.out.println(arr[3]); System.out.println(\"这里能够访问到吗\"); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println(\"你访问的数组索引不存在，请回去修改为正确的索引\"); &#125; &#125;&#125; 注意 如果 try 中没有遇到问题，怎么执行？ 会把try中所有的代码全部执行完毕,不会执行catch里面的代码 如果 try 中遇到了问题，那么 try 下面的代码还会执行吗？ 那么直接跳转到对应的catch语句中,try下面的代码就不会再执行了当catch里面的语句全部执行完毕,表示整个体系全部执行完全,继续执行下面的代码 如果出现的问题没有被捕获，那么程序如何运行？ 那么try…catch就相当于没有写.那么也就是自己没有处理.默认交给虚拟机处理. 同时有可能出现多个异常怎么处理？ 出现多个异常,那么就写多个catch就可以了.注意点:如果多个异常之间存在子父类关系.那么父类一定要写在下面 3.8 Throwable成员方法（应用） 常用方法 方法名 说明 public String getMessage() 返回此 throwable 的详细消息字符串 public String toString() 返回此可抛出的简短描述 public void printStackTrace() 把异常的错误信息输出在控制台 示例代码 1234567891011121314151617181920212223242526272829303132public class ExceptionDemo02 &#123; public static void main(String[] args) &#123; System.out.println(\"开始\"); method(); System.out.println(\"结束\"); &#125; public static void method() &#123; try &#123; int[] arr = &#123;1, 2, 3&#125;; System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException(); System.out.println(\"这里能够访问到吗\"); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; //new ArrayIndexOutOfBoundsException();// e.printStackTrace(); //public String getMessage():返回此 throwable 的详细消息字符串// System.out.println(e.getMessage()); //Index 3 out of bounds for length 3 //public String toString():返回此可抛出的简短描述// System.out.println(e.toString()); //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 //public void printStackTrace():把异常的错误信息输出在控制台 e.printStackTrace();// java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3// at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18)// at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11) &#125; &#125;&#125; 3.9 异常的练习 (应用) 需求 键盘录入学生的姓名和年龄,其中年龄为18 - 25岁,超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止 实现步骤 创建学生对象 键盘录入姓名和年龄，并赋值给学生对象 如果是非法数据就再次录入 代码实现 学生类 1234567891011121314151617181920212223242526272829303132333435363738394041public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age &gt;= 18 &amp;&amp; age &lt;= 25)&#123; this.age = age; &#125;else&#123; //当年龄不合法时,产生一个异常 throw new RuntimeException(\"年龄超出了范围\"); &#125; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738public class ExceptionDemo12 &#123; public static void main(String[] args) &#123; // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(\"请输入姓名\"); String name = sc.nextLine(); s.setName(name); while(true)&#123; System.out.println(\"请输入年龄\"); String ageStr = sc.nextLine(); try &#123; int age = Integer.parseInt(ageStr); s.setAge(age); break; &#125; catch (NumberFormatException e) &#123; System.out.println(\"请输入一个整数\"); continue; &#125; catch (AgeOutOfBoundsException e) &#123; System.out.println(e.toString()); System.out.println(\"请输入一个符合范围的年龄\"); continue; &#125; /*if(age &gt;= 18 &amp;&amp; age &lt;=25)&#123; s.setAge(age); break; &#125;else&#123; System.out.println(\"请输入符合要求的年龄\"); continue; &#125;*/ &#125; System.out.println(s); &#125;&#125; 3.10 自定义异常（应用） 自定义异常概述 当Java中提供的异常不能满足我们的需求时,我们可以自定义异常 实现步骤 定义异常类 写继承关系 提供空参构造 提供带参构造 代码实现 异常类 12345678public class AgeOutOfBoundsException extends RuntimeException &#123; public AgeOutOfBoundsException() &#123; &#125; public AgeOutOfBoundsException(String message) &#123; super(message); &#125;&#125; 学生类 1234567891011121314151617181920212223242526272829303132333435363738394041public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age &gt;= 18 &amp;&amp; age &lt;= 25)&#123; this.age = age; &#125;else&#123; //如果Java中提供的异常不能满足我们的需求,我们可以使用自定义的异常 throw new AgeOutOfBoundsException(\"年龄超出了范围\"); &#125; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738public class ExceptionDemo12 &#123; public static void main(String[] args) &#123; // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(\"请输入姓名\"); String name = sc.nextLine(); s.setName(name); while(true)&#123; System.out.println(\"请输入年龄\"); String ageStr = sc.nextLine(); try &#123; int age = Integer.parseInt(ageStr); s.setAge(age); break; &#125; catch (NumberFormatException e) &#123; System.out.println(\"请输入一个整数\"); continue; &#125; catch (AgeOutOfBoundsException e) &#123; System.out.println(e.toString()); System.out.println(\"请输入一个符合范围的年龄\"); continue; &#125; /*if(age &gt;= 18 &amp;&amp; age &lt;=25)&#123; s.setAge(age); break; &#125;else&#123; System.out.println(\"请输入符合要求的年龄\"); continue; &#125;*/ &#125; System.out.println(s); &#125;&#125;","categories":[],"tags":[]},{"title":"15-API01","slug":"28_API01","date":"2020-11-08T12:58:41.000Z","updated":"2020-11-08T12:59:41.572Z","comments":true,"path":"2020/11/08/28_API01/","link":"","permalink":"http://xiaojujing.com/2020/11/08/28_API01/","excerpt":"1.API1.1 API概述【理解】 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API","text":"1.API1.1 API概述【理解】 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API ​ 指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。 1.2 如何使用API帮助文档【应用】 打开帮助文档 找到索引选项卡中的输入框 在输入框中输入Random 看类在哪个包下 看类的描述 看构造方法 看成员方法 2.常用API2.1 Math（应用） 1、Math类概述 Math 包含执行基本数字运算的方法 2、Math中方法的调用方式 Math类中无构造方法，但内部的方法都是静态的，则可以通过 类名.进行调用 3、Math类的常用方法 方法名 方法名 说明 public static int abs(int a) 返回参数的绝对值 public static double ceil(double a) 返回大于或等于参数的最小double值，等于一个整数 public static double floor(double a) 返回小于或等于参数的最大double值，等于一个整数 public static int round(float a) 按照四舍五入返回最接近参数的int public static int max(int a,int b) 返回两个int值中的较大值 public static int min(int a,int b) 返回两个int值中的较小值 public static double pow (double a,double b) 返回a的b次幂的值 public static double random() 返回值为double的正值，[0.0,1.0) 2.2 System（应用） System类的常用方法 方法名 说明 public static void exit(int status) 终止当前运行的 Java 虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前时间(以毫秒为单位) 示例代码 需求：在控制台输出1-10000，计算这段代码执行了多少毫秒 123456789101112public class SystemDemo &#123; public static void main(String[] args) &#123; // 获取开始的时间节点 long start = System.currentTimeMillis(); for (int i = 1; i &lt;= 10000; i++) &#123; System.out.println(i); &#125; // 获取代码运行结束后的时间节点 long end = System.currentTimeMillis(); System.out.println(\"共耗时：\" + (end - start) + \"毫秒\"); &#125;&#125; 2.3 Object类的toString方法（应用） Object类概述 Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份 查看方法源码的方式 选中方法，按下Ctrl + B 重写toString方法的方式 Alt + Insert 选择toString 在类的空白区域，右键 -&gt; Generate -&gt; 选择toString toString方法的作用： 以良好的格式，更方便的展示对象中的属性值 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Student extends Object &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125;public class ObjectDemo &#123; public static void main(String[] args) &#123; Student s = new Student(); s.setName(\"林青霞\"); s.setAge(30); System.out.println(s); System.out.println(s.toString()); &#125;&#125; 运行结果： 12Student&#123;name='林青霞', age=30&#125;Student&#123;name='林青霞', age=30&#125; 2.4 Object类的equals方法（应用） equals方法的作用 用于对象之间的比较，返回true和false的结果 举例：s1.equals(s2); s1和s2是两个对象 重写equals方法的场景 不希望比较对象的地址值，想要结合对象属性进行比较的时候。 重写equals方法的方式 alt + insert 选择equals() and hashCode()，IntelliJ Default，一路next，finish即可 在类的空白区域，右键 -&gt; Generate -&gt; 选择equals() and hashCode()，后面的同上。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; //this -- s1 //o -- s2 if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; //student -- s2 if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125;&#125;public class ObjectDemo &#123; public static void main(String[] args) &#123; Student s1 = new Student(); s1.setName(\"林青霞\"); s1.setAge(30); Student s2 = new Student(); s2.setName(\"林青霞\"); s2.setAge(30); //需求：比较两个对象的内容是否相同 System.out.println(s1.equals(s2)); &#125;&#125; 面试题 123456789101112131415161718// 看程序,分析结果String s = “abc”;StringBuilder sb = new StringBuilder(“abc”);s.equals(sb); sb.equals(s); public class InterviewTest &#123; public static void main(String[] args) &#123; String s1 = \"abc\"; StringBuilder sb = new StringBuilder(\"abc\"); //1.此时调用的是String类中的equals方法. //保证参数也是字符串,否则不会比较属性值而直接返回false //System.out.println(s1.equals(sb)); // false //StringBuilder类中是没有重写equals方法,用的就是Object类中的. System.out.println(sb.equals(s1)); // false &#125;&#125; 2.5 Objects (应用) 常用方法 方法名 说明 public static String toString(对象) 返回参数中对象的字符串表示形式。 public static String toString(对象, 默认字符串) 返回对象的字符串表示形式。 public static Boolean isNull(对象) 判断对象是否为空 public static Boolean nonNull(对象) 判断对象是否不为空 示例代码 学生类 123456789101112131415161718192021222324252627282930313233343536class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; &#125; 测试类 123456789101112131415161718192021222324252627public class MyObjectsDemo &#123; public static void main(String[] args) &#123; // public static String toString(对象): 返回参数中对象的字符串表示形式。 // Student s = new Student(\"小罗同学\",50); // String result = Objects.toString(s); // System.out.println(result); // System.out.println(s); // public static String toString(对象, 默认字符串): 返回对象的字符串表示形式。如果对象为空,那么返回第二个参数. //Student s = new Student(\"小花同学\",23); // Student s = null; // String result = Objects.toString(s, \"随便写一个\"); // System.out.println(result); // public static Boolean isNull(对象): 判断对象是否为空 //Student s = null; // Student s = new Student(); // boolean result = Objects.isNull(s); // System.out.println(result); // public static Boolean nonNull(对象): 判断对象是否不为空 //Student s = new Student(); Student s = null; boolean result = Objects.nonNull(s); System.out.println(result); &#125; &#125; 2.6 BigDecimal (应用) 作用 可以用来进行精确计算 构造方法 方法名 说明 BigDecimal(double val) 参数为double BigDecimal(String val) 参数为String 常用方法 方法名 说明 public BigDecimal add(另一个BigDecimal对象) 加法 public BigDecimal subtract (另一个BigDecimal对象) 减法 public BigDecimal multiply (另一个BigDecimal对象) 乘法 public BigDecimal divide (另一个BigDecimal对象) 除法 public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) 除法 总结 BigDecimal是用来进行精确计算的 创建BigDecimal的对象，构造方法使用参数类型为字符串的。 四则运算中的除法，如果除不尽请使用divide的三个参数的方法。 代码示例： 1234567BigDecimal divide = bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);参数1 ，表示参与运算的BigDecimal 对象。参数2 ，表示小数点后面精确到多少位参数3 ，舍入模式 BigDecimal.ROUND_UP 进一法 BigDecimal.ROUND_FLOOR 去尾法 BigDecimal.ROUND_HALF_UP 四舍五入 3.包装类3.1 基本类型包装类（记忆） 基本类型包装类的作用 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 常用的操作之一：用于基本数据类型与字符串之间的转换 基本类型对应的包装类 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 3.2 Integer类（应用） Integer类概述 包装一个对象中的原始类型 int 的值 Integer类构造方法 方法名 说明 public Integer(int value) 根据 int 值创建 Integer 对象(过时) public Integer(String s) 根据 String 值创建 Integer 对象(过时) public static Integer valueOf(int i) 返回表示指定的 int 值的 Integer 实例 public static Integer valueOf(String s) 返回一个保存指定值的 Integer 对象 String 示例代码 123456789101112131415161718192021public class IntegerDemo &#123; public static void main(String[] args) &#123; //public Integer(int value)：根据 int 值创建 Integer 对象(过时) Integer i1 = new Integer(100); System.out.println(i1); //public Integer(String s)：根据 String 值创建 Integer 对象(过时) Integer i2 = new Integer(\"100\");// Integer i2 = new Integer(\"abc\"); //NumberFormatException System.out.println(i2); System.out.println(\"--------\"); //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例 Integer i3 = Integer.valueOf(100); System.out.println(i3); //public static Integer valueOf(String s)：返回一个保存指定值的Integer对象 String Integer i4 = Integer.valueOf(\"100\"); System.out.println(i4); &#125;&#125; 3.3 自动拆箱和自动装箱（理解） 自动装箱 ​ 把基本数据类型转换为对应的包装类类型 自动拆箱 ​ 把包装类类型转换为对应的基本数据类型 示例代码 12Integer i = 100; // 自动装箱i += 200; // i = i + 200; i + 200 自动拆箱；i = i + 200; 是自动装箱 3.4 int和String类型的相互转换（记忆） int转换为String 转换方式 方式一：直接在数字后加一个空字符串 方式二：通过String类静态方法valueOf() 示例代码 1234567891011121314public class IntegerDemo &#123; public static void main(String[] args) &#123; //int --- String int number = 100; //方式1 String s1 = number + \"\"; System.out.println(s1); //方式2 //public static String valueOf(int i) String s2 = String.valueOf(number); System.out.println(s2); System.out.println(\"--------\"); &#125;&#125; String转换为int 转换方式 方式一：先将字符串数字转成Integer，再调用valueOf()方法 方式二：通过Integer静态方法parseInt()进行转换 示例代码 123456789101112131415public class IntegerDemo &#123; public static void main(String[] args) &#123; //String --- int String s = \"100\"; //方式1：String --- Integer --- int Integer i = Integer.valueOf(s); //public int intValue() int x = i.intValue(); System.out.println(x); //方式2 //public static int parseInt(String s) int y = Integer.parseInt(s); System.out.println(y); &#125;&#125; 3.5 字符串数据排序案例（应用） 案例需求 ​ 有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：27 38 46 50 91 代码实现 123456789101112131415161718192021222324public class IntegerTest &#123; public static void main(String[] args) &#123; //定义一个字符串 String s = \"91 27 46 38 50\"; //把字符串中的数字数据存储到一个int类型的数组中 String[] strArray = s.split(\" \");// for(int i=0; i&lt;strArray.length; i++) &#123;// System.out.println(strArray[i]);// &#125; //定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中 int[] arr = new int[strArray.length]; for(int i=0; i&lt;arr.length; i++) &#123; arr[i] = Integer.parseInt(strArray[i]); &#125; //对 int 数组进行排序 Arrays.sort(arr); for(int i=0; i&lt;arr.length; i++)&#123; System.out.print(arr[i] + \" \"); &#125;&#125; 4.递归4.1 递归【应用】 递归的介绍 以编程的角度来看，递归指的是方法定义中调用方法本身的现象 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算 递归的基本使用 1234567891011121314151617181920public class MyFactorialDemo2 &#123; public static void main(String[] args) &#123; int sum = getSum(100); System.out.println(sum); &#125; private static int getSum(int i) &#123; //1- 100之间的和 //100 + (1-99之间的和) // 99 + (1- 98之间的和) //.... //1 //方法的作用: 求 1- i 之间和 if(i == 1)&#123; return 1; &#125;else&#123; return i + getSum(i -1); &#125; &#125;&#125; 递归的注意事项 递归一定要有出口。否则内存溢出 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出 4.2 递归求阶乘【应用】 案例需求 ​ 用递归求5的阶乘，并把结果在控制台输出 代码实现 1234567891011121314151617181920public class DiGuiDemo01 &#123; public static void main(String[] args) &#123; //调用方法 int result = jc(5); //输出结果 System.out.println(\"5的阶乘是：\" + result); &#125; //定义一个方法，用于递归求阶乘，参数为一个int类型的变量 public static int jc(int n) &#123; //在方法内部判断该变量的值是否是1 if(n == 1) &#123; //是：返回1 return 1; &#125; else &#123; //不是：返回n*(n-1)! return n*jc(n-1); &#125; &#125;&#125; 内存图 5.数组的高级操作5.1 二分查找 (理解) 二分查找概述 查找指定元素在数组中的位置时,以前的方式是通过遍历,逐个获取每个元素,看是否是要查找的元素,这种方式当数组元素较多时,查找的效率很低 二分查找也叫折半查找,每次可以去掉一半的查找范围,从而提高查找的效率 需求 在数组{1,2,3,4,5,6,7,8,9,10}中,查找某个元素的位置 实现步骤 定义两个变量，表示要查找的范围。默认min = 0 ，max = 最大索引 循环查找，但是min &lt;= max 计算出mid的值 判断mid位置的元素是否为要查找的元素，如果是直接返回对应索引 如果要查找的值在mid的左半边，那么min值不变，max = mid -1.继续下次循环查找 如果要查找的值在mid的右半边，那么max值不变，min = mid + 1.继续下次循环查找 当min &gt; max 时，表示要查找的元素在数组中不存在，返回-1. 代码实现 1234567891011121314151617181920212223242526272829303132333435363738public class MyBinarySearchDemo &#123; public static void main(String[] args) &#123; int [] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int number = 11; //1,我现在要干嘛? --- 二分查找 //2.我干这件事情需要什么? --- 数组 元素 //3,我干完了,要不要把结果返回调用者 --- 把索引返回给调用者 int index = binarySearchForIndex(arr,number); System.out.println(index); &#125; private static int binarySearchForIndex(int[] arr, int number) &#123; //1,定义查找的范围 int min = 0; int max = arr.length - 1; //2.循环查找 min &lt;= max while(min &lt;= max)&#123; //3.计算出中间位置 mid int mid = (min + max) &gt;&gt; 1; //mid指向的元素 &gt; number if(arr[mid] &gt; number)&#123; //表示要查找的元素在左边. max = mid -1; &#125;else if(arr[mid] &lt; number)&#123; //mid指向的元素 &lt; number //表示要查找的元素在右边. min = mid + 1; &#125;else&#123; //mid指向的元素 == number return mid; &#125; &#125; //如果min大于了max就表示元素不存在,返回-1. return -1; &#125; &#125; 注意事项 有一个前提条件，数组内的元素一定要按照大小顺序排列，如果没有大小顺序，是不能使用二分查找法的 5.2 冒泡排序 (理解) 冒泡排序概述 一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序 如果有n个数据进行排序，总共需要比较n-1次 每一次比较完毕，下一次的比较就会少一个数据参与 代码实现 123456789101112131415161718192021222324252627282930313233public class MyBubbleSortDemo2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3, 5, 2, 1, 4&#125;; //1 2 3 4 5 bubbleSort(arr); &#125; private static void bubbleSort(int[] arr) &#123; //外层循环控制的是次数 比数组的长度少一次. for (int i = 0; i &lt; arr.length -1; i++) &#123; //内存循环就是实际循环比较的 //-1 是为了让数组不要越界 //-i 每一轮结束之后,我们就会少比一个数字. for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; printArr(arr); &#125; private static void printArr(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125; &#125; 5.3 快速排序 (理解) 快速排序概述 冒泡排序算法中,一次循环结束,就相当于确定了当前的最大值,也能确定最大值在数组中应存入的位置 快速排序算法中,每一次递归时以第一个数为基准数,找到数组中所有比基准数小的.再找到所有比基准数大的.小的全部放左边,大的全部放右边,确定基准数的正确位置 核心步骤 从右开始找比基准数小的 从左开始找比基准数大的 交换两个值的位置 红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止 基准数归位 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MyQuiteSortDemo2 &#123; public static void main(String[] args) &#123;// 1，从右开始找比基准数小的// 2，从左开始找比基准数大的// 3，交换两个值的位置// 4，红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止// 5，基准数归位 int[] arr = &#123;6, 1, 2, 7, 9, 3, 4, 5, 10, 8&#125;; quiteSort(arr,0,arr.length-1); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; &#125; private static void quiteSort(int[] arr, int left, int right) &#123; // 递归结束的条件 if(right &lt; left)&#123; return; &#125; int left0 = left; int right0 = right; //计算出基准数 int baseNumber = arr[left0]; while(left != right)&#123;// 1，从右开始找比基准数小的 while(arr[right] &gt;= baseNumber &amp;&amp; right &gt; left)&#123; right--; &#125;// 2，从左开始找比基准数大的 while(arr[left] &lt;= baseNumber &amp;&amp; right &gt; left)&#123; left++; &#125;// 3，交换两个值的位置 int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; &#125; //基准数归位 int temp = arr[left]; arr[left] = arr[left0]; arr[left0] = temp; // 递归调用自己,将左半部分排好序 quiteSort(arr,left0,left-1); // 递归调用自己,将右半部分排好序 quiteSort(arr,left +1,right0); &#125;&#125; 5.4 Arrays (应用) Arrays的常用方法 方法名 说明 public static String toString(int[] a) 返回指定数组的内容的字符串表示形式 public static void sort(int[] a) 按照数字顺序排列指定的数组 public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引 示例代码 123456789101112131415161718192021public class MyArraysDemo &#123; public static void main(String[] args) &#123; // public static String toString(int[] a) 返回指定数组的内容的字符串表示形式 // int [] arr = &#123;3,2,4,6,7&#125;; // System.out.println(Arrays.toString(arr)); // public static void sort(int[] a) 按照数字顺序排列指定的数组 // int [] arr = &#123;3,2,4,6,7&#125;; // Arrays.sort(arr); // System.out.println(Arrays.toString(arr)); // public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引 int [] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int index = Arrays.binarySearch(arr, 0); System.out.println(index); //1,数组必须有序 //2.如果要查找的元素存在,那么返回的是这个元素实际的索引 //3.如果要查找的元素不存在,那么返回的是 (-插入点-1) //插入点:如果这个元素在数组中,他应该在哪个索引上. &#125; &#125; 工具类设计思想 构造方法用 private 修饰 成员用 public static 修饰","categories":[],"tags":[]},{"title":"14_匿名内部类和Lambda表达式","slug":"27_匿名内部类和Lambda表达式","date":"2020-11-07T15:16:20.000Z","updated":"2020-11-07T15:17:16.330Z","comments":true,"path":"2020/11/07/27_匿名内部类和Lambda表达式/","link":"","permalink":"http://xiaojujing.com/2020/11/07/27_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"1.内部类1.1 内部类的基本使用（理解） 内部类概念 在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类 内部类定义格式 格式&amp;举例：","text":"1.内部类1.1 内部类的基本使用（理解） 内部类概念 在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类 内部类定义格式 格式&amp;举例： 1234567891011121314/* 格式： class 外部类名&#123; 修饰符 class 内部类名&#123; &#125; &#125;*/class Outer &#123; public class Inner &#123; &#125;&#125; 内部类的访问特点 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 示例代码： 1234567891011121314151617/* 内部类访问特点： 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 */public class Outer &#123; private int num = 10; public class Inner &#123; public void show() &#123; System.out.println(num); &#125; &#125; public void method() &#123; Inner i = new Inner(); i.show(); &#125;&#125; 1.2 成员内部类（理解） 成员内部类的定义位置 在类中方法，跟成员变量是一个位置 外界创建成员内部类格式 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象; 举例：Outer.Inner oi = new Outer().new Inner(); 私有成员内部类 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。 示例代码： 1234567891011121314151617181920class Outer &#123; private int num = 10; private class Inner &#123; public void show() &#123; System.out.println(num); &#125; &#125; public void method() &#123; Inner i = new Inner(); i.show(); &#125;&#125;public class InnerDemo &#123; public static void main(String[] args) &#123; //Outer.Inner oi = new Outer().new Inner(); //oi.show(); Outer o = new Outer(); o.method(); &#125;&#125; 静态成员内部类 静态成员内部类访问格式：外部类名.内部类名 对象名 = new 外部类名.内部类名(); 静态成员内部类中的静态方法：外部类名.内部类名.方法名(); 示例代码 123456789101112131415161718192021222324class Outer &#123; static class Inner &#123; public void show()&#123; System.out.println(\"inner..show\"); &#125; public static void method()&#123; System.out.println(\"inner..method\"); &#125; &#125;&#125;public class Test3Innerclass &#123; /* 静态成员内部类演示 */ public static void main(String[] args) &#123; // 外部类名.内部类名 对象名 = new 外部类名.内部类名(); Outer.Inner oi = new Outer.Inner(); oi.show(); Outer.Inner.method(); &#125;&#125; 1.3 局部内部类（理解） 局部内部类定义位置 局部内部类是在方法中定义的类 局部内部类方式方式 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用 该类可以直接访问外部类的成员，也可以访问方法内的局部变量 示例代码 1234567891011121314151617181920class Outer &#123; private int num = 10; public void method() &#123; int num2 = 20; class Inner &#123; public void show() &#123; System.out.println(num); System.out.println(num2); &#125; &#125; Inner i = new Inner(); i.show(); &#125;&#125;public class OuterDemo &#123; public static void main(String[] args) &#123; Outer o = new Outer(); o.method(); &#125;&#125; 1.4 匿名内部类（应用） 匿名内部类的前提 存在一个类或者接口，这里的类可以是具体类也可以是抽象类 匿名内部类的格式 格式：new 类名 ( ) { 重写方法 } new 接口名 ( ) { 重写方法 } 举例： 1234new Inter()&#123; @Override public void method()&#123;&#125;&#125; 匿名内部类的本质 本质：是一个继承了该类或者实现了该接口的子类匿名对象 匿名内部类的细节 匿名内部类可以通过多态的形式接受 123456Inter i = new Inter()&#123; @Override public void method()&#123; &#125;&#125; 匿名内部类直接调用方法 1234567891011121314interface Inter&#123; void method();&#125;class Test&#123; public static void main(String[] args)&#123; new Inter()&#123; @Override public void method()&#123; System.out.println(\"我是匿名内部类\"); &#125; &#125;.method(); // 直接调用方法 &#125;&#125; 1.5 匿名内部类在开发中的使用（应用） 匿名内部类在开发中的使用 当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码 示例代码： 1234567891011121314151617181920212223242526272829303132/* 游泳接口 */interface Swimming &#123; void swim();&#125;public class TestSwimming &#123; public static void main(String[] args) &#123; goSwimming(new Swimming() &#123; @Override public void swim() &#123; System.out.println(\"铁汁, 我们去游泳吧\"); &#125; &#125;); &#125; /** * 使用接口的方法 */ public static void goSwimming(Swimming swimming)&#123; /* Swimming swim = new Swimming() &#123; @Override public void swim() &#123; System.out.println(\"铁汁, 我们去游泳吧\"); &#125; &#125; */ swimming.swim(); &#125;&#125; 2.Lambda表达式2.1体验Lambda表达式【理解】 代码演示 123456789101112131415161718192021222324252627282930/* 游泳接口 */interface Swimming &#123; void swim();&#125;public class TestSwimming &#123; public static void main(String[] args) &#123; // 通过匿名内部类实现 goSwimming(new Swimming() &#123; @Override public void swim() &#123; System.out.println(\"铁汁, 我们去游泳吧\"); &#125; &#125;); /* 通过Lambda表达式实现 理解: 对于Lambda表达式, 对匿名内部类进行了优化 */ goSwimming(() -&gt; System.out.println(\"铁汁, 我们去游泳吧\")); &#125; /** * 使用接口的方法 */ public static void goSwimming(Swimming swimming) &#123; swimming.swim(); &#125;&#125; 函数式编程思想概述 在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿数据做操作” 面向对象思想强调“必须通过对象的形式来做事情” 函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做” 而我们要学习的Lambda表达式就是函数式思想的体现 2.2Lambda表达式的标准格式【理解】 格式： ​ (形式参数) -&gt; {代码块} 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可 -&gt;：由英文中画线和大于符号组成，固定写法。代表指向动作 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容 组成Lambda表达式的三要素： 形式参数，箭头，代码块 2.3Lambda表达式练习1【应用】 Lambda表达式的使用前提 有一个接口 接口中有且仅有一个抽象方法 练习描述 ​ 无参无返回值抽象方法的练习 操作步骤 定义一个接口(Eatable)，里面定义一个抽象方法：void eat(); 定义一个测试类(EatableDemo)，在测试类中提供两个方法 一个方法是：useEatable(Eatable e) 一个方法是主方法，在主方法中调用useEatable方法 示例代码 123456789101112131415161718192021222324252627282930313233343536//接口public interface Eatable &#123; void eat();&#125;//实现类public class EatableImpl implements Eatable &#123; @Override public void eat() &#123; System.out.println(\"一天一苹果，医生远离我\"); &#125;&#125;//测试类public class EatableDemo &#123; public static void main(String[] args) &#123; //在主方法中调用useEatable方法 Eatable e = new EatableImpl(); useEatable(e); //匿名内部类 useEatable(new Eatable() &#123; @Override public void eat() &#123; System.out.println(\"一天一苹果，医生远离我\"); &#125; &#125;); //Lambda表达式 useEatable(() -&gt; &#123; System.out.println(\"一天一苹果，医生远离我\"); &#125;); &#125; private static void useEatable(Eatable e) &#123; e.eat(); &#125;&#125; 2.4Lambda表达式练习2【应用】 练习描述 有参无返回值抽象方法的练习 操作步骤 定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s); 定义一个测试类(FlyableDemo)，在测试类中提供两个方法 一个方法是：useFlyable(Flyable f) 一个方法是主方法，在主方法中调用useFlyable方法 示例代码 1234567891011121314151617181920212223242526272829public interface Flyable &#123; void fly(String s);&#125;public class FlyableDemo &#123; public static void main(String[] args) &#123; //在主方法中调用useFlyable方法 //匿名内部类 useFlyable(new Flyable() &#123; @Override public void fly(String s) &#123; System.out.println(s); System.out.println(\"飞机自驾游\"); &#125; &#125;); System.out.println(\"--------\"); //Lambda useFlyable((String s) -&gt; &#123; System.out.println(s); System.out.println(\"飞机自驾游\"); &#125;); &#125; private static void useFlyable(Flyable f) &#123; f.fly(\"风和日丽，晴空万里\"); &#125;&#125; 2.5Lambda表达式练习3【应用】 练习描述 有参有返回值抽象方法的练习 操作步骤 定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y); 定义一个测试类(AddableDemo)，在测试类中提供两个方法 一个方法是：useAddable(Addable a) 一个方法是主方法，在主方法中调用useAddable方法 示例代码 123456789101112131415161718public interface Addable &#123; int add(int x,int y);&#125;public class AddableDemo &#123; public static void main(String[] args) &#123; //在主方法中调用useAddable方法 useAddable((int x,int y) -&gt; &#123; return x + y; &#125;); &#125; private static void useAddable(Addable a) &#123; int sum = a.add(10, 20); System.out.println(sum); &#125;&#125; 2.6Lambda表达式的省略模式【应用】 省略的规则 参数类型可以省略。但是有多个参数的情况下，不能只省略一个 如果参数有且仅有一个，那么小括号可以省略 如果代码块的语句只有一条，可以省略大括号和分号，和return关键字 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142public interface Addable &#123; int add(int x, int y);&#125;public interface Flyable &#123; void fly(String s);&#125;public class LambdaDemo &#123; public static void main(String[] args) &#123;// useAddable((int x,int y) -&gt; &#123;// return x + y;// &#125;); //参数的类型可以省略 useAddable((x, y) -&gt; &#123; return x + y; &#125;);// useFlyable((String s) -&gt; &#123;// System.out.println(s);// &#125;); //如果参数有且仅有一个，那么小括号可以省略// useFlyable(s -&gt; &#123;// System.out.println(s);// &#125;); //如果代码块的语句只有一条，可以省略大括号和分号 useFlyable(s -&gt; System.out.println(s)); //如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉 useAddable((x, y) -&gt; x + y); &#125; private static void useFlyable(Flyable f) &#123; f.fly(\"风和日丽，晴空万里\"); &#125; private static void useAddable(Addable a) &#123; int sum = a.add(10, 20); System.out.println(sum); &#125;&#125; 2.7Lambda表达式的使用前提【理解】 使用Lambda必须要有接口 并且要求接口中有且仅有一个抽象方法 2.8Lambda表达式和匿名内部类的区别【理解】 所需类型不同 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类 Lambda表达式：只能是接口 使用限制不同 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式 实现原理不同 匿名内部类：编译之后，产生一个单独的.class字节码文件 Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成","categories":[],"tags":[]},{"title":"13_接口和多态","slug":"26_接口和多态","date":"2020-11-07T15:14:58.000Z","updated":"2020-11-07T15:17:23.142Z","comments":true,"path":"2020/11/07/26_接口和多态/","link":"","permalink":"http://xiaojujing.com/2020/11/07/26_%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81/","excerpt":"1.接口1.1黑马信息管理系统集合改进 (应用) 使用数组容器的弊端 容器长度是固定的，不能根据添加功能自动增长 没有提供用于赠删改查的方法","text":"1.接口1.1黑马信息管理系统集合改进 (应用) 使用数组容器的弊端 容器长度是固定的，不能根据添加功能自动增长 没有提供用于赠删改查的方法 优化步骤 创建新的StudentDao类，OtherStudentDao 创建ArrayList集合容器对象 OtherStudentDao中的方法声明，需要跟StudentDao保持一致 注意：如果不一致，StudentService中的代码就需要进行修改 完善方法（添加、删除、修改、查看） 替换StudentService中的Dao对象 代码实现 OtherStudentDao类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class OtherStudentDao &#123; // 集合容器 private static ArrayList&lt;Student&gt; stus = new ArrayList&lt;&gt;(); static &#123; Student stu1 = new Student(\"heima001\",\"张三\",\"23\",\"1999-11-11\"); Student stu2 = new Student(\"heima002\",\"李四\",\"24\",\"2000-11-11\"); stus.add(stu1); stus.add(stu2); &#125; // 添加学生方法 public boolean addStudent(Student stu) &#123; stus.add(stu); return true; &#125; // 查看学生方法 public Student[] findAllStudent() &#123; Student[] students = new Student[stus.size()]; for (int i = 0; i &lt; students.length; i++) &#123; students[i] = stus.get(i); &#125; return students; &#125; public void deleteStudentById(String delId) &#123; // 1. 查找id在容器中所在的索引位置 int index = getIndex(delId); stus.remove(index); &#125; public int getIndex(String id)&#123; int index = -1; for (int i = 0; i &lt; stus.size(); i++) &#123; Student stu = stus.get(i); if(stu != null &amp;&amp; stu.getId().equals(id))&#123; index = i; break; &#125; &#125; return index; &#125; public void updateStudent(String updateId, Student newStu) &#123; // 1. 查找updateId, 在容器中的索引位置 int index = getIndex(updateId); stus.set(index, newStu); &#125;&#125; StudentService类 12345public class StudentService &#123; // 创建StudentDao (库管) private OtherStudentDao studentDao = new OtherStudentDao(); // 其他方法没有变化,此处省略...&#125; 1.2黑马信息管理系统抽取Dao (应用) 优化步骤 将方法向上抽取，抽取出一个父类 （ BaseStudentDao ） 方法的功能实现在父类中无法给出具体明确，定义为抽象方法 让两个类分别继承 BaseStudentDao ，重写内部抽象方法 代码实现 BaseStudentDao类 123456789101112public abstract class BaseStudentDao &#123; // 添加学生方法 public abstract boolean addStudent(Student stu); // 查看学生方法 public abstract Student[] findAllStudent(); // 删除学生方法 public abstract void deleteStudentById(String delId); // 根据id找索引方法 public abstract int getIndex(String id); // 修改学生方法 public abstract void updateStudent(String updateId, Student newStu);&#125; StudentDao类 123public class StudentDao extends BaseStudentDao &#123; // 其他内容不变,此处省略&#125; OtherStudentDao类 123public class OtherStudentDao extends BaseStudentDao &#123; // 其他内容不变,此处省略&#125; 1.3接口的概述（理解） 接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。 Java中接口存在的两个意义 用来定义规范 用来做功能的拓展 1.4接口的特点（记忆） 接口用关键字interface修饰 1public interface 接口名 &#123;&#125; 类实现接口用implements表示 1public class 类名 implements 接口名 &#123;&#125; 接口不能实例化 ​ 我们可以创建接口的实现类对象使用 接口的子类 ​ 要么重写接口中的所有抽象方法 ​ 要么子类也是抽象类 1.5接口的成员特点（记忆） 成员特点 成员变量 ​ 只能是常量​ 默认修饰符：public static final 构造方法 ​ 没有，因为接口主要是扩展功能的，而没有具体存在 成员方法 ​ 只能是抽象方法 ​ 默认修饰符：public abstract ​ 关于接口中的方法，JDK8和JDK9中有一些新特性，后面再讲解 代码演示 接口 12345public interface Inter &#123; public static final int NUM = 10; public abstract void show();&#125; 实现类 1234567891011class InterImpl implements Inter&#123; public void method()&#123; // NUM = 20; System.out.println(NUM); &#125; public void show()&#123; &#125;&#125; 测试类 12345678910111213public class TestInterface &#123; /* 成员变量: 只能是常量 系统会默认加入三个关键字 public static final 构造方法: 没有 成员方法: 只能是抽象方法, 系统会默认加入两个关键字 public abstract */ public static void main(String[] args) &#123; System.out.println(Inter.NUM); &#125; &#125; 1.6类和接口的关系（记忆） 类与类的关系 ​ 继承关系，只能单继承，但是可以多层继承 类与接口的关系 ​ 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口 接口与接口的关系 ​ 继承关系，可以单继承，也可以多继承 1.7黑马信息管理系统使用接口改进 (应用) 实现步骤 将 BaseStudentDao 改进为一个接口 让 StudentDao 和 OtherStudentDao 去实现这个接口 代码实现 BaseStudentDao接口 123456789101112public interface BaseStudentDao &#123; // 添加学生方法 public abstract boolean addStudent(Student stu); // 查看学生方法 public abstract Student[] findAllStudent(); // 删除学生方法 public abstract void deleteStudentById(String delId); // 根据id找索引方法 public abstract int getIndex(String id); // 修改学生方法 public abstract void updateStudent(String updateId, Student newStu);&#125; StudentDao类 123public class StudentDao implements BaseStudentDao &#123; // 其他内容不变,此处省略&#125; OtherStudentDao类 123public class OtherStudentDao implements BaseStudentDao &#123; // 其他内容不变,此处省略&#125; 1.8黑马信息管理系统解耦合改进 (应用) 实现步骤 创建factory包，创建 StudentDaoFactory（工厂类） 提供 static 修改的 getStudentDao 方法，该方法用于创建StudentDao对象并返回 代码实现 StudentDaoFactory类 12345public class StudentDaoFactory &#123; public static OtherStudentDao getStudentDao()&#123; return new OtherStudentDao(); &#125;&#125; StudentService类 1234567public class StudentService &#123; // 创建StudentDao (库管) // private OtherStudentDao studentDao = new OtherStudentDao(); // 通过学生库管工厂类, 获取库管对象 private OtherStudentDao studentDao = StudentDaoFactory.getStudentDao();&#125; 2.接口组成更新2.1接口组成更新概述【理解】 常量 public static final 抽象方法 public abstract 默认方法(Java 8) 静态方法(Java 8) 私有方法(Java 9) 2.2接口中默认方法【应用】 格式 public default 返回值类型 方法名(参数列表) { } 作用 解决接口升级的问题 范例 12public default void show3() &#123; &#125; 注意事项 默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字 public可以省略，default不能省略 如果实现了多个接口，多个接口中存在相同的方法声明，子类就必须对该方法进行重写 2.3接口中静态方法【应用】 格式 public static 返回值类型 方法名(参数列表) { } 范例 12public static void show() &#123;&#125; 注意事项 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略 2.4接口中私有方法【应用】 私有方法产生原因 Java 9中新增了带方法体的私有方法，这其实在Java 8中就埋下了伏笔：Java 8允许在接口中定义带方法体的默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java 9增加私有方法的必然性 定义格式 格式1 private 返回值类型 方法名(参数列表) { } 范例1 12private void show() &#123; &#125; 格式2 private static 返回值类型 方法名(参数列表) { } 范例2 12private static void method() &#123; &#125; 注意事项 默认方法可以调用私有的静态方法和非静态方法 静态方法只能调用私有的静态方法 3.多态3.1多态的概述（记忆） 什么是多态 ​ 同一个对象，在不同时刻表现出来的不同形态 多态的前提 要有继承或实现关系 要有方法的重写 要有父类引用指向子类对象 代码演示 123456789101112131415161718192021222324252627282930class Animal &#123; public void eat()&#123; System.out.println(\"动物吃饭\"); &#125;&#125;class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125;public class Test1Polymorphic &#123; /* 多态的前提: 1. 要有(继承 \\ 实现)关系 2. 要有方法重写 3. 要有父类引用, 指向子类对象 */ public static void main(String[] args) &#123; // 当前事物, 是一只猫 Cat c = new Cat(); // 当前事物, 是一只动物 Animal a = new Cat(); a.eat(); &#125;&#125; 3.2多态中的成员访问特点（记忆） 成员访问特点 成员变量 ​ 编译看父类，运行看父类 成员方法 ​ 编译看父类，运行看子类 代码演示 123456789101112131415161718192021222324252627282930class Fu &#123; int num = 10; public void method()&#123; System.out.println(\"Fu.. method\"); &#125;&#125;class Zi extends Fu &#123; int num = 20; public void method()&#123; System.out.println(\"Zi.. method\"); &#125;&#125;public class Test2Polymorpic &#123; /* 多态的成员访问特点: 成员变量: 编译看左边 (父类), 运行看左边 (父类) 成员方法: 编译看左边 (父类), 运行看右边 (子类) */ public static void main(String[] args) &#123; Fu f = new Zi(); System.out.println(f.num); f.method(); &#125;&#125; 3.3多态的好处和弊端（记忆） 好处 ​ 提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作 弊端 ​ 不能使用子类的特有成员 3.4多态中的转型（应用） 向上转型 ​ 父类引用指向子类对象就是向上转型 向下转型 ​ 格式：子类型 对象名 = (子类型)父类引用; 代码演示 123456789101112131415161718192021222324252627282930313233class Fu &#123; public void show()&#123; System.out.println(\"Fu..show...\"); &#125;&#125;class Zi extends Fu &#123; @Override public void show() &#123; System.out.println(\"Zi..show...\"); &#125; public void method()&#123; System.out.println(\"我是子类特有的方法, method\"); &#125;&#125;public class Test3Polymorpic &#123; public static void main(String[] args) &#123; // 1. 向上转型 : 父类引用指向子类对象 Fu f = new Zi(); f.show(); // 多态的弊端: 不能调用子类特有的成员 // f.method(); // A: 直接创建子类对象 // B: 向下转型 // 2. 向下转型 : 从父类类型, 转换回子类类型 Zi z = (Zi) f; z.method(); &#125;&#125; 3.5多态中转型存在的风险和解决方案 (应用) 风险 如果被转的引用类型变量,对应的实际类型和目标类型不是同一种类型,那么在转换的时候就会出现ClassCastException 解决方案 关键字 instanceof 使用格式 变量名 instanceof 类型 通俗的理解：判断关键字左边的变量，是否是右边的类型，返回boolean类型结果 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142abstract class Animal &#123; public abstract void eat();&#125;class Dog extends Animal &#123; public void eat() &#123; System.out.println(\"狗吃肉\"); &#125; public void watchHome()&#123; System.out.println(\"看家\"); &#125;&#125;class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125;public class Test4Polymorpic &#123; public static void main(String[] args) &#123; useAnimal(new Dog()); useAnimal(new Cat()); &#125; public static void useAnimal(Animal a)&#123; // Animal a = new Dog(); // Animal a = new Cat(); a.eat(); //a.watchHome();// Dog dog = (Dog) a;// dog.watchHome(); // ClassCastException 类型转换异常 // 判断a变量记录的类型, 是否是Dog if(a instanceof Dog)&#123; Dog dog = (Dog) a; dog.watchHome(); &#125; &#125;&#125; 3.6黑马信息管理系统多态改进 (应用) 实现步骤 StudentDaoFactory类中方法的返回值定义成父类类型BaseStudentDao StudentService中接收方法返回值的类型定义成父类类型BaseStudentDao 代码实现 StudentDaoFactory类 12345public class StudentDaoFactory &#123; public static BaseStudentDao getStudentDao()&#123; return new OtherStudentDao(); &#125;&#125; StudentService类 1234567public class StudentService &#123; // 创建StudentDao (库管) // private OtherStudentDao studentDao = new OtherStudentDao(); // 通过学生库管工厂类, 获取库管对象 private BaseStudentDao studentDao = StudentDaoFactory.getStudentDao();&#125;","categories":[],"tags":[]},{"title":"25_继承","slug":"25_继承","date":"2020-11-06T15:46:27.122Z","updated":"2021-01-12T02:54:27.943Z","comments":true,"path":"2020/11/06/25_继承/","link":"","permalink":"http://xiaojujing.com/2020/11/06/25_%E7%BB%A7%E6%89%BF/","excerpt":"第一章 Redis基础课程计划","text":"第一章 Redis基础课程计划 1. Redis 入 门 （了解） （操作） 2. 数据类型 （重点） （操作） （理解） 3. 常用指令 （操作） 4. Jedis （重点） （操作） 5. 持 久 化 （重点） （理解） 6. 数据删除与淘汰策略 （理解） 7. 主从复制 （重点） （操作） （理解） 8. 哨 兵 （重点） （操作） （理解） 9. Cluster集群方案 （重点） （操作） （理解） 10. 企业级缓存解决方案 （重点） （理解） 11. 性能指标监控 （了解） 学习目标：目标1：能够说出NoSQL的概念，redis的应用场景，能够完成redis的下载安装与启动以及一些常用的配置 目标2：能够说出redis常用的5种数据类型，对应这些数据类型的基本操作，应用场景及对应的解决方案 目标3：能够说出redis中常用的一些基本指令 目标4：能够使用jedis完成客户端应用程序的开发 目标5：能够说出redis数据持久化的两种方式，各自相关的操作配置及指令，以及两种方式的优缺点比较 1. Redis 简介在这个部分，我们将学习以下3个部分的内容，分别是： ◆ Redis 简介（NoSQL概念、Redis概念） ◆ Redis 的下载与安装 ◆ Redis 的基本操作 1.1 NoSQL概念1.1.1 问题现象在讲解NoSQL的概念之前呢，我们先来看一个现象： （1）问题现象 每年到了过年期间，大家都会自觉自发的组织一场活动，叫做春运！以前我们买票都是到火车站排队，后来呢有了12306，有了他以后就更方便了，我们可以在网上买票，但是带来的问题，大家也很清楚，春节期间买票进不去，进去了刷不着票。什么原因呢，人太多了！ 除了这种做铁路的，它系统做的不专业以外，还有马爸爸做的淘宝，它面临一样的问题。淘宝也崩，也是用户量太大！作为我们整个电商界的东哥来说，他第一次做图书促销的时候，也遇到了服务器崩掉的这样一个现象，原因同样是因为用户量太大！ （2）现象特征 再来看这几个现象，有两个非常相似的特征： 第一，用户比较多，海量用户 第二，高并发 这两个现象出现以后，对应的就会造成我们的服务器瘫痪。核心本质是什么呢？其实并不是我们的应用服务器，而是我们的关系型数据库。关系型数据库才是最终的罪魁祸首！ （3）造成原因 什么样的原因导致的整个系统崩掉的呢： 1.性能瓶颈：磁盘IO性能低下 关系型数据库菜存取数据的时候和读取数据的时候他要走磁盘IO。磁盘这个性能本身是比较低的。 2.扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群 我们说关系型数据库，它里面表与表之间的关系非常复杂，不知道大家能不能想象一点，就是一张表，通过它的外键关联了七八张表，这七八张表又通过她的外件，每张又关联了四五张表。你想想，查询一下，你要想拿到数据，你就要从A到B、B到C、C到D的一直这么关联下去，最终非常影响查询的效率。同时，你想扩展下，也很难! （4）解决思路 面对这样的现象，我们要想解决怎么版呢。两方面： 一，降低磁盘IO次数，越低越好。 二，去除数据间关系，越简单越好。 降低磁盘IO次数，越低越好，怎么搞？我不用你磁盘不就行了吗？于是，内存存储的思想就提出来了，我数据不放到你磁盘里边，放内存里，这样是不是效率就高了。 第二，你的数据关系很复杂，那怎么办呢？干脆简单点，我断开你的关系，我不存关系了，我只存数据，这样不就没这事了吗？ 把这两个特征一合并一起，就出来了一个新的概念：NoSQL 1.1.2 NoSQL的概念（1）概念 NoSQL：即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。 作用：应对基于海量用户和海量数据前提下的数据处理问题。 他说这句话说的非常客气，什么意思呢？就是我们数据存储要用SQL，但是呢可以不仅仅用SQL，还可以用别的东西，那别的东西叫什么呢？于是他定义了一句话叫做NoSQL。这个意思就是说我们存储数据，可以不光使用SQL，我们还可以使用非SQL的这种存储方案，这就是所谓的NoSQL。 （2）特征 可扩容，可伸缩。SQL数据关系过于复杂，你扩容一下难度很高，那我们Nosql 这种的，不存关系，所以它的扩容就简单一些。 大数据量下高性能。包数据非常多的时候，它的性能高，因为你不走磁盘IO，你走的是内存，性能肯定要比磁盘IO的性能快一些。 灵活的数据模型、高可用。他设计了自己的一些数据存储格式，这样能保证效率上来说是比较高的，最后一个高可用，我们等到集群内部分再去它！ （3）常见 Nosql 数据库 目前市面上常见的Nosql产品：Redis、memcache、HBase、MongoDB （4）应用场景-电商为例 我们以电商为例，来看一看他在这里边起到的作用。 第一类，在电商中我们的基础数据一定要存储起来，比如说商品名称，价格，生产厂商，这些都属于基础数据，这些数据放在MySQL数据库。 第二类，我们商品的附加信息，比如说，你买了一个商品评价了一下，这个评价它不属于商品本身。就像你买一个苹果，“这个苹果很好吃”就是评论，但是你能说很好吃是这个商品的属性嘛？不能这么说，那只是一个人对他的评论而已。这一类数据呢，我们放在另外一个地方，我们放到MongoDB。它也可以用来加快我们的访问，他属于NoSQL的一种。 第三，图片内的信息。注意这种信息相对来说比较固定，他有专用的存储区，我们一般用文件系统来存储。至于是不是分布式，要看你的系统的一个整个 瓶颈 了？如果说你发现你需要做分布式，那就做，不需要的话，一台主机就搞定了。 第四，搜索关键字。为了加快搜索，我们会用到一些技术，有些人可能了解过，像分ES、Lucene、solr都属于搜索技术。那说的这么热闹，我们的电商解决方案中还没出现我们的redis啊！注意第五类信息。 第五，热点信息。访问频度比较高的信息，这种东西的第二特征就是它具有波段性。换句话说他不是稳定的，它具有一个时效性的。那么这类信息放哪儿了，放到我们的redis这个解决方案中来进行存储。 具体的我们从我们的整个数据存储结构的设计上来看一下。 我们的基础数据都存MySQL,在它的基础之上，我们把它连在一块儿，同时对外提供服务。向上走，有一些信息加载完以后,要放到我们的MongoDB中。还有一类信息，我们放到我们专用的文件系统中（比如图片），就放到我们的这个搜索专用的，如Lucene、solr及集群里边，或者用ES的这种技术里边。那么剩下来的热点信息，放到我们的redis里面。 1.2 Redis概念1.2.1 redis概念概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。 特征： （1）数据间没有必然的关联关系； （2）内部采用单线程机制进行工作； （3）高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。 （4）多数据类型支持 字符串类型，string list 列表类型，hash set 散列类型，zset/sorted_set 集合类型 有序集合类型 （5）支持持久化，可以进行数据灾难恢复 1.2.2 redis的应用场景（1）为热点数据加速查询（主要场景）。如热点商品、热点新闻、热点资讯、推广类等高访问量信息等。 （2）即时信息查询。如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等。 （3）时效性信息控制。如验证码控制、投票控制等。 （4）分布式数据共享。如分布式集群架构中的 session 分离消息队列. 1.3 Redis 的下载与安装后期所有资料分4中不同色块显示，详情如下： 1.3.1 Redis 的下载与安装本课程所示，均基于Center OS7安装Redis。 （1)下载Redis 下载安装包： 1wget http://download.redis.io/releases/redis-5.0.0.tar.gz 解压安装包： 1tar –xvf redis-5.0.0.tar.gz 编译（在解压的目录中执行）： 1make 安装（在解压的目录中执行）： 1make install （2）安装 Redis redis-server，服务器启动命令 客户端启动命令 redis-cli，redis核心配置文件 redis.conf，RDB文件检查工具（快照持久化文件） redis-check-dump，AOF文件修复工具 redis-check-aof 1.4 Redis服务器启动1.4.1 Redis服务器启动启动服务器——参数启动 1redis-server [--port port] 范例 1redis-server --port 6379 启动服务器——配置文件启动 1redis-server config_file_name 范例 1redis-server redis.conf 1.4.2 Redis客户端启动启动客户端 1redis-cli [-h host] [-p port] 范 例 1redis-cli –h 61.129.65.248 –p 6384 注意：服务器启动指定端口使用的是–port，客户端启动指定端口使用的是-p。-的数量不同。 1.4.3 Redis基础环境设置约定创建配置文件存储目录 1mkdir conf 创建服务器文件存储目录（包含日志、数据、临时配置文件等） 1mkdir data 创建快速访问链接 1ln -s redis-5.0.0 redis 1.5 配置文件启动与常用配置1.5.1 服务器端设定设置服务器以守护进程的方式运行，开启后服务器控制台中将打印服务器运行信息（同日志内容相同） 1daemonize yes|no 绑定主机地址 1bind ip 设置服务器端口 1port port 设置服务器文件保存地址 1dir path 1.5.2 客户端配置 服务器允许客户端连接最大数量，默认0，表示无限制。当客户端连接到达上限后，Redis会拒绝新的连接 1maxclients count 客户端闲置等待最大时长，达到最大值后关闭对应连接。如需关闭该功能，设置为 0 1timeout seconds 1.5.3 日志配置设置服务器以指定日志记录级别 1loglevel debug|verbose|notice|warning 日志记录文件名 1logfile filename 注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度。 1.6 Redis基本操作1.6.1 命令行模式工具使用思考功能性命令 帮助信息查阅 退出指令 清除屏幕信息 1.6.2 信息读写设置 key，value 数据 1set key value 范例 1set name itheima 根据 key 查询对应的 value，如果不存在，返回空（nil） 1get key 范例 1get name 1.6.3 帮助信息获取命令帮助文档 1help [command] 范例 1help set 获取组中所有命令信息名称 1help [@group-name] 范例 1help @string 1.6.4 退出命令行客户端模式 退出客户端 12quitexit 快捷键 1Ctrl+C 1.6.4 redis入门总结到这里，Redis 入门的相关知识，我们就全部学习完了，再来回顾一下，这个部分我们主要讲解了哪些内容呢？ 首先，我们对Redis进行了一个简单介绍，包括NoSQL的概念、Redis的概念等。 然后，我们介绍了Redis 的下载与安装。包括下载与安装、服务器与客户端启动、以及相关配置文件（3类）。 最后，我们介绍了Redis 的基本操作。包括数据读写、退出与帮助信息获取。 2. 数据类型在这个部分，我们将学习一共要学习三大块内容，首先需要了解一下数据类型，接下来将针对着我们要学习的数据类型进行逐一的讲解，如string、hash、list、set等，最后我们通过一个案例来总结前面的数据类型的使用场景。 2.1 数据存储类型介绍2.1.1 业务数据的特殊性在讲解数据类型之前，我们得先思考一个问题，数据类型既然是用来描述数据的存储格式的，如果你不知道哪些数据未来会进入到我们来的redis中，那么对应的数据类型的选择，你就会出现问题，我们一块来看一下： （1）原始业务功能设计 秒杀。他这个里边数据变化速度特别的快，访问量也特别的高，用户大量涌入以后都会针对着一部分数据进行操作，这一类要记住。 618活动。对于我们京东的618活动、以及天猫的双11活动，相信大家不用说都知道这些数据一定要进去，因为他们的访问频度实在太高了。 排队购票。我们12306的票务信息。这些信息在原始设计的时候，他们就注定了要进redis。 （2）运营平台监控到的突发高频访问数据 此类平台临时监控到的这些数据，比如说现在出来的一个八卦的信息，这个新闻一旦出现以后呢，顺速的被围观了，那么这个时候，这个数据就会变得访量特别高，那么这类信息也要进入进去。 （3）高频、复杂的统计数据 在线人数。比如说直播现在很火，直播里边有很多数据，例如在线人数。进一个人出一个人，这个数据就要跳动，那么这个访问速度非常的快，而且访量很高，并且它里边有一个复杂的数据统计，在这里这种信息也要进入到我们的redis中。 投票排行榜。投票投票类的信息他的变化速度也比较快，为了追求一个更快的一个即时投票的名次变化，这种数据最好也放到redis中。 2.1.2 Redis 数据类型(5种常用)基于以上数据特征我们进行分析，最终得出来我们的Redis中要设计5种 数据类型： string、hash、list、set、sorted_set/zset（应用性较低） 2.2 string数据类型在学习第一个数据类型之前，先给大家介绍一下，在随后这部分内容的学习过程中，我们每一种数据类型都分成三块来讲：首先是讲下它的基本操作，接下来讲一些它的扩展操作，最后我们会去做一个小的案例分析。 2.2.1Redis 数据存储格式在学习string这个数据形式之前，我们先要明白string到底是修饰什么的。我们知道redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储。 对于这种结构来说，我们用来存储数据一定是一个值前面对应一个名称。我们通过名称来访问后面的值。按照这种形势，我们可以对出来我们的存储格式。前面这一部分我们称为key。后面的一部分称为value，而我们的数据类型，他一定是修饰value的。 数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串。 2.2.2 string 类型（1）存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型。 string，他就是存一个字符串儿，注意是value那一部分是一个字符串，它是redis中最基本、最简单的存储数据的格式。 （2）存储数据的格式：一个存储空间保存一个数据 每一个空间中只能保存一个字符串信息，这个信息里边如果是存的纯数字，他也能当数字使用，我们来看一下，这是我们的数据的存储空间。 （3）存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用. 一个key对一个value，而这个itheima就是我们所说的string类型，当然它也可以是一个纯数字的格式。 2.2.3 string 类型数据的基本操作（1）基础指令 添加/修改数据添加/修改数据 1set key value 获取数据 1get key 删除数据 1del key 判定性添加数据 1setnx key value 添加/修改多个数据 1mset key1 value1 key2 value2 … 获取多个数据 1mget key1 key2 … 获取数据字符个数（字符串长度） 1strlen key 追加信息到原始信息后部（如果原始信息存在就追加，否则新建） 1append key value （2）单数据操作与多数据操作的选择之惑 即set 与mset的关系。这对于这两个操作来说，没有什么你应该选哪个，而是他们自己的特征是什么，你要根据这个特征去比对你的业务，看看究竟适用于哪个。 假如说这是我们现在的服务器，他要向redis要数据的话，它会发出一条指令。那么当这条指令发过来的时候，比如说是这个set指令过来，那么它会把这个结果返回给你，这个时候我们要思考这里边一共经过了多长时间。 首先，发送set指令要时间，这是网络的一个时间，接下来redis要去运行这个指令要消耗时间，最终把这个结果返回给你又有一个时间，这个时间又是一个网络的时间，那我们可以理解为：一个指令发送的过程中需要消耗这样的时间. 但是如果说现在不是一条指令了，你要发3个set的话，还要多长时间呢？对应的发送时间要乘3了，因为这是三个单条指令,而运行的操作时间呢，它也要乘3了，但最终返回的也要发3次，所以这边也要乘3。 于是我们可以得到一个结论：单指令发3条它需要的时间，假定他们两个一样，是6个网络时间加3个处理时间，如果我们把它合成一个mset呢，我们想一想。 假如说用多指令发3个指令的话，其实只需要发一次就行了。这样我们可以得到一个结论，多指令发3个指令的话，其实它是两个网络时间加上3个redis的操作时间，为什么这写一个小加号呢，就是因为毕竟发的信息量变大了，所以网络时间有可能会变长。 那么通过这张图，你就可以得到一个结论，我们单指令和多指令他们的差别就在于你发送的次数是多还是少。当你影响的数据比较少的时候，你可以用单指令，也可以用多指令。但是一旦这个量大了，你就要选择多指令了，他的效率会高一些。 2.3 string 类型数据的扩展操作2.3.1 string 类型数据的扩展操作下面我们来看一string的扩展操作，分成两大块：一块是对数字进行操作的，第二块是对我们的key的时间进行操作的。 设置数值数据增加指定范围的值 123incr keyincrby key incrementincrbyfloat key increment 设置数值数据减少指定范围的值 12decr keydecrby key increment 设置数据具有指定的生命周期 12setex key seconds valuepsetex key milliseconds value 2.3.2 string 类型数据操作的注意事项(1)数据操作不成功的反馈与数据正常操作之间的差异 表示运行结果是否成功 (integer) 0 → false 失败 (integer) 1 → true 成功 表示运行结果值 (integer) 3 → 3 3个 (integer) 1 → 1 1个 (2)数据未获取到时，对应的数据为（nil），等同于null (3)数据最大存储量：512MB (4)string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算 (5)按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错9223372036854775807（java中Long型数据最大值，Long.MAX_VALUE） (6)redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响. 2.4string应用场景与key命名约定2.4.1 应用场景它的应用场景在于：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量。 我们来思考一下：这些信息是不是你进入大V的页面儿以后就要读取这写信息的啊，那这种信息一定要存储到我们的redis中，因为他的访问量太高了！那这种数据应该怎么存呢？我们来一块儿看一下方案！ 2.4.2 解决方案（1）在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可。 123eg: user:id:3506728370:fans → 12210947eg: user:id:3506728370:blogs → 6164eg: user:id:3506728370:focuses → 83 （2）也可以使用json格式保存数据 1eg: user:id:3506728370 → &#123;“fans”：12210947，“blogs”：6164，“ focuses ”：83 &#125; （3） key 的设置约定 数据库中的热点数据key命名惯例 表名 主键名 主键值 字段名 eg1： order id 29437595 name eg2： equip id 390472345 type eg3： news id 202004150 title 2.5 hash的基本操作下面我们来学习第二个数据类型hash。 2.5.1 数据存储的困惑对象类数据的存储如果具有较频繁的更新需求操作会显得笨重！ 在正式学习之前，我们先来看一个关于数据存储的困惑： 比如说前面我们用以上形式存了数据，如果我们用单条去存的话，它存的条数会很多。但如果我们用json格式，它存一条数据就够了。问题来了，假如说现在粉丝数量发生变化了，你要把整个值都改了。但是用单条存的话就不存在这个问题，你只需要改其中一个就行了。这个时候我们就想，有没有一种新的存储结构，能帮我们解决这个问题呢。 我们一块儿来分析一下： 如上图所示：单条的话是对应的数据在后面放着。仔细观察：我们看左边是不是长得都一模一样啊，都是对应的表名、ID等的一系列的东西。我们可以将右边红框中的这个区域给他封起来。 那如果要是这样的形式的话，如下图，我们把它一合并，并把右边的东西给他变成这个格式，这不就行了吗？ 这个图其实大家并不陌生，第一，你前面学过一个东西叫hashmap不就这格式吗？第二，redis自身不也是这格式吗？那是什么意思呢？注意，这就是我们要讲的第二种格式，hash。 在右边对应的值，我们就存具体的值，那左边儿这就是我们的key。问题来了，那中间的这一块叫什么呢？这个东西我们给他起个名儿，叫做field字段。那么右边儿整体这块儿空间我们就称为hash，也就是说hash是存了一个key value的存储空间。 2.5.2 hash 类型新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息 需要的存储结构：一个存储空间保存多个键值对数据 hash类型：底层使用哈希表结构实现数据存储 如上图所示，这种结构叫做hash，左边一个key，对右边一个存储空间。这里要明确一点，右边这块儿存储空间叫hash，也就是说hash是指的一个数据类型，他指的不是一个数据，是这里边的一堆数据，那么它底层呢，是用hash表的结构来实现的。 值得注意的是： 如果field数量较少，存储结构优化为类数组结构 如果field数量较多，存储结构使用HashMap结构 2.5.3 hash 类型数据的基本操作添加/修改数据 1hset key field value 获取数据 12hget key fieldhgetall key 删除数据 1hdel key field1 [field2] 设置field的值，如果该field存在则不做任何操作 1hsetnx key field value 添加/修改多个数据 1hmset key field1 value1 field2 value2 … 获取多个数据 1hmget key field1 field2 … 获取哈希表中字段的数量 1hlen key 获取哈希表中是否存在指定的字段 1hexists key field 2.6 hash的拓展操作在看完hash的基本操作后，我们再来看他的拓展操作，他的拓展操作相对比较简单： 2.6.1 hash 类型数据扩展操作获取哈希表中所有的字段名或字段值 12hkeys keyhvals key 设置指定字段的数值数据增加指定范围的值 12hincrby key field incrementhincrbyfloat key field increment 2.6.2 hash类型数据操作的注意事项(1)hash类型中value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）。 (2）每个 hash 可以存储 232 - 1 个键值对hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计 的，切记不可滥用，更不可以将hash作为对象列表使用。 (3)hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈。 2.7 hash应用场景2.7.1 应用场景双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，每种商品抢购上限1000 张。 也就是商家有了，商品有了，数量有了。最终我们的用户买东西就是在改变这个数量。那你说这个结构应该怎么存呢？对应的商家的ID作为key，然后这些充值卡的ID作为field，最后这些数量作为value。而我们所谓的操作是其实就是increa这个操作，只不过你传负值就行了。看一看对应的解决方案： 2.7.2 解决方案以商家id作为key 将参与抢购的商品id作为field 将参与抢购的商品数量作为对应的value 抢购时使用降值的方式控制产品数量 注意：实际业务中还有超卖等实际问题，这里不做讨论 2.8 list基本操作前面我们存数据的时候呢，单个数据也能存，多个数据也能存，但是这里面有一个问题，我们存多个数据用hash的时候它是没有顺序的。我们平时操作，实际上数据很多情况下都是有顺序的，那有没有一种能够用来存储带有顺序的这种数据模型呢，list就专门来干这事儿。 2.8.1 list 类型数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分 需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序 list类型：保存多个数据，底层使用双向链表存储结构实现 先来通过一张图，回忆一下顺序表、链表、双向链表。 list对应的存储结构是什么呢？里边存的这个东西是个列表，他有一个对应的名称。就是key存一个list的这样结构。对应的基本操作，你其实是可以想到的。 来看一下，因为它是双向的，所以他左边右边都能操作，它对应的操作结构两边都能进数据。这就是链表的一个存储结构。往外拿数据的时候怎么拿呢？通常是从一端拿，当然另一端也能拿。如果两端都能拿的话，这就是个双端队列，两边儿都能操作。如果只能从一端进一端出，这个模型咱们前面了解过，叫做栈。 2.8.2 list 类型数据基本操作最后看一下他的基本操作 添加/修改数据 12lpush key value1 [value2] ……rpush key value1 [value2] …… 获取数据 123lrange key start stoplindex key indexllen key 获取并移除数据 12lpop keyrpop key 2.9 list扩展操作2.9.1 list 类型数据扩展操作移除指定数据 1lrem key count value 规定时间内获取并移除数据 123blpop key1 [key2] timeoutbrpop key1 [key2] timeoutbrpoplpush source destination timeout 2.9.2 list 类型数据操作注意事项（1）list中保存的数据都是string类型的，数据总容量是有限的，最多232 - 1 个元素(4294967295)。 （2）list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作 （3）获取全部数据操作结束索引设置为-1 （4）list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载 2.10 list 应用场景2.10.1 应用场景企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？ 假如现在你有多台服务器，每一台服务器都会产生它的日志，假设你是一个运维人员，你想看它的操作日志，你怎么看呢？打开A机器的日志看一看，打开B机器的日志再看一看吗？这样的话你会可能会疯掉的！因为左边看的有可能它的时间是11:01，右边11:02，然后再看左边11:03，它们本身是连续的，但是你在看的时候就分成四个文件了，这个时候你看起来就会很麻烦。能不能把他们合并呢？答案是可以的！怎么做呢？建立起redis服务器。当他们需要记日志的时候，记在哪儿,全部发给redis。等到你想看的时候，通过服务器访问redis获取日志。然后得到以后，就会得到一个完整的日志信息。那么这里面就可以获取到完整的日志了，依靠什么来实现呢？就依靠我们的list的模型的顺序来实现。进来一组数据就往里加，谁先进来谁先加进去，它是有一定的顺序的。 2.10.2 解决方案依赖list的数据具有顺序的特征对信息进行管理 使用队列模型解决多路信息汇总合并的问题 使用栈模型解决最新消息的问题 2.11 set 基本操作2.11.1 set类型新的存储需求：存储大量的数据，在查询方面提供更高的效率 需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询 set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的 通过这个名称，大家也基本上能够认识到和我们Java中的set完全一样。我们现在要存储大量的数据，并且要求提高它的查询效率。用list这种链表形式，它的查询效率是不高的，那怎么办呢？这时候我们就想，有没有高效的存储机制。其实前面咱讲Java的时候说过hash表的结构就非常的好，但是这里边我们已经有hash了，他做了这么一个设定，干嘛呢，他把hash的存储空间给改一下，右边你原来存数据改掉,全部存空，那你说数据放哪儿了？放到原来的filed的位置，也就在这里边存真正的值，那么这个模型就是我们的set 模型。 set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。 看一下它的整个结构： 2.11.2 set类型数据的基本操作添加数据 1sadd key member1 [member2] 获取全部数据 1smembers key 删除数据 1srem key member1 [member2] 获取集合数据总量 1scard key 判断集合中是否包含指定数据 1sismember key member 随机获取集合中指定数量的数据 1srandmember key [count] 随机获取集中的某个数据并将该数据移除集合 1spop key [count] 2.12 set 类型数据的扩展操作2.12.1 set 类型数据的扩展操作求两个集合的交、并、差集 123sinter key1 [key2 …] sunion key1 [key2 …] sdiff key1 [key2 …] 求两个集合的交、并、差集并存储到指定集合中 123sinterstore destination key1 [key2 …] sunionstore destination key1 [key2 …] sdiffstore destination key1 [key2 …] 将指定数据从原始集合中移动到目标集合中 1smove source destination member 通过下面一张图回忆一下交、并、差 2.12.2 set 类型数据操作的注意事项set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份。 set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间。 2.13 set应用场景2.13.1 set应用场景（1）黑名单 资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术， 快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密进行出售。例如第三方火 车票、机票、酒店刷票代购软件，电商刷评论、刷好评。 同时爬虫带来的伪流量也会给经营者带来错觉，产生错误的决策，有效避免网站被爬虫反复爬取成为每个网站都要考虑的基本问题。在基于技术层面区分出爬虫用户后，需要将此类用户进行有效的屏蔽，这就是黑名单的典型应用。 ps:不是说爬虫一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。 （2）白名单 对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体， 依赖白名单做更为苛刻的访问验证。 2.13.2 解决方案基于经营战略设定问题用户发现、鉴别规则 周期性更新满足规则的用户黑名单，加入set集合 用户行为信息达到后与黑名单进行比对，确认行为去向 黑名单过滤IP地址：应用于开放游客访问权限的信息源 黑名单过滤设备信息：应用于限定访问设备的信息源 黑名单过滤用户：应用于基于访问权限的信息源 2.14 实践案例2.14.1业务场景使用微信的过程中，当微信接收消息后，会默认将最近接收的消息置顶，当多个好友及关注的订阅号同时发 送消息时，该排序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户离线后，再次打开微信时，消息该按照什么样的顺序显示。 我们分析一下： 100这台手机代表你。而200、300、400这三台代表你好友的手机。在这里有一些东西需要交代一下，因为我们每个人的都会对自己的微信中的一些比较重要的人设置会话置顶，将他的那条对话放在最上面。我们假定这个人有两个会话置顶的好友，分别是400和500，而这里边就包含400. 下面呢，我们就来发这个消息，第一个发消息的是300，他发了个消息给100。发完以后，这个东西应该怎么存储呢？在这里面一定要分开，记录置顶的这些人的会话，对应的会话显示顺序和非置顶的一定要分两。 这里面我们创建两个模型，一个是普通的，一个是置顶的，而上面的这个置顶的用户呢，我们用set来存储，因为不重复。而下面这些因为有顺序，很容易想到用list去存储,不然你怎么表达顺序呢？ 那当300发给消息给100以后，这个时候我们先判定你在置顶人群中吗？不在,那好，300的消息对应的顺序就应该放在普通的列表里边。而在这里边，我们把300加进去。第一个数据也就是现在300。 接下来400，发了个消息。判断一下，他是需要置顶的，所以400将进入list的置顶里边放着。当前还没有特殊的地方。 再来200发消息了，和刚才的判定方法一样，先看在不在置顶里，不在的话进普通，然后在普通里边把200加入就行了，OK，到这里目前还没有顺序变化。 接下来200又发消息过来，同一个人给你连发了两条，那这个时候200的消息到达以后，先判断是否在置顶范围，不在，接下来他要放在list普通中，这里你要注意一点，因为这里边已经有200，所以进来以后先干一件事儿，把200杀掉，没有200，然后再把200加进来，那你想一下，现在这个位置顺序是什么呢？就是新的都在右边，对不对？ 还记得我们说list模型，如果是一个双端队列，它是可以两头进两头出。当然我们双端从一头进一头出，这就是栈模型，现在咱们运用的就是list模型中的栈模型。 现在300发消息，先判定他在不在，不在，用普通的队列，接下来按照刚才的操作，不管你里边原来有没有300，我先把300杀掉，没了，200自然就填到300的位置了，他现在是list里面唯一一个，然后让300进来，注意是从右侧进来的，那么现在300就是最新的。 那么到这里呢，我们让100来读取消息。你觉得这个消息顺序应该是什么样的？首先置顶的400有一个，他跑在最上面，然后list普通如果出来的话，300是最新的消息，而200在他后面的。用这种形式，我们就可以做出来他的消息顺序来。 2.14.2 解决方案看一下最终的解决方案： 依赖list的数据具有顺序的特征对消息进行管理，将list结构作为栈使用 置顶与普通会话分别创建独立的list分别管理 当某个list中接收到用户消息后，将消息发送方的id从list的一侧加入list（此处设定左侧） 多个相同id发出的消息反复入栈会出现问题，在入栈之前无论是否具有当前id对应的消息，先删除对应id 推送消息时先推送置顶会话list，再推送普通会话list，推送完成的list清除所有数据消息的数量，也就是微信用户对话数量采用计数器的思想另行记录，伴随list操作同步更新 2.14.3 数据类型总结总结一下，在整个数据类型的部分，我们主要介绍了哪些内容： 首先我们了解了一下数据类型，接下来针对着我们要学习的数据类型，进行逐一讲解了string、hash、list、set等，最后通过一个案例总结了一下前面的数据类型的使用场景。 3. 常用指令在这部分中呢，我们家学习两个知识，第一个是key的常用指令，第二个是数据库的常用指令。和前面我们学数据类型做一下区分，前面你学的那些指令呢，都是针对某一个数据类型操作的，现在学的都是对所有的操作的，来看一下，我们在学习Key的操作的时候，我们先想一下的操作我们应该学哪些东西: 3.1 key 操作分析3.1.1 key应该设计哪些操作？key是一个字符串，通过key获取redis中保存的数据 对于key自身状态的相关操作，例如：删除，判定存在，获取类型等 对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等 对于key快速查询操作，例如：按指定策略查询key 3.1.2 key 基本操作删除指定key 1del key 获取key是否存在 1exists key 获取key的类型 1type key 3.1.3 拓展操作 排序 1sort 改名 12rename key newkeyrenamenx key newkey 3.1.3 key 扩展操作（时效性控制）为指定key设置有效期 1234expire key secondspexpire key millisecondsexpireat key timestamppexpireat key milliseconds-timestamp 获取key的有效时间 12ttl keypttl key 切换key从时效性转换为永久性 1persist key 3.1.4 key 扩展操作（查询模式）查询key 1keys pattern 查询模式规则 *匹配任意数量的任意符号 ? 配合一个任意符号 [] 匹配一个指定符号 123456keys * keys 查询所有it* keys 查询所有以it开头*heima 查询所有以heima结尾keys ??heima 查询所有前面两个字符任意，后面以heima结尾 查询所有以keys user:? user:开头，最后一个字符任意keys u[st]er:1 查询所有以u开头，以er:1结尾，中间包含一个字母，s或t 3.2 数据库指令3.2.1 key 的重复问题在这个地方我们来讲一下数据库的常用指令，在讲这个东西之前，我们先思考一个问题： 假如说你们十个人同时操作redis，会不会出现key名字命名冲突的问题。 一定会，为什么?因为你的key是由程序而定义的。你想写什么写什么，那在使用的过程中大家都在不停的加，早晚有一天他会冲突的。 redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key。 那这个问题我们要不要解决？要！怎么解决呢？我们最好把数据进行一个分类，除了命名规范我们做统一以外，如果还能把它分开，这样是不是冲突的机率就会小一些了，这就是咱们下面要说的解决方案！ 3.2.2 解决方案redis为每个服务提供有16个数据库，编号从0到15 每个数据库之间的数据相互独立 在对应的数据库中划出一块区域，说他就是几，你就用几那块，同时，其他的这些都可以进行定义，一共是16个，这里边需要注意一点，他们这16个共用redis的内存。没有说谁大谁小，也就是说数字只是代表了一块儿区域，区域具体多大未知。这是数据库的一个分区的一个策略！ 3.2.3 数据库的基本操作切换数据库 1select index 其他操作 1ping 3.2.4 数据库扩展操作数据移动 1move key db 数据总量 1dbsize 数据清除 1flushdb flushall 4. Jedis在学习完redis后，我们现在就要用Java来连接redis了，也就是我们的这一章要学的Jedis了。在这个部分，我们主要讲解以下3个内容： HelloWorld（Jedis版） Jedis简易工具类开发 可视化客户端 4.1 Jedis简介4.1.1 编程语言与redis 对于我们现在的数据来说，它是在我们的redis中，而最终我们是要做程序。那么程序就要和我们的redis进行连接。干什么事情呢？两件事：程序中有数据的时候，我们要把这些数据全部交给redis管理。同时，redis中的数据还能取出来，回到我们的应用程序中。那在这个过程中，在Java与redis之间打交道的这个东西就叫做Jedis.简单说，Jedis就是提供了Java与redis的连接服务的，里边有各种各样的API接口，你可以去调用它。 除了Jedis外，还有没有其他的这种连接服务呢？其实还有很多，了解一下： Java语言连接redis服务 Jedis（SpringData、Redis 、 Lettuce） 其它语言：C 、C++ 、C# 、Erlang、Lua 、Objective-C 、Perl 、PHP 、Python 、Ruby 、Scala 4.1.2 准备工作(1)jar包导入 下载地址：https://mvnrepository.com/artifact/redis.clients/jedis 基于maven 12345&lt;dependency&gt;&lt;groupId&gt;redis.clients&lt;/groupId&gt;&lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; (2)客户端连接redis 连接redis 1Jedis jedis &#x3D; new Jedis(&quot;localhost&quot;, 6379); 操作redis 1jedis.set(&quot;name&quot;, &quot;itheima&quot;); jedis.get(&quot;name&quot;); 关闭redis连接 1jedis.close(); API文档 http://xetorthio.github.io/jedis/ 4.1.3 代码实现创建：com.itheima.JedisTest 123456789101112131415161718192021public class JedisTest &#123; public static void main(String[] args) &#123; //1.获取连接对象 Jedis jedis = new Jedis(\"192.168.40.130\",6379); //2.执行操作 jedis.set(\"age\",\"39\"); String hello = jedis.get(\"hello\"); System.out.println(hello); jedis.lpush(\"list1\",\"a\",\"b\",\"c\",\"d\"); List&lt;String&gt; list1 = jedis.lrange(\"list1\", 0, -1); for (String s:list1 ) &#123; System.out.println(s); &#125; jedis.sadd(\"set1\",\"abc\",\"abc\",\"def\",\"poi\",\"cba\"); Long len = jedis.scard(\"set1\"); System.out.println(len); //3.关闭连接 jedis.close(); &#125;&#125; 4.2 Jedis简易工具类开发前面我们做的程序还是有点儿小问题，就是我们的Jedis对象的管理是我们自己创建的，真实企业开发中是不可能让你去new一个的，那接下来咱们就要做一个工具类，简单来说，就是做一个创建Jedis的这样的一个工具。 4.2.1 基于连接池获取连接JedisPool：Jedis提供的连接池技术 poolConfig:连接池配置对象 host:redis服务地址 port:redis服务端口号 JedisPool的构造器如下： 123public JedisPool(GenericObjectPoolConfig poolConfig, String host, int port) &#123;this(poolConfig, host, port, 2000, (String)null, 0, (String)null);&#125; 4.2.2 封装连接参数创建jedis的配置文件：jedis.properties 1234jedis.host=192.168.40.130 jedis.port=6379 jedis.maxTotal=50 jedis.maxIdle=10 4.2.3 加载配置信息 创建JedisUtils：com.itheima.util.JedisUtils，使用静态代码块初始化资源 12345678910111213141516171819202122public class JedisUtils &#123; private static int maxTotal; private static int maxIdel; private static String host; private static int port; private static JedisPoolConfig jpc; private static JedisPool jp; static &#123; ResourceBundle bundle = ResourceBundle.getBundle(\"redis\"); maxTotal = Integer.parseInt(bundle.getString(\"redis.maxTotal\")); maxIdel = Integer.parseInt(bundle.getString(\"redis.maxIdel\")); host = bundle.getString(\"redis.host\"); port = Integer.parseInt(bundle.getString(\"redis.port\")); //Jedis连接池配置 jpc = new JedisPoolConfig(); jpc.setMaxTotal(maxTotal); jpc.setMaxIdle(maxIdel); jp = new JedisPool(jpc,host,port); &#125;&#125; 4.2.4 获取连接 对外访问接口，提供jedis连接对象，连接从连接池获取，在JedisUtils中添加一个获取jedis的方法：getJedis 1234public static Jedis getJedis()&#123; Jedis jedis = jedisPool.getResource(); return jedis;&#125; 4.3 可视化客户端4.3.1 Redis Desktop Manager 5. 持久化下面呢，进入到持久化的学习.这部分内容理解的东西多，操作的东西少。在这个部分，我们将讲解四个东西： 持久化简介 RDB AOF RDB与AOF区别 5.1 持久化简介5.1.1 场景-意外断电不知道大家有没有遇见过，就是正工作的时候停电了，如果你用的是笔记本电脑还好，你有电池，但如果你用的是台式机呢，那恐怕就比较灾难了，假如你现在正在写一个比较重要的文档，如果你要使用的是word，这种办公自动化软件的话，他一旦遇到停电，其实你不用担心，因为它会给你生成一些其他的文件。 其实他们都在做一件事儿，帮你自动恢复，有了这个文件，你前面的东西就不再丢了。那什么是自动恢复呢？你要先了解他的整个过程。 我们说自动恢复，其实基于的一个前提就是他提前把你的数据给存起来了。你平常操作的所有信息都是在内存中的，而我们真正的信息是保存在硬盘中的，内存中的信息断电以后就消失了，硬盘中的信息断电以后还可以保留下来！ 我们将文件由内存中保存到硬盘中的这个过程，我们叫做数据保存，也就叫做持久化。但是把它保存下来不是你的目的，最终你还要把它再读取出来，它加载到内存中这个过程，我们叫做数据恢复，这就是我们所说的word为什么断电以后还能够给你保留文件，因为它执行了一个自动备份的过程，也就是通过自动的形式，把你的数据存储起来，那么有了这种形式以后，我们的数据就可以由内存到硬盘上实现保存。 5.1.2 什么是持久化(1)什么是持久化 利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化 。 持久化用于防止数据的意外丢失，确保数据安全性。 (2)持久化过程保存什么？ 我们知道一点，计算机中的数据全部都是二进制，如果现在我要你给我保存一组数据的话，你有什么样的方式呢，其实最简单的就是现在长什么样，我就记下来就行了，那么这种是记录纯粹的数据，也叫做快照存储，也就是它保存的是某一时刻的数据状态。 还有一种形式，它不记录你的数据，它记录你所有的操作过程，比如说大家用idea的时候，有没有遇到过写错了ctrl+z撤销，然后ctrl+y还能恢复，这个地方它也是在记录，但是记录的是你所有的操作过程，那我想问一下，操作过程，我都给你留下来了，你说数据还会丢吗？肯定不会丢，因为你所有的操作过程我都保存了。这种保存操作过程的存储，用专业术语来说可以说是日志，这是两种不同的保存数据的形式啊。 总结一下： 第一种：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据。 第二种：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程。 5.2 RDB5.2.1 save指令手动执行一次保存操作 1save save指令相关配置 设置本地数据库文件名，默认值为 dump.rdb，通常设置为dump-端口号.rdb 1dbfilename filename 设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称data 1dir path 设置存储至本地数据库时是否压缩数据，默认yes，设置为no，节省 CPU 运行时间，但存储文件变大 1rdbcompression yes|no 设置读写文件过程是否进行RDB格式校验，默认yes，设置为no，节约读写10%时间消耗，单存在数据损坏的风险 1rdbchecksum yes|no save指令工作原理 需要注意一个问题，来看一下，现在有四个客户端各自要执行一个指令，把这些指令发送到redis服务器后，他们执行有一个先后顺序问题，假定就是按照1234的顺序放过去的话，那会是什么样的？ 记得redis是个单线程的工作模式，它会创建一个任务队列，所有的命令都会进到这个队列里边，在这儿排队执行，执行完一个消失一个，当所有的命令都执行完了，OK，结果达到了。 但是如果现在我们执行的时候save指令保存的数据量很大会是什么现象呢？ 他会非常耗时，以至于影响到它在执行的时候，后面的指令都要等，所以说这种模式是不友好的，这是save指令对应的一个问题，当cpu执行的时候会阻塞redis服务器，直到他执行完毕，所以说我们不建议大家在线上环境用save指令。 5.2.2 bgsave指令之前我们讲到了当save指令的数据量过大时，单线程执行方式造成效率过低，那应该如何处理？ 此时我们可以使用：bgsave指令，bg其实是background的意思，后台执行的意思 手动启动后台保存操作，但不是立即执行 1bgsave bgsave指令相关配置 后台存储过程中如果出现错误现象，是否停止保存操作，默认yes 1stop-writes-on-bgsave-error yes|no 其 他 1234dbfilename filename dir path rdbcompression yes|no rdbchecksum yes|no bgsave指令工作原理 当执行bgsave的时候，客户端发出bgsave指令给到redis服务器。注意，这个时候服务器马上回一个结果告诉客户端后台已经开始了，与此同时它会创建一个子进程，使用Linux的fork函数创建一个子进程，让这个子进程去执行save相关的操作，此时我们可以想一下，我们主进程一直在处理指令，而子进程在执行后台的保存，它会不会干扰到主进程的执行吗？ 答案是不会，所以说他才是主流方案。子进程开始执行之后，它就会创建啊RDB文件把它存起来，操作完以后他会把这个结果返回，也就是说bgsave的过程分成两个过程，第一个是服务端拿到指令直接告诉客户端开始执行了；另外一个过程是一个子进程在完成后台的保存操作，操作完以后回一个消息。 5.2.3 save配置自动执行设置自动持久化的条件，满足限定时间范围内key的变化数量达到指定数量即进行持久化 1save second changes 参数 second：监控时间范围 changes：监控key的变化量 范例： 123save 900 1save 300 10save 60 10000 其他相关配置： 123456789dbfilename filenamedir path对于存储到磁盘中的快照(rdb)，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能rdbcompression yes|no在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能rdbchecksum yes|nostop-writes-on-bgsave-error yes|no save配置工作原理 5.2.4 RDB三种启动方式对比 方式 save指令 bgsave指令 读写 同步 异步 阻塞客户端指令 是 否 额外内存消耗 否 是 启动新进程 否 是 RDB特殊启动形式 服务器运行过程中重启 1debug reload 关闭服务器时指定保存数据 1shutdown save 全量复制（在主从复制中详细讲解） RDB优点： RDB是一个紧凑压缩的二进制文件，存储效率较高 RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景 RDB恢复数据的速度要比AOF快很多 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。 RDB缺点 RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据 bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能 Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象 5.3 AOF为什么要有AOF,这得从RDB的存储的弊端说起： 存储数据量较大，效率较低，基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低 大数据量下的IO性能较低 基于fork创建子进程，内存产生额外消耗 宕机带来的数据丢失风险 那解决的思路是什么呢？ 不写全数据，仅记录部分数据 降低区分数据是否改变的难度，改记录数据为记录操作过程 对所有操作均进行记录，排除丢失数据的风险 5.3.1 AOF概念AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令 达到恢复数据的目的。与RDB相比可以简单理解为由记录数据改为记录数据产生的变化 AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式 AOF写数据过程 启动AOF相关配置 开启AOF持久化功能，默认no，即不开启状态 123# 是否启用aof持久化方式 。否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。# 因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为noappendonly yes|no AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof 12# 指定更新日志（aof）文件名，默认为appendonly.aofappendfilename filename AOF持久化文件保存路径，与RDB持久化文件保持一致即可 1dir AOF写数据策略，默认为everysec 123456789#指定更新日志条件，共有3个可选值： # no：表示等操作系统进行数据缓存同步到磁盘（快，持久化没保证） # always：同步持久化，每次发生数据变更时，立即记录到磁盘（慢，安全） # everysec：表示每秒同步一次（默认值,很快，但可能会丢失一秒以内的数据）appendfsync always|everysec|no# 指定是否在后台aof文件rewrite期间调用fsync，默认为no，表示要调用fsync（无论后台是否有子进程在刷盘）。# Redis在后台写RDB文件或重写AOF文件期间会存在大量磁盘IO，此时，在某些linux系统中，调用fsync可能会阻塞。#如果应用系统无法忍受延迟，而可以容忍少量的数据丢失，则设置为yes。如果应用系统无法忍受数据丢失，则设置为no。no-appendfsync-on-rewrite no 5.3.2 AOF执行策略AOF写数据三种策略(appendfsync) always(每次）：每次写入操作均同步到AOF文件中数据零误差，性能较低，不建议使用。 everysec（每秒）：每秒将缓冲区中的指令同步到AOF文件中，在系统突然宕机的情况下丢失1秒内的数据 数据准确性较高，性能较高，建议使用，也是默认配置 no（系统控制）：由操作系统控制每次同步到AOF文件的周期，整体过程不可控 5.3.3 AOF重写场景：AOF写数据遇到的问题，如果连续执行如下指令该如何处理 什么叫AOF重写？ 随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重 写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结 果转化成最终结果数据对应的指令进行记录。 AOF重写作用 降低磁盘占用量，提高磁盘利用率 提高持久化效率，降低持久化写时间，提高IO性能 降低数据恢复用时，提高数据恢复效率 AOF重写规则 进程内具有时效性的数据，并且数据已超时将不再写入文件 非写入类的无效指令将被忽略，只保留最终数据的写入命令 如del key1、 hdel key2、srem key3、set key4 111、set key4 222等 如select指令虽然不更改数据，但是更改了数据的存储位置，此类命令同样需要记录 对同一数据的多条写命令合并为一条命令 如lpushlist1 a、lpush list1 b、lpush list1 c可以转化为：lpush list1 a b c。 为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素 AOF重写方式 手动重写 1bgrewriteaof 手动重写原理分析： 自动重写 12auto-aof-rewrite-min-size sizeauto-aof-rewrite-percentage percentage 自动重写触发条件设置 1234#当AOF文件增长到一定大小的时候Redis能够调用 BGREWRITEAOF 对日志文件进行重写 。当AOF文件大小大于该配置项时自动开启重写auto-aof-rewrite-min-size size#当AOF文件增长到一定大小的时候Redis能够调用 BGREWRITEAOF 对日志文件进行重写 。当AOF文件大小的增长率大于该配置项时自动开启重写。auto-aof-rewrite-percentage percent 自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ） 12aof_current_size aof_base_size 自动重写触发条件公式： 5.3.4 AOF工作流程及重写流程![](D:/Develop/1-study/9monthJavaWeb/1-web/day26_Redis基础/讲义/img/AOF 工作流程.png) 5.4 RDB与AOF区别5.4.1 RDB与AOF对比（优缺点） 持久化方式 RDB AOF 占用存储空间 小（数据级：压缩） 大（指令级：重写） 存储速度 慢 快 恢复速度 快 慢 数据安全性 会丢失数据 依据策略决定 资源消耗 高/重量级 低/轻量级 启动优先级 低 高 5.4.2 RDB与AOF应用场景RDB与AOF的选择之惑 对数据非常敏感，建议使用默认的AOF持久化方案 AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出 现问题时，最多丢失0-1秒内的数据。 注意：由于AOF文件存储体积较大，且恢复速度较慢 数据呈现阶段有效性，建议使用RDB持久化方案 数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段 点数据恢复通常采用RDB方案 注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结： 综合比对 RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊 如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF 如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB 灾难恢复选用RDB 双保险策略，同时开启 RDB和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量","categories":[],"tags":[]},{"title":"24_Redis","slug":"24_Redis","date":"2020-11-06T15:45:54.846Z","updated":"2021-01-03T05:34:28.312Z","comments":true,"path":"2020/11/06/24_Redis/","link":"","permalink":"http://xiaojujing.com/2020/11/06/24_Redis/","excerpt":"","text":"Redis1、NoSQL(1) 概念 NoSQL：Not-Only SQL(泛指非关系型数据库)，作为关系型数据库的补充。作业：应对基于海量用户和海量数据前提下的数据处理问 (2) 特征 可扩容、可伸缩；大数据量下高性能。 (3) 应用场景 2、持久化2.1、RDB(数据快照) 将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单 场景：承受数分钟以内的数据丢失，且追求大数据集的恢复速度 2.2、AOF(过程日志) 将数据操作过程进行保存，日志形式，存储操作过程，存储格式复杂 场景：对数据业务非常敏感，保障数据无丢失 3、数据删除和淘汰策略3.1、数据删除3.1.1、定时删除​ 创建一个定时器，当key设置的过期时间到达时，由定时器任务立即执行对键的删除操作。 性能：节约内存，占用CPU资源 3.1.2、惰性删除​ 数据到达过期时间不作处理，等下次访问该数据时判断，如果发现已过期，删除。 性能：节约CPU性能，内存压力很大，出现长期占用内存的数据 3.1.3、定期删除​ 周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度。 性能：CPU性能占用设置有峰值，检测频度可自定义设置；内存压力不是很大，长期占用内存的冷数据会被持续清理 3.2、淘汰策略 检测易失数据 1234volatile-lru：挑选最近最少使用的数据淘汰volatile-lfu：挑选最近使用次数最少的数据淘汰volatile-ttl：挑选将要过期的数据淘汰volatile-random：任意选择数据淘汰 检测全库数据 123allkeys-lru：挑选最近最少使用的数据淘汰allkeLyRs-lfu：：挑选最近使用次数最少的数据淘汰allkeys-random：任意选择数据淘汰，相当于随机 放弃数据驱除 1no-enviction（驱逐）：禁止驱逐数据(redis4.0中默认策略)，会引发OOM(Out Of Memory) 4、主从复制主从复制大体分为3个阶段： 建立连接 数据同步 命令传播（反复同步） 5、哨兵​ 哨兵(sentinel)是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master 6、集群集群作用： 分散单台服务器的访问压力，实现负载均衡 分散单台服务器的存储压力，实现可扩展性 降低单台服务器宕机带来的业务灾难 7、企业级解决方案7.1、缓存预热​ 大量请求过来在缓存中没有获取到数据 解决方案：系统启动前，提前将相关的缓存数据直接加载到缓存系统；避免在用户请求的时候查数据库。 7.2、缓存雪崩​ 短时间大量key集中过期 解决方案：更多页面静态化处理、多级缓存、Mysql优化、灾难预警、限流降级 7.3、缓存击穿​ 单个高热数据key过期 解决方案：监控测试、及时调整 7.4、缓存穿透​ 获取的数据在数据库中不存在，跳过了合法数据的redis数据缓存 解决方案：缓存null、黑白名单、实施监控、key加密","categories":[],"tags":[]},{"title":"23_Mybatis","slug":"23_Mybatis","date":"2020-11-05T07:13:27.339Z","updated":"2021-01-02T08:52:13.470Z","comments":true,"path":"2020/11/05/23_Mybatis/","link":"","permalink":"http://xiaojujing.com/2020/11/05/23_Mybatis/","excerpt":"Mybatis","text":"Mybatis","categories":[],"tags":[]},{"title":"22_JDBC","slug":"22_JDBC","date":"2020-11-05T07:12:37.394Z","updated":"2021-01-02T08:04:51.746Z","comments":true,"path":"2020/11/05/22_JDBC/","link":"","permalink":"http://xiaojujing.com/2020/11/05/22_JDBC/","excerpt":"JDBC1、执行流程","text":"JDBC1、执行流程 导入jar包 注册驱动 获取数据库连接 获取执行者对象 执行sql语句并返回结果 处理结果 释放资源","categories":[],"tags":[]},{"title":"21_数据库事务","slug":"21_数据库事务","date":"2020-11-04T14:41:55.500Z","updated":"2021-01-02T06:53:21.132Z","comments":true,"path":"2020/11/04/21_数据库事务/","link":"","permalink":"http://xiaojujing.com/2020/11/04/21_%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/","excerpt":"MySQL事务1、事务的四大特征","text":"MySQL事务1、事务的四大特征 2、事务的隔离级别 数据库默认隔离级别(隔离级别从小到大安全性越高，效率越低) MySQL(可重复读) Oracle(读已提交)","categories":[],"tags":[]},{"title":"20_Cookie&Session&Jsp","slug":"20_Cookie&Session&Jsp","date":"2020-11-04T14:41:16.824Z","updated":"2020-12-31T03:16:35.355Z","comments":true,"path":"2020/11/04/20_Cookie&Session&Jsp/","link":"","permalink":"http://xiaojujing.com/2020/11/04/20_Cookie&Session&Jsp/","excerpt":"1、Cookie 客户端浏览器的缓存文件，记录了客户浏览器访问网站的一些内容。同时，也是HTTP协议请求和响应消息头的一部分","text":"1、Cookie 客户端浏览器的缓存文件，记录了客户浏览器访问网站的一些内容。同时，也是HTTP协议请求和响应消息头的一部分 2、session Servlet规范中提供的一个接口，Tomcat服务器对Servlet规范进行了实现。该对象提供了一种通过多个页面请求或访问网站来标识用户并存储有关该用户的信息的方法。简单来说它就是一个服务端会话对象，用于存储用户的会话数据。 3、JSP3.1、四大域对象 域对象名称 范围 级别 备注 PageContext 页面范围 最小，只能在当前页面用 因范围太小，开发中用的很少 ServletRequest 请求范围 一次请求或当期请求转发用 当请求转发之后，再次转发时请求域丢失 HttpSession 会话范围 多次请求数据共享时使用 多次请求共享数据，但不同的客户端不能共享 ServletContext 应用范围 最大，整个应用都可以使用 尽量少用，如果对数据有修改需要做同步处理 3.2、MVC模型 Servlet：擅长处理业务逻辑，不擅长输出显示界面。在web开发中多用于控制程序逻辑，我们称之为：控制器。 JSP：擅长显示界面，不擅长处理程序逻辑。在web开发中多用于展示动态界面。所以我们称之为：视图。 M：model，通常用于数据封装，封装的是数据模型；V：view，通常用于展示数据。动态展示用jsp页面，静态数据展示用html；C：controller，通常用于处理请求和响应。","categories":[],"tags":[]},{"title":"19_Servlet","slug":"19_Servlet","date":"2020-11-03T15:15:30.312Z","updated":"2020-12-27T02:26:08.074Z","comments":true,"path":"2020/11/03/19_Servlet/","link":"","permalink":"http://xiaojujing.com/2020/11/03/19_Servlet/","excerpt":"Servlet1、基本概念1.1、什么是servlet","text":"Servlet1、基本概念1.1、什么是servlet Servlet是一个运行在Web服务器的Java小程序，通常通过HTTP协议，用于接收和响应来自Web客户端的请求。实现Servlet功能除了实现Servlet接口外，还可以选择继承GenericServlet或者继承HttpServlet。在接口中定义着初始化Servlet、请求服务和从服务器中销毁Servlet的方法。这些生命周期方法是按照下面的排列顺序调用的： Servlet实例化后，当初始化时调用init方法 任何客户端请求都由service方法处理 Servlet从服务器中移除，当销毁时调用destroy方法，最终由垃圾回收器回收 除了生命周期方法外，接口还提供了getServletConfig方法，每个Servlet都可以使用它并在启动时获取配置信息。还有getServletInfo方法，它允许任何Servlet返回它自己的基本信息。 1.2、Servlet编写方式 实现Servlet接口，接口中的方法必须全部实现。此种方式支持最大程度的自定义。 继承GenericServlet，必须重写service方法，其他方法可根据需要选择性重写。此种方式表示只在接收和响应客户端请求方面有重写的需求，使我们开发Servlet变得简单，但是注意此方式和HTTP协议无关 继承HttpServlet，它是javax.servlet.http包下的一个抽象类，是GenericServlet的子类。继承HttpServlet只需要重写doGet和doPost方法，不需要覆盖service方法。此种方式表示我们的请求和响应是符合HTTP协议的规范。 1.3、Servlet生命周期 出生：请求在第一次到达Servlet(单例模式)，创建对象并初始化 活着：服务器提供服务的整个过程中，该对象一直存在，每次只执行service方法 死亡：服务停止或者服务器宕机，对象销毁 1.4、线程安全问题 由于Servlet是单例，单例对象的类成员只会随类实例化初始化一次，之后的操作都是改变；所以说多个线程会共享Servlet类中成员的数据，因此它是线程不安全的。","categories":[],"tags":[]},{"title":"18_反射","slug":"18_反射","date":"2020-11-03T15:14:41.628Z","updated":"2020-12-26T08:43:33.040Z","comments":true,"path":"2020/11/03/18_反射/","link":"","permalink":"http://xiaojujing.com/2020/11/03/18_%E5%8F%8D%E5%B0%84/","excerpt":"反射1、反射获取Class类的三种方式","text":"反射1、反射获取Class类的三种方式 类名.class属性 对象名.getClass()方法 Class.forName(全类名)方法","categories":[],"tags":[]},{"title":"17_网络编程","slug":"17_网络编程","date":"2020-11-02T15:43:12.066Z","updated":"2020-12-25T06:36:59.482Z","comments":true,"path":"2020/11/02/17_网络编程/","link":"","permalink":"http://xiaojujing.com/2020/11/02/17_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"网络编程1、三次握手 客户端给服务端发送一个请求携带SYN=1、SEQ(随机)","text":"网络编程1、三次握手 客户端给服务端发送一个请求携带SYN=1、SEQ(随机) 服务端收到请求，返回一个响应携带SYN=1、ACK=SEQ+1、SEQ；Listen状态-&gt;SRND 客户端收到响应，发送SYN=1、ACK=SEQ+1、SEQ(第一次)+1;SEND-&gt;ESTABLISHED 2、四次挥手 客户端想要释放连接，给服务器发送一段TCP报文 服务器接收到客户端发出的TCP报文后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段并返回一段TCP报文 服务器端自发出ACK确认报文后，经过CLOSE-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文 客户端收到从服务器发来的TCP报文，确认了服务器已经做好了释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文 3、为什么要三次 防止服务器端开启一些无用的连接增加服务器开销以及防止接收到从已失效连接传送过来的请求产生错误 4、为什么要四次 三次握手是因为在第二次握手的过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位；SYN是请求连接标志，ACK是确认报文 四次挥手是因为FIN释放连接报文与ACK确认报文分别由第二次和第三次挥手传输的","categories":[],"tags":[]},{"title":"16_多线程","slug":"16_多线程","date":"2020-11-02T15:42:34.078Z","updated":"2020-12-24T07:44:58.598Z","comments":true,"path":"2020/11/02/16_多线程/","link":"","permalink":"http://xiaojujing.com/2020/11/02/16_%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"多线程1、实现多线程1.1、多线程实现的三种方式","text":"多线程1、实现多线程1.1、多线程实现的三种方式 继承Thread类，重写run()方法 实现Runnable接口，重新run()方法 实现Callable接口，重写Call()方法;创建MyCallable对象；创建FutureTask对象，传入MyCallable对象作为构造方法参数;创建Thread对象，传入FutureTask对象作为构造方法的参数 1.2、同步机制 锁对象 new ReentrantLock() 同步代码块 new Object() 用synchronized(object){同步代码块} 同步方法 直接在方法前加synchronized关键字 1.3、案例 案例需求：开n个线程顺序打印从1-m的整数 实现线程接口 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.Callable;import java.util.concurrent.locks.ReentrantLock;public class MyThread implements Callable &#123; private int m; private int n; private int index = 0; private int count = 1; private ReentrantLock lock = new ReentrantLock(); public MyThread(int m,int n)&#123; this.m = m; this.n = n; &#125; @Override public Object call() throws Exception &#123; while (true) &#123; lock.lock(); if (count==m+1)&#123; lock.unlock(); break; &#125; String name = Thread.currentThread().getName(); String[] s = name.split(\" \"); Integer myIndex = Integer.valueOf(s[1]); if (myIndex == index + 1) &#123; System.out.println(name + \": \" + count); index=(index+1)%n; count++; &#125; lock.unlock(); &#125; return null; &#125;&#125; 主函数 123456789101112131415161718192021import java.util.ArrayList;import java.util.concurrent.FutureTask;public class Test03 &#123; public static void main(String[] args) &#123; int m = 100, n = 5; MyThread myThread03 = new MyThread(m, n); ArrayList&lt;FutureTask&gt; futureTasks = new ArrayList&lt;&gt;(); ArrayList&lt;Thread&gt; threads = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; FutureTask futureTask = new FutureTask&lt;&gt;(myThread03); futureTasks.add(futureTask); Thread thread = new Thread(futureTasks.get(i), \"线程 \" + (i + 1)); threads.add(thread); threads.get(i).start(); &#125; &#125;&#125; 2、生产者消费者问题2.1、概述 桌子 定义生产者生产上限，定义同一锁对象 生产者 桌子没食物生产，生产完唤醒消费者并等待；生产达上限结束当前进程。 消费者 有食物消费，消费完则等待并且唤醒消费者；确定不再生产否则结束进程。 2.2、实现 定义桌子 1234567public class Desk &#123; public static int count = 10; //每日生产上限 public static int flag = 1; //是否有食物，0表示有 public static Object lock = new Object();&#125; 生产者 12345678910111213141516171819202122232425262728293031323334353637383940public class Cooker implements Runnable&#123; private Desk desk; private Object lock; public Cooker(Desk desk) &#123; this.desk = desk; this.lock = desk.lock; &#125; @Override public void run() &#123; while (true) &#123; synchronized (lock) &#123; if (desk.flag == 1) &#123; //没有食物且能生产 String name = Thread.currentThread().getName(); System.out.println(name + \"正在生产汉堡包..\"+desk.count); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; desk.flag = 0; desk.count--; lock.notifyAll(); if (desk.count == 0) &#123; break; //不能生产，则结束 &#125; &#125;else &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 消费者 1234567891011121314151617181920212223242526272829303132333435363738394041public class Fooder implements Runnable &#123; private Desk desk; private Object lock; public Fooder(Desk desk) &#123; this.desk = desk; this.lock = desk.lock; &#125; @Override public void run() &#123; synchronized (lock) &#123; while (true) &#123; if (desk.flag == 0) &#123; //有食物则可以拿 String name = Thread.currentThread().getName(); System.out.println(name + \"正在大口吃汉堡包..\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; desk.flag = 1; lock.notifyAll(); if (desk.count == 0) &#123; System.out.println(\"店铺关门了~~\"); System.out.println(\"下次再来~~\"); break; //厨师累了，不做菜 &#125; &#125; else &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"15_集合","slug":"15_集合","date":"2020-11-01T15:49:40.774Z","updated":"2020-12-25T06:36:05.010Z","comments":true,"path":"2020/11/01/15_集合/","link":"","permalink":"http://xiaojujing.com/2020/11/01/15_%E9%9B%86%E5%90%88/","excerpt":"集合1、Collection 长度可变的容器 只能存储引用类型，存基本数据类型要用到包装类","text":"集合1、Collection 长度可变的容器 只能存储引用类型，存基本数据类型要用到包装类 JDK1.5之后新增增强for用来简化集合遍历 2、List 存取有序、可重复、有索引 2.1、ArrayList 数组结构实现，查询快、增删慢 2.2、LinkList 链表结构实现，查询慢、增删快 3、Set 不可重复、无索引（不能使用普通for） 3.1、TreeSet3.1.1、自然排序 空参创建TreeSet集合 自定义类实现Comparable接口 重写CompareTo方法 3.1.2、比较器排序 TreeSet带参构造接收Comparetor的实现类对象 重写compare(T o1,T o2)方法 3.2、HashSet 底层是哈希表、无序、不可重复、无索引 哈希表结构基于数组+链表，JDK1.8之后当结点多于8个基于数组+红黑树 HashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法 4、Map 双列集合，一个键对应一个值 键不可以重复，值可以重复 4.1、遍历方式 map.values()、map.keyset() map.entrySet() 4.2、HashMap HashMap底层是哈希表结构的 依赖hashCode方法和equals方法保证键的唯一 4.3、TreeMap TreeMap底层是红黑树结构 依赖自然排序或者比较器排序,对键进行排序","categories":[],"tags":[]},{"title":"14_Java基础","slug":"14_Java基础","date":"2020-11-01T15:48:20.534Z","updated":"2020-12-25T06:36:24.008Z","comments":true,"path":"2020/11/01/14_Java基础/","link":"","permalink":"http://xiaojujing.com/2020/11/01/14_Java%E5%9F%BA%E7%A1%80/","excerpt":"Java基础1、类和对象 类是现实世界中具有共同属性和行为的一类事物的抽象","text":"Java基础1、类和对象 类是现实世界中具有共同属性和行为的一类事物的抽象 对象是类中一个具体的实体 2、StringBuilder 支持字符串拼接及链式编程 3、权限修饰符 4、静态代码块 在构造函数之前执行，用于初始化数据，随着类的加载而加载，且只执行一次 5、接口 一种公共的规范标准 用于做功能扩展，类和接口以及接口和接口可以实现多继承","categories":[],"tags":[]},{"title":"PAT乙级1025","slug":"13_PAT乙级1025","date":"2020-02-15T15:48:25.000Z","updated":"2020-02-15T15:48:25.347Z","comments":true,"path":"2020/02/15/13_PAT乙级1025/","link":"","permalink":"http://xiaojujing.com/2020/02/15/13_PAT%E4%B9%99%E7%BA%A71025/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"广度优先搜索","slug":"12_广度优先搜索","date":"2020-02-12T14:40:52.000Z","updated":"2020-02-12T14:41:58.803Z","comments":true,"path":"2020/02/12/12_广度优先搜索/","link":"","permalink":"http://xiaojujing.com/2020/02/12/12_%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std; /int N,K; //抓住这头牛const int MAXN=100000;int visited[MAXN+10];struct Step{ int x; int steps; Step(int xx,int s):x(xx),steps(s){ }};queue q;/ int main(){ /cin&gt;&gt;N&gt;&gt;K; memset(visited,0,sizeof(visited)); q.push(Step(N,0)); visited[N]=1; while(!q.empty()){ Step s=q.front(); if(s.x==K){ cout&lt;&lt;s.steps&lt;&lt;endl; return 0; }else{ if(s.x&gt;=0&amp;&amp;!visited[s.x-1]){ q.push(Step(s.x-1,s.steps+1)); visited[s.x-1]=1; } if(s.x+1&lt;=MAXN&amp;&amp;!visited[s.x+1]){ q.push(Step(s.x+1,s.steps+1)); visited[s.x+1]=1; } if(s.x2&lt;=MAXN&amp;&amp;!visited[s.x2]){ q.push(Step(s.x2,s.steps+1)); visited[s.x2]=1; } q.pop(); } }/ return 0;}","categories":[],"tags":[]},{"title":"贪心","slug":"11_贪心","date":"2020-02-11T07:34:19.000Z","updated":"2020-02-11T07:35:55.861Z","comments":true,"path":"2020/02/11/11_贪心/","link":"","permalink":"http://xiaojujing.com/2020/02/11/11_%E8%B4%AA%E5%BF%83/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std; /const double eps=1e-6; //圣诞老人的礼物struct Candy{ int v; int w; bool operator &lt; (const Candy &amp; c){ return double(v)/w-double(c.v)/c.w&gt;eps; }}candies[110];/ struct Cow{ //分配畜栏 int a,b; int No; bool operator &lt; (const Cow &amp;c) const{ return a&lt;c.a; };}cows[50100];int pos[50100];struct Stall{ int end; int No; bool operator&lt;(const Stall &amp;s) const{ return end&gt;s.end; } Stall(int e,int n):end(e),No(n){ }}; int main(){ /int n,w; scanf(“%d%d”,&amp;n,&amp;w); for(int i=0;i&lt;n;i++){ scanf(“%d%d”,&amp;candies[i].v,&amp;candies[i].w); } sort(candies,candies+n); int totalW=0; double totalV=0; for(int i=0;i&lt;n;i++){ if(totalW+candies[i].w&lt;=w){ totalW+=candies[i].w; totalV+=candies[i].v; }else{ totalV+=candies[i].v*double(w-totalW)/candies[i].w; break; } } printf(“%.1f”,totalV);/ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;++i){ scanf(&quot;%d%d&quot;,&amp;cows[i].a,&amp;cows[i].b); cows[i].No=i; } sort(cows,cows+n); int total=0; priority_queue&lt;Stall&gt; pq; for(int i=0;i&lt;n;++i){ if(pq.empty()){ ++total; pq.push(Stall(cows[i].b,total)); pos[cows[i].No]=total; }else{ Stall st=pq.top(); if(st.end&lt;cows[i].a){ pq.pop(); pos[cows[i].No]=st.No; pq.push(Stall(cows[i].b,st.No)); }else{ ++total; pq.push(Stall(cows[i].b,total)); pos[cows[i].No]=total; } } } printf(&quot;%d\\n&quot;,total); for(int i=0;i&lt;n;i++){ printf(&quot;%d\\n&quot;,pos[i]); } return 0;}","categories":[],"tags":[]},{"title":"动态规划","slug":"10_动态规划","date":"2020-02-10T11:54:26.000Z","updated":"2020-02-10T11:55:04.676Z","comments":true,"path":"2020/02/10/10_动态规划/","link":"","permalink":"http://xiaojujing.com/2020/02/10/10_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std; /const int MAXN=1010; //最长上升子序列int a[MAXN];int maxLen[MAXN];/ char sz1[1000]; //最长公共子序列char sz2[1000];int maxLen[1000][1000]; int main(){ /int N; cin&gt;&gt;N; for(int i=1;i&lt;=N;i++){ cin&gt;&gt;a[i]; maxLen[i]=1; } for(int i=2;i&lt;=N;i++){ for(int j=1;j&lt;i;j++){ if(a[i]&gt;a[j]) maxLen[i]=max(maxLen[i],maxLen[j]+1); } } cout&lt;&lt;*max_element(maxLen+1,maxLen+N+1);/ while(cin&gt;&gt;sz1&gt;&gt;sz2){ int length1=strlen(sz1); int length2=strlen(sz2); int nTmp; int i,j; for(i=0;i&lt;=length1;i++) maxLen[i][0]=0; for(j=0;j&lt;=length2;j++) maxLen[0][j]=0; for(i=1;i&lt;=length1;i++){ for(j=1;j&lt;=length2;j++){ if(sz1[i-1]==sz2[j-1]) maxLen[i][j]=maxLen[i-1][j-1]+1; else maxLen[i][j]=max(maxLen[i][j-1],maxLen[i-1][j]); } } cout&lt;&lt;maxLen[length1][length2]&lt;&lt;endl; } return 0;}","categories":[],"tags":[]},{"title":"深度优先搜索","slug":"09_深度优先搜索","date":"2020-02-09T14:07:52.000Z","updated":"2020-02-09T14:08:11.093Z","comments":true,"path":"2020/02/09/09_深度优先搜索/","link":"","permalink":"http://xiaojujing.com/2020/02/09/09_%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std;/*int R,C; //城堡问题int rooms[60][60];int color[60][60];int maxRoomArea=0,roomNum=0;int roomArea;void Dfs(int i,int k){ if(color[i][k]) return; ++roomArea; color[i][k]=roomNum; if((rooms[i][k]&amp;1)==0) Dfs(i,k-1); if((rooms[i][k]&amp;2)==0) Dfs(i-1,k); if((rooms[i][k]&amp;4)==0) Dfs(i,k+1); if((rooms[i][k]&amp;8)==0) Dfs(i+1,k);} int visited[30][50]; //采方格int ways(int i,int j,int n){ if(n==0) return 1; visited[i][j]=1; int num=0; if(!visited[i][j-1]) num+=ways(i,j-1,n-1); if(!visited[i][j+1]) num+=ways(i,j+1,n-1); if(!visited[i+1][j]) num+=ways(i+1,j,n-1); visited[i][j]=0; return num;} int k,n,r; //寻路问题struct Road{ int d,L,t;};vector&lt; vector &gt; G(110);int minL[110][10010];int minLen;int totalLen;int totalCost;int visited[110]; void dfs(int s){ if(s==n){ minLen=min(minLen,totalLen); return; } for(int i=0;i&lt;G[s].size();++i){ Road r=G[s][i]; if(totalCost+r.t&gt;k) continue; if(!visited[r.d]){ if(totalLen+r.L&gt;=minLen) continue; if(totalLen+r.L&gt;=minL[r.d][totalCost+r.t]) continue; minL[r.d][totalCost+r.t]=totalLen+r.L; totalLen+=r.L; totalCost+=r.t; visited[r.d]=1; dfs(r.d); totalLen-=r.L; totalCost-=r.t; visited[r.d]=0; } }}*/ int N,M; //生日蛋糕int minArea=1&lt;&lt;30;int area=0; void Dfs(int v,int n,int r,int h){ if(n==0){ if(v) return ; else{ minArea=min(minArea,area); return; } } if(v&lt;=0) return; for(int rr=r;rr&gt;=n;–rr){ if(n==M) area=rrrr; for(int hh=h;hh&gt;=n;–hh){ area+=2rrhh; Dfs(v-rrrrhh,n-1,rr-1,hh-1); area-=2rr*hh; } }} int main(){ /cin&gt;&gt;R&gt;&gt;C; for(int i=1;i&lt;=R;i++){ for(int k=1;k&lt;=C;k++){ cin&gt;&gt;rooms[i][k]; } } memset(color,0,sizeof(color)); for(int i=1;i&lt;=R;i++){ for(int k=1;k&lt;=C;k++){ if(!color[i][k]){ ++roomNum; roomArea=0; Dfs(i,k); maxRoomArea=max(roomArea,maxRoomArea); } } } cout&lt;&lt;roomNum&lt;&lt;endl&lt;&lt;maxRoomArea&lt;&lt;endl;/ /*int n; cin&gt;&gt;n; memset(visited,0,sizeof(visited)); cout&lt;&lt;ways(0,25,n); cin&gt;&gt;k&gt;&gt;n&gt;&gt;r; for(int i=0;i&lt;r;i++){ int s; Road r; cin&gt;&gt;s&gt;&gt;r.d&gt;&gt;r.L&gt;&gt;r.t; if(s!=r.d){ G[s].push_back(r); } } memset(visited,0,sizeof(visited)); totalLen=0; minLen=1&lt;&lt;30; totalCost=0; visited[1]=1; for(int i=0;i&lt;110;i++){ for(int j=0;j&lt;10010;j++){ minL[i][j]=1&lt;&lt;30; } } dfs(1); if(minLen&lt;(1&lt;&lt;30)){ cout&lt;&lt;minLen&lt;&lt;endl; }else{ cout&lt;&lt;-1&lt;&lt;endl; }*/ int maxR=5,maxH=100; cin&gt;&gt;N&gt;&gt;M; Dfs(N,M,maxR,maxH); if(minArea==1&lt;&lt;30) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;minArea&lt;&lt;endl; return 0;}","categories":[],"tags":[]},{"title":"分治再探","slug":"08_分治再探","date":"2020-02-08T15:45:45.000Z","updated":"2020-02-08T15:54:00.706Z","comments":true,"path":"2020/02/08/08_分治再探/","link":"","permalink":"http://xiaojujing.com/2020/02/08/08_%E5%88%86%E6%B2%BB%E5%86%8D%E6%8E%A2/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std;#define MAX 101int D[MAX][MAX]={0};int n;int maxsum[MAX][MAX];int MaxSum(int i,int j){ if(maxsum[i][j]!=-1) return maxsum[i][j]; if(i==n) maxsum[i][j]=D[i][j]; else{ int x=MaxSum(i+1,j); int y=MaxSum(i+1,j+1); maxsum[i][j]=max(x,y)+D[i][j]; } return maxsum[i][j];}int main(){ int i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ for(j=1;j&lt;=i;j++){ cin&gt;&gt;D[i][j]; maxsum[i][j]=-1; } } cout&lt;&lt;MaxSum(1,1)&lt;&lt;endl; return 0;}","categories":[],"tags":[]},{"title":"递归和分治","slug":"07_递归和分治","date":"2020-02-07T15:10:35.000Z","updated":"2020-02-07T15:50:52.451Z","comments":true,"path":"2020/02/07/07_递归和分治/","link":"","permalink":"http://xiaojujing.com/2020/02/07/07_%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std;void Swap(int &amp;a,int &amp;b){ int temp=0; temp=a; a=b; b=temp;} void Hanoi(int n,char src,char mid,char dest){ //汉诺塔问题 if(n==1){ cout&lt;&lt;src&lt;&lt;”-&gt;”&lt;&lt;dest&lt;&lt;endl; return; } Hanoi(n-1,src,dest,mid); cout&lt;&lt;src&lt;&lt;”-&gt;”&lt;&lt;dest&lt;&lt;endl; Hanoi(n-1,mid,src,dest);} int N;int queenPos[100];void NQueen(int k){ //N皇后 if(k==N){ for(int i=0;i&lt;N;i++){ cout&lt;&lt;queenPos[i]+1&lt;&lt;’ ‘; } cout&lt;&lt;endl; return; } for(int i=0;i&lt;N;i++){ int j; for(j=0;j&lt;k;j++){ if(queenPos[j]==i||abs(queenPos[j]-i)==abs(k-j)){ break; } } if(j==k){ queenPos[k]=i; NQueen(k+1); } }} double exp(){ //逆波兰式 char s[20]; cin&gt;&gt;s; switch(s[0]){ case ‘+’: return exp()+exp(); case ‘-‘: return exp()-exp(); case ‘‘: return exp()exp(); case ‘/‘: return exp()/exp(); default: return atof(s); break; }} int expression_value(){ //表达式的值 int term_value(); int result=term_value(); bool more=true; while(more){ char op=cin.peek(); if(op==’+’||op==’-‘){ cin.get(); int value=term_value(); if(op==’+’) result+=value; else result-=value; } else more=false; } return result;}int term_value(){ int factor_value(); int result=factor_value(); while(true){ char op=cin.peek(); if(op==’‘||op==’/‘){ cin.get(); int value=factor_value(); if(op==’‘) result*=value; else result/=value; } else break; } return result; }int factor_value(){ int result=0; char c=cin.peek(); if(c==’(‘){ cin.get(); result=expression_value(); cin.get(); }else{ while(isdigit(c)){ result=10*result+c-‘0’; cin.get(); c=cin.peek(); } } return result;} bool HuiWen(string s){ //回文串判断,小写输入 int h=0,t=s.size()-1; while(h&lt;=t){ if(s[h]!=s[t]) return 0; h++;t–; } return 1;} void QuanPai(int a[],int k,int n){ //全排列 if(n==k){ for(int i=1;i&lt;=n;i++){ cout&lt;&lt;a[i]&lt;&lt;’ ‘; } cout&lt;&lt;endl; }else{ for(int i=k;i&lt;n+1;i++){ Swap(a[k],a[i]); QuanPai(a,k+1,n); Swap(a[k],a[i]); } } } int main(){ //递归 /*char a=&apos;A&apos;,b=&apos;B&apos;,c=&apos;C&apos;; int n=0; cin&gt;&gt;n; Hanoi(n,a,b,c);*/ /*cin&gt;&gt;N; NQueen(0);*/ //cout&lt;&lt;exp()&lt;&lt;endl; //cout&lt;&lt;expression_value()&lt;&lt;endl; //分治 /*string s; int flag=-1; cin&gt;&gt;s; flag=HuiWen(s); cout&lt;&lt;&quot;回文串:&quot;&lt;&lt;flag&lt;&lt;endl; */ /*int *a,len; cout&lt;&lt;&quot;len:&quot;&lt;&lt;endl; cin&gt;&gt;len; a=new int[len+1]; for(int i=1;i&lt;len+1;i++){ a[i]=i; } QuanPai(a,1,len);*/ return 0;}","categories":[],"tags":[]},{"title":"STL实践","slug":"06_STL实践","date":"2020-02-06T15:39:45.000Z","updated":"2020-02-06T17:54:54.461Z","comments":true,"path":"2020/02/06/06_STL实践/","link":"","permalink":"http://xiaojujing.com/2020/02/06/06_STL%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"#include #include#include#include#include#include#include#include#includeusing namespace std;struct Student{ int a,b; bool operator &lt; (const Student &amp;rs) const{ if(a==rs.a) return b&lt;rs.b; return a&lt;rs.a; }}; int main(){ priority_queue q; deque ::const_iterator i; set ::const_iterator j; map &lt;int,char&gt;::iterator k; vector v; deque d; map&lt;int,char&gt; m; set s; s.insert(5);s.insert(8);s.insert(1);s.insert(3);s.insert(3); m.insert(pair&lt;int,char&gt;(1,’a’)); m.insert(pair&lt;int,char&gt;(2,’a’)); m.insert(pair&lt;int,char&gt;(3,’c’)); m.insert(pair&lt;int,char&gt;(4,’d’)); /m.insert(map&lt;int,char&gt;::value_type(1,’a’)); m.insert(map&lt;int,char&gt;::value_type(1,’b’)); m.insert(map&lt;int,char&gt;::value_type(3,’c’)); m.insert(map&lt;int,char&gt;::value_type(4,’d’));/ for(k=m.begin();k!=m.end();k++){ cout&lt;&lt;1&lt;&lt;’ ‘; } cout &lt;&lt;endl; for(int i=0;i&lt;10;i++){ v.push_back(i); d.push_front(i); } for(i=d.begin();i&lt;d.end();i++){ cout&lt;&lt;i&lt;&lt;’ ‘; } cout &lt;&lt;endl; for(j=s.begin();j!=s.end();j++){ cout&lt;&lt;j&lt;&lt;’ ‘; } cout &lt;&lt;endl; for(int i=0;i&lt;10;i++){ q.push(i); } while(q.size()){ cout&lt;&lt;q.top()&lt;&lt;&apos; &apos;; q.pop(); } cout &lt;&lt;endl; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q_; for(int i=0;i&lt;10;i++){ q_.push(i); } while(q_.size()){ cout&lt;&lt;q_.top()&lt;&lt;&apos; &apos;; q_.pop(); } cout &lt;&lt;endl; Student student[5]={{5,5},{5,4},{3,1},{2,2},{2,1}}; sort(student,student+5); for(int i=0;i&lt;5;i++){ cout&lt;&lt;student[i].a&lt;&lt;&apos; &apos;&lt;&lt;student[i].b&lt;&lt;endl; } priority_queue &lt;Student&gt; qq; for(int i=0;i&lt;5;i++){ qq.push(student[i]); } while(qq.size()){ Student now=qq.top(); cout&lt;&lt;now.a&lt;&lt;&apos; &apos;&lt;&lt;now.b&lt;&lt;endl; qq.pop(); } cout &lt;&lt;endl; return 0;}","categories":[],"tags":[]},{"title":"图的遍历","slug":"05_图的遍历","date":"2020-02-05T14:42:29.000Z","updated":"2020-02-05T14:45:27.662Z","comments":true,"path":"2020/02/05/05_图的遍历/","link":"","permalink":"http://xiaojujing.com/2020/02/05/05_%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"","text":"邻接表存储DFSvoid Visit(Vertex v){ printf(“%d\\n”,v);}void DFS(LGraph Graph,Vertex v,void (*Visit)(Vertex)){ ProToAdjVNode W; Visit(v); Visited[v]=true; for(W=Graph-&gt;G[v].FitstEdge;W;W=W-&gt;Next){ if(!Visited[W-&gt;Adjv]){ DFS(Graph,W-&gt;Adjv,Visit); } }} 邻接矩阵存储BFSvoid Visit(Vertex v){ printf(“正在访问的顶点%d\\n”,v);}bool IsEdge(MGraph Graph,Vertex v,Vertex w){ return Graph-&gt;G[v][w]&lt;INFNITY?true:false;}void BFS(MGraph Graph,Vertex S,void(*Visit)(Vertex)){ queue Q; Vertex V,W; Visit(S); Visited[S]=true; Q.push(S); while(!Q.empty()){ V=Q.front();Q.pop(); for(W=0;WNv;W++){ if(!Visited[W]&amp;&amp;IsEdge(Graph,V,W)){ Visit(W); Visited[W]=true; Q.push(W); } } }}","categories":[],"tags":[]},{"title":"图的两种表示法","slug":"04_图的两种表示法","date":"2020-02-04T14:38:09.000Z","updated":"2020-02-04T14:38:32.857Z","comments":true,"path":"2020/02/04/04_图的两种表示法/","link":"","permalink":"http://xiaojujing.com/2020/02/04/04_%E5%9B%BE%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%B3%95/","excerpt":"","text":"邻接矩阵表示:#include#include#define MaxVertexNum 100#define INFNITY 65535using namespace std;typedef int Vertex;typedef int WeightType;typedef char DataType; typedef struct ENode{ Vertex v1,v2; WeightType Weight;}*PtrToENode;typedef PtrToENode Edge; typedef struct GNode{ int Nv,Ne; WeightType G[MaxVertexNum][MaxVertexNum]; DataType Data[MaxVertexNum];}*PtrToMNode;typedef PtrToMNode MGraph; MGraph CreateGraph(int VertexNum){ Vertex v,w; MGraph Graph; Graph=(MGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv=VertexNum; Graph-&gt;Ne=0; for(v=0;vNv;v++){ for(w=0;wNv;w++){ Graph-&gt;G[v][w]=INFNITY; } } return Graph;}void InsertEdge(MGraph Graph,Edge E){ Graph-&gt;G[E-&gt;v1][E-&gt;v2]=E-&gt;Weight; Graph-&gt;G[E-&gt;v2][E-&gt;v1]=E-&gt;Weight;}MGraph BuildGraph(){ MGraph Graph; Edge E; Vertex v; int Nv,i; scanf(“%d”,&amp;Nv); Graph=CreateGraph(Nv); scanf(“%d”,&amp;(Graph-&gt;Ne)); if(Graph-&gt;Ne!=0){ E=(Edge)malloc(sizeof(struct ENode)); for(i=0;iNe;i++){ scanf(“%d%d%d”,&amp;E-&gt;v1,&amp;E-&gt;v2,&amp;E-&gt;Weight); InsertEdge(Graph,E); } } for(v=0;vNv;v++){ scanf(“ %c”,&amp;(Graph-&gt;Data[v])); } return Graph;}int main(){ MGraph Graph; Graph=BuildGraph(); int n=0; int v=-1; printf(“请输入你要查询的顶点编号:”); scanf(“%d”,&amp;v); printf(“你查询的顶点%c的邻接点:\\n”,Graph-&gt;Data[v]); for(n=0;nNv;n++){ if(Graph-&gt;G[v][n]&lt;INFNITY&amp;&amp;Graph-&gt;G[v][n]&gt;0){ printf(“%c “,Graph-&gt;Data[n]); } } printf(“\\n”); for(int i=0;iNv;i++){ for(int j=0;jNv;j++){ printf(“%d “,Graph-&gt;G[i][j]); } printf(“\\n”); } /* 5 5 0 1 2 0 3 10 0 4 13 1 2 4 2 4 9 a e d c b */ return 0;} 邻接表表示#include#includeusing namespace std; #define MaxVertexNum 100typedef int Vertex;typedef int WeightType;typedef char DataType; typedef struct ENode{ Vertex v1,v2; WeightType Weight;}*PtrToENode;typedef PtrToENode Edge; typedef struct AdjVNode{ Vertex Adjv; WeightType Weight; AdjVNode Next;}ProToAdjVNode; typedef struct VNode{ ProToAdjVNode FitstEdge; DataType Data;}AdjList[MaxVertexNum]; typedef struct GNode{ int Nv; int Ne; AdjList G;}*PtrToGNode;typedef PtrToGNode LGraph; LGraph CreateGraph(int VertexNum){ Vertex v; LGraph Graph; Graph=(LGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv=VertexNum; Graph-&gt;Ne=0; for(v=0;vNv;v++){ Graph-&gt;G[v].FitstEdge=NULL; } return Graph;} void InsertEdge(LGraph Graph,Edge E){ ProToAdjVNode NewNode; NewNode=(ProToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;Adjv=E-&gt;v2; NewNode-&gt;Weight=E-&gt;Weight; NewNode-&gt;Next=Graph-&gt;G[E-&gt;v2].FitstEdge; Graph-&gt;G[E-&gt;v1].FitstEdge=NewNode; NewNode=(ProToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;Adjv=E-&gt;v1; NewNode-&gt;Weight=E-&gt;Weight; NewNode-&gt;Next=Graph-&gt;G[E-&gt;v2].FitstEdge; Graph-&gt;G[E-&gt;v2].FitstEdge=NewNode;}LGraph BuildGraph(){ LGraph Graph; Edge E; Vertex v; int Nv,i; scanf(“%d”,&amp;Nv); Graph=CreateGraph(Nv); scanf(“%d”,&amp;(Graph-&gt;Ne)); if(Graph-&gt;Ne!=0){ E=(Edge)malloc(sizeof(ENode)); for(i=0;iNe;i++){ scanf(“%d %d %d”,&amp;E-&gt;v1,&amp;E-&gt;v2,&amp;E-&gt;Weight); InsertEdge(Graph,E); } } for(v=0;vNv;v++){ scanf(“ %c”,&amp;(Graph-&gt;G[v].Data)); } return Graph;}int main(){ LGraph Graph; Graph=BuildGraph(); int n=0; int v=-1; printf(“请输入你要查询的顶点编号:”); scanf(“%d”,&amp;v); printf(“你查询的顶点%c的邻接点:”,Graph-&gt;G[v].Data); AdjVNode M; M=Graph-&gt;G[v].FitstEdge; while(M!=NULL){ printf(“%c “,Graph-&gt;G[M-&gt;Adjv].Data); M=M-&gt;Next; } printf(“\\n”); / 5 5 1 0 2 3 0 10 4 0 13 2 1 4 4 2 9 a e d c b */ return 0;}","categories":[],"tags":[]},{"title":"栈队列二叉树的简单实现","slug":"03_静态栈和队列以及二叉树","date":"2020-02-03T13:03:14.000Z","updated":"2020-12-25T06:35:25.113Z","comments":true,"path":"2020/02/03/03_静态栈和队列以及二叉树/","link":"","permalink":"http://xiaojujing.com/2020/02/03/03_%E9%9D%99%E6%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556include&lt;iostream&gt;include&lt;cstdlib&gt;using namespace std; typedef char Elemtype;typedef struct BiTNode&#123; Elemtype data; BiTNode lchild,rchild;&#125;BiTNode,BiTree;int CreatBiTree(BiTree &amp;T)&#123; //建立二叉树 Elemtype ch; cin&gt;&gt;ch; if(ch=='#') T=NULL; else&#123; T=(BiTNode)malloc(sizeof(BiTNode)); T-&gt;data=ch; CreatBiTree(T-&gt;lchild); CreatBiTree(T-&gt;rchild); &#125; return 0;&#125;void PreOrder(BiTree &amp;T)&#123; if(T!=NULL)&#123; cout&lt;&lt;T-&gt;data&lt;&lt;endl; PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); &#125;&#125;void InOrder(BiTree &amp;T)&#123; if(T!=NULL)&#123; InOrder(T-&gt;lchild); cout&lt;&lt;T-&gt;data&lt;&lt;endl; InOrder(T-&gt;rchild); &#125;&#125;void PostOrder(BiTree &amp;T)&#123; if(T!=NULL)&#123; PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); cout&lt;&lt;T-&gt;data&lt;&lt;endl; &#125;&#125;int main()&#123; BiTree T; CreatBiTree(T); printf(\"先序遍历:\\n\"); // a PreOrder(T); // b c printf(\"中序遍历:\\n\"); //d e InOrder(T); // f g printf(\"后序遍历:\\n\"); PostOrder(T); return 0;&#125;","categories":[],"tags":[]},{"title":"数据结构几种排序的简单实现","slug":"02_数据结构内部排序简单实现","date":"2020-02-02T15:16:58.000Z","updated":"2020-12-23T07:48:47.558Z","comments":true,"path":"2020/02/02/02_数据结构内部排序简单实现/","link":"","permalink":"http://xiaojujing.com/2020/02/02/02_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","excerpt":"内部排序1、直接插入排序 遍历选取待排序数组，每次插入一个元素到结果队列","text":"内部排序1、直接插入排序 遍历选取待排序数组，每次插入一个元素到结果队列 2、希尔排序 设置递减增量d（最后到1），每轮对增量个子序列插入排序 3、冒泡排序 两两比较将大数后移，每轮选取最大的元素到队列末尾；再在前n-1个元素中排序 4、简单选择排序 与冒泡排序算法类似，区别在于每次将两两交换改成记录对应的索引，只在每轮结束后才交换选取最大元素的值 5、快速排序 取当前排序范围内中间的元素作为枢纽，从头尾靠拢找到需要交换的元素，一轮完成后枢纽左边元素都小于枢纽，右边都大于枢纽；分治左右两边 5.1、改进 选取左端、右端、中心的中值作为枢纽 处理小规模数据时采用插入排序 大量元素相等的序列三路分区","categories":[],"tags":[{"name":"排序","slug":"排序","permalink":"http://xiaojujing.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"我的第一篇博客文章","slug":"01_我的第一篇博客文章","date":"2020-02-01T13:05:40.000Z","updated":"2020-12-25T06:33:31.773Z","comments":true,"path":"2020/02/01/01_我的第一篇博客文章/","link":"","permalink":"http://xiaojujing.com/2020/02/01/01_%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"万事开头难坚持 大四即将工作的老学长即日起更新博客. 励志做一名靠谱的程序员 qaq~~ 座右铭: 得得得得得得得得得得得得~~~","categories":[],"tags":[{"name":"努力 坚持","slug":"努力-坚持","permalink":"http://xiaojujing.com/tags/%E5%8A%AA%E5%8A%9B-%E5%9D%9A%E6%8C%81/"}]}],"categories":[],"tags":[{"name":"归并排序 堆排序","slug":"归并排序-堆排序","permalink":"http://xiaojujing.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"Nginx 模板","slug":"Nginx-模板","permalink":"http://xiaojujing.com/tags/Nginx-%E6%A8%A1%E6%9D%BF/"},{"name":"内存管理 Tomcat 垃圾回收","slug":"内存管理-Tomcat-垃圾回收","permalink":"http://xiaojujing.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Tomcat-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"编译 类加载 双亲委派","slug":"编译-类加载-双亲委派","permalink":"http://xiaojujing.com/tags/%E7%BC%96%E8%AF%91-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"},{"name":"SDK集成","slug":"SDK集成","permalink":"http://xiaojujing.com/tags/SDK%E9%9B%86%E6%88%90/"},{"name":"IO流","slug":"IO流","permalink":"http://xiaojujing.com/tags/IO%E6%B5%81/"},{"name":"排序","slug":"排序","permalink":"http://xiaojujing.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"努力 坚持","slug":"努力-坚持","permalink":"http://xiaojujing.com/tags/%E5%8A%AA%E5%8A%9B-%E5%9D%9A%E6%8C%81/"}]}