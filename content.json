{"meta":{"title":"xiaojujing's blogs","subtitle":"","description":"some blogs of xiaojujing","author":"xiaojujing","url":"http://xiaojujing.com","root":"/"},"pages":[],"posts":[{"title":"JVM01","slug":"JVM01","date":"2020-12-01T11:38:38.000Z","updated":"2020-12-01T11:52:49.233Z","comments":true,"path":"2020/12/01/JVM01/","link":"","permalink":"http://xiaojujing.com/2020/12/01/JVM01/","excerpt":"","text":"JVM011、Java代码怎么运行 问题：怎么防止反编译？ ​ 回答这个问题前，首先我们要搞清楚：一个.java文件怎么变成.class文件的。 ​ Javac是一种编译器，能将一种语言规范转化成另外一种语言规范，通常编译器都是将便于人理解的语言规范转化成机器容易理解的语言规范，如C/C++或者汇编语言都是将源代码直接编译成目标机器码，这个目标机器代码是CPU直接执行的指令集合。这些指令集合也就是底层的一种语言规范。 ​ Javac的编译器也是将Java这种对人非常友好的编程语言编译成对对所有机器都非常友好的一种语言。这种语言不是针对某种机器或某个平台。怎么消除不同种类，不同平台之间的差异这个任务就有JVM来完成，而Javac的任务就是将Java源代码语言转化为JVM能够识别的一种语言，然后由JVM将JVM语言再转化成当前这个机器能够识别的机器语言。 ​ Javac的任务就是将Java源代码编译成Java字节码，也就是JVM能够识别的二进制代码，从表面看是将.java文件转化为.class文件。而实际上是将Java源代码转化成一连串二进制数字，这些二进制数字是有格式的，只有JVM能够真确的识别他们到底代表什么意思。 ​ 编译器把一种语言规范转化为另一种语言规范的这个过程需要哪些步骤？回答这个问题需要参照《编译原理》，总结过程如下： ​ 1）词法分析：读取源代码，一个字节一个字节的读进来，找出这些词法中我们定义的语言关键词如：if、else、while等，识别哪些if是合法的哪些是不合法的。这个步骤就是词法分析过程。 ​ 词法分析的结果：就是从源代码中找出了一些规范化的token流，就像人类语言中，给你一句话你要分辨出哪些是一个词语，哪些是标点符号，哪些是动词，哪些是名词。 ​ 2）语法分析：就是对词法分析中得到的token流进行语法分析，这一步就是检查这些关键词组合在一起是不是符合Java语言规范。如if的后面是不是紧跟着一个布尔型判断表达式。 ​ 语法分析的结果：就是形成一个符合Java语言规定的抽象语法树，抽象语法树是一个结构化的语法表达形式，它的作用是把语言的主要词法用一个结构化的形式组织在一起。这棵语法树可以被后面按照新的规则再重新组织。 ​ 3）语义分析：语法分析完成之后也就不存在语法问题了，语义分析的主要工作就是把一些难懂的，复杂的语法转化成更简单的语法。就如难懂的文言文转化为大家都懂的百话文，或者是注释一下一些不懂的成语。 ​ 语义分析结果：就是将复杂的语法转化为简单的语法，对应到Java就是将foreach转化为for循环，还有一些注释等。最后生成一棵抽象的语法树，这棵语法树也就更接近目标语言的语法规则。 ​ 4）字节码生成：将会根据经过注释的抽象语法树生成字节码，也就是将一个数据结构转化为另外一个数据结构。就像将所有的中文词语翻译成英文单词后按照英文语法组装文英文语句。代码生成器的结果就是生成符合java虚拟机规范的字节码。 ​ 因此我们可以认为既然.java文件向.class文件的编译是由编译原理执行的，那么可以说没有办法或者很难通过直接换一种编译方式来控制反编译的安全性，在这里我采取的办法是：加密。将编译好的文件加密处理，这样可以控制别人进行反编译时首先需要解密。 2、类加载过程 3、双亲委派机制 问题：Tomcat怎么执行动态部署的代码？ ​ Tomcat本身相当于一个JVM，那么肯定也是要用到类加载器，它首先会加载自己的所有配置，包括类的加载和初始化，当接收新的war包，依然基于双亲委派模型，在反编译后加载代码。","categories":[],"tags":[{"name":"编译 类加载 双亲委派","slug":"编译-类加载-双亲委派","permalink":"http://xiaojujing.com/tags/%E7%BC%96%E8%AF%91-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"}]},{"title":"day01探花交友","slug":"day01探花交友","date":"2020-11-27T15:32:01.000Z","updated":"2020-11-27T16:39:27.313Z","comments":true,"path":"2020/11/27/day01探花交友/","link":"","permalink":"http://xiaojujing.com/2020/11/27/day01%E6%8E%A2%E8%8A%B1%E4%BA%A4%E5%8F%8B/","excerpt":"day01探花交友​ 今天内容分为：阿里云短信服务、OSS、登陆模块开发。","text":"day01探花交友​ 今天内容分为：阿里云短信服务、OSS、登陆模块开发。 1、阿里云短信服务​ 短信服务是互联网项目的一个常用功能，通常在登陆时用于用户身份校验。对于我们普通的Java开发者，想要自己开发短信服务的功能想必是可以做到的，但是问题在于我们没有通信牌照，因此通常要选用第三方的SDK服务。阿里云短信服务SMS（Short Message Server）就是一个还不错的选项，对于快速集成SMS，阿里云提供了非常规范、详细的开发文档，具体请参照： 下面介绍一些注意细节： 1.1、签名​ 想要快速发送短信，首先要申请一个签名，这个签名其实同时也用于其他服务，其中包含了AccessKey ID和AccessKey Secret通常在各个功能的模板代码中必不可少，而且在申请完成时只显示一次，之后不再显示，这里请注意一定要保存好！！！ 2、OSS​ 对象存储OSS是阿里的一款海量、安全、高可靠的云存储服务，对于实际项目中的需要存储的大量的图片、视频、音频的文件提供了一套解决方案。 2.1、用户​ 这里注意OSS是要创建一个用户，并且为其添加管理权限。","categories":[],"tags":[]},{"title":"26_基础加强01","slug":"26-基础加强01","date":"2020-11-13T15:09:38.000Z","updated":"2020-11-13T15:11:01.282Z","comments":true,"path":"2020/11/13/26-基础加强01/","link":"","permalink":"http://xiaojujing.com/2020/11/13/26-%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA01/","excerpt":"1.类加载器1.1类加载器【理解】 作用 负责将.class文件（存储的物理文件）加载在到内存中","text":"1.类加载器1.1类加载器【理解】 作用 负责将.class文件（存储的物理文件）加载在到内存中 1.2类加载的过程【理解】 类加载时机 创建类的实例（对象） 调用类的类方法 访问类或者接口的类变量，或者为该类变量赋值 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 类加载过程 加载 通过包名 + 类名，获取这个类，准备用流进行传输 在这个类加载到内存中 加载完毕创建一个class对象 链接 验证 确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全 (文件中的信息是否符合虚拟机规范有没有安全隐患) 准备 负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值 (初始化静态变量) 解析 将类的二进制数据流中的符号引用替换为直接引用 (本类中如果用到了其他类，此时就需要找到对应的类) 初始化 根据程序员通过程序制定的主观计划去初始化类变量和其他资源 (静态变量赋值以及初始化其他资源) 小结 当一个类被使用的时候，才会加载到内存 类加载的过程: 加载、验证、准备、解析、初始化 1.3类加载的分类【理解】 分类 Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块 System class loader：系统类加载器,负责加载用户类路径上所指定的类库 类加载器的继承关系 System的父加载器为Platform Platform的父加载器为Bootstrap 代码演示 1234567891011121314151617public class ClassLoaderDemo1 &#123; public static void main(String[] args) &#123; //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); //获取系统类加载器的父加载器 --- 平台类加载器 ClassLoader classLoader1 = systemClassLoader.getParent(); //获取平台类加载器的父加载器 --- 启动类加载器 ClassLoader classLoader2 = classLoader1.getParent(); System.out.println(\"系统类加载器\" + systemClassLoader); System.out.println(\"平台类加载器\" + classLoader1); System.out.println(\"启动类加载器\" + classLoader2); &#125;&#125; 1.4双亲委派模型【理解】 介绍 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式 1.5ClassLoader 中的两个方法【应用】 方法介绍 方法名 说明 public static ClassLoader getSystemClassLoader() 获取系统类加载器 public InputStream getResourceAsStream(String name) 加载某一个资源文件 示例代码 123456789101112131415161718192021public class ClassLoaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; //static ClassLoader getSystemClassLoader() 获取系统类加载器 //InputStream getResourceAsStream(String name) 加载某一个资源文件 //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); //利用加载器去加载一个指定的文件 //参数：文件的路径（放在src的根目录下，默认去那里加载） //返回值：字节流。 InputStream is = systemClassLoader.getResourceAsStream(\"prop.properties\"); Properties prop = new Properties(); prop.load(is); System.out.println(prop); is.close(); &#125;&#125; 2.反射2.1反射的概述【理解】 反射机制 是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意属性和方法；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。 2.2获取Class类对象的三种方式【应用】 三种方式分类 类名.class属性 对象名.getClass()方法 Class.forName(全类名)方法 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void study()&#123; System.out.println(\"学生在学习\"); &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125;public class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //1.Class类中的静态方法forName(\"全类名\") //全类名:包名 + 类名 Class clazz = Class.forName(\"com.itheima.myreflect2.Student\"); System.out.println(clazz); //2.通过class属性来获取 Class clazz2 = Student.class; System.out.println(clazz2); //3.利用对象的getClass方法来获取class对象 //getClass方法是定义在Object类中. Student s = new Student(); Class clazz3 = s.getClass(); System.out.println(clazz3); System.out.println(clazz == clazz2); System.out.println(clazz2 == clazz3); &#125;&#125; 2.3反射获取构造方法并使用【应用】2.3.1Class类获取构造方法对象的方法 方法介绍 方法名 说明 Constructor&lt;?&gt;[] getConstructors() 返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[] getDeclaredConstructors() 返回所有构造方法对象的数组 Constructor getConstructor(Class&lt;?&gt;… parameterTypes) 返回单个公共构造方法对象 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 返回单个构造方法对象 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Student &#123; private String name; private int age; //私有的有参构造方法 private Student(String name) &#123; System.out.println(\"name的值为:\" + name); System.out.println(\"private...Student...有参构造方法\"); &#125; //公共的无参构造方法 public Student() &#123; System.out.println(\"public...Student...无参构造方法\"); &#125; //公共的有参构造方法 public Student(String name, int age) &#123; System.out.println(\"name的值为:\" + name + \"age的值为:\" + age); System.out.println(\"public...Student...有参构造方法\"); &#125;&#125;public class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; //method1(); //method2(); //method3(); //method4(); &#125; private static void method4() throws ClassNotFoundException, NoSuchMethodException &#123; // Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)：// 返回单个构造方法对象 //1.获取Class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); Constructor constructor = clazz.getDeclaredConstructor(String.class); System.out.println(constructor); &#125; private static void method3() throws ClassNotFoundException, NoSuchMethodException &#123; // Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)：// 返回单个公共构造方法对象 //1.获取Class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); //小括号中,一定要跟构造方法的形参保持一致. Constructor constructor1 = clazz.getConstructor(); System.out.println(constructor1); Constructor constructor2 = clazz.getConstructor(String.class, int.class); System.out.println(constructor2); //因为Student类中,没有只有一个int的构造,所以这里会报错. Constructor constructor3 = clazz.getConstructor(int.class); System.out.println(constructor3); &#125; private static void method2() throws ClassNotFoundException &#123; // Constructor&lt;?&gt;[] getDeclaredConstructors()：// 返回所有构造方法对象的数组 //1.获取Class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; &#125; private static void method1() throws ClassNotFoundException &#123; // Constructor&lt;?&gt;[] getConstructors()：// 返回所有公共构造方法对象的数组 //1.获取Class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); Constructor[] constructors = clazz.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; &#125;&#125; 2.3.2Constructor类用于创建对象的方法 方法介绍 方法名 说明 T newInstance(Object…initargs) 根据指定的构造方法创建对象 setAccessible(boolean flag) 设置为true,表示取消访问检查 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Student类同上一个示例,这里就不在重复提供了public class ReflectDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; //T newInstance(Object... initargs)：根据指定的构造方法创建对象 //method1(); //method2(); //method3(); //method4(); &#125; private static void method4() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; //获取一个私有的构造方法并创建对象 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); //2.获取一个私有化的构造方法. Constructor constructor = clazz.getDeclaredConstructor(String.class); //被private修饰的成员,不能直接使用的 //如果用反射强行获取并使用,需要临时取消访问检查 constructor.setAccessible(true); //3.直接创建对象 Student student = (Student) constructor.newInstance(\"zhangsan\"); System.out.println(student); &#125; private static void method3() throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; //简写格式 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); //2.在Class类中,有一个newInstance方法,可以利用空参直接创建一个对象 Student student = (Student) clazz.newInstance();//这个方法现在已经过时了,了解一下 System.out.println(student); &#125; private static void method2() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); //2.获取构造方法对象 Constructor constructor = clazz.getConstructor(); //3.利用空参来创建Student的对象 Student student = (Student) constructor.newInstance(); System.out.println(student); &#125; private static void method1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect3.Student\"); //2.获取构造方法对象 Constructor constructor = clazz.getConstructor(String.class, int.class); //3.利用newInstance创建Student的对象 Student student = (Student) constructor.newInstance(\"zhangsan\", 23); System.out.println(student); &#125;&#125; 2.3.3小结 获取class对象 三种方式: Class.forName(“全类名”), 类名.class, 对象名.getClass() 获取里面的构造方法对象 getConstructor (Class... parameterTypes) getDeclaredConstructor (Class… parameterTypes) 如果是public的，直接创建对象 newInstance(Object… initargs) 如果是非public的，需要临时取消检查，然后再创建对象 setAccessible(boolean) 暴力反射 2.4反射获取成员变量并使用【应用】2.4.1Class类获取成员变量对象的方法 方法分类 方法名 说明 Field[] getFields() 返回所有公共成员变量对象的数组 Field[] getDeclaredFields() 返回所有成员变量对象的数组 Field getField(String name) 返回单个公共成员变量对象 Field getDeclaredField(String name) 返回单个成员变量对象 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Student &#123; public String name; public int age; public String gender; private int money = 300; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", gender='\" + gender + '\\'' + \", money=\" + money + '&#125;'; &#125;&#125;public class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123; // method1(); //method2(); //method3(); //method4(); &#125; private static void method4() throws ClassNotFoundException, NoSuchFieldException &#123; // Field getDeclaredField(String name)：返回单个成员变量对象 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取money成员变量 Field field = clazz.getDeclaredField(\"money\"); //3.打印一下 System.out.println(field); &#125; private static void method3() throws ClassNotFoundException, NoSuchFieldException &#123; // Field getField(String name)：返回单个公共成员变量对象 //想要获取的成员变量必须是真实存在的 //且必须是public修饰的. //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取name这个成员变量 //Field field = clazz.getField(\"name\"); //Field field = clazz.getField(\"name1\"); Field field = clazz.getField(\"money\"); //3.打印一下 System.out.println(field); &#125; private static void method2() throws ClassNotFoundException &#123; // Field[] getDeclaredFields()：返回所有成员变量对象的数组 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取所有的Field对象 Field[] fields = clazz.getDeclaredFields(); //3.遍历 for (Field field : fields) &#123; System.out.println(field); &#125; &#125; private static void method1() throws ClassNotFoundException &#123; // Field[] getFields()：返回所有公共成员变量对象的数组 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取Field对象. Field[] fields = clazz.getFields(); //3.遍历 for (Field field : fields) &#123; System.out.println(field); &#125; &#125;&#125; 2.4.2Field类用于给成员变量赋值的方法 方法介绍 方法名 说明 void set(Object obj, Object value) 赋值 Object get(Object obj) 获取值 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Student类同上一个示例,这里就不在重复提供了public class ReflectDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException &#123;// Object get(Object obj) 返回由该 Field表示的字段在指定对象上的值。 //method1(); //method2(); &#125; private static void method2() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException &#123; //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取成员变量Field的对象 Field field = clazz.getDeclaredField(\"money\"); //3.取消一下访问检查 field.setAccessible(true); //4.调用get方法来获取值 //4.1创建一个对象 Student student = (Student) clazz.newInstance(); //4.2获取指定对象的money的值 Object o = field.get(student); //5.打印一下 System.out.println(o); &#125; private static void method1() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException &#123; // void set(Object obj, Object value)：给obj对象的成员变量赋值为value //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect4.Student\"); //2.获取name这个Field对象 Field field = clazz.getField(\"name\"); //3.利用set方法进行赋值. //3.1先创建一个Student对象 Student student = (Student) clazz.newInstance(); //3.2有了对象才可以给指定对象进行赋值 field.set(student,\"zhangsan\"); System.out.println(student); &#125;&#125; 2.5反射获取成员方法并使用【应用】2.5.1Class类获取成员方法对象的方法 方法分类 方法名 说明 Method[] getMethods() 返回所有公共成员方法对象的数组，包括继承的 Method[] getDeclaredMethods() 返回所有成员方法对象的数组，不包括继承的 Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 返回单个公共成员方法对象 Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回单个成员方法对象 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class Student &#123; //私有的，无参无返回值 private void show() &#123; System.out.println(\"私有的show方法，无参无返回值\"); &#125; //公共的，无参无返回值 public void function1() &#123; System.out.println(\"function1方法，无参无返回值\"); &#125; //公共的，有参无返回值 public void function2(String name) &#123; System.out.println(\"function2方法，有参无返回值,参数为\" + name); &#125; //公共的，无参有返回值 public String function3() &#123; System.out.println(\"function3方法，无参有返回值\"); return \"aaa\"; &#125; //公共的，有参有返回值 public String function4(String name) &#123; System.out.println(\"function4方法，有参有返回值,参数为\" + name); return \"aaa\"; &#125;&#125;public class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; //method1(); //method2(); //method3(); //method4(); //method5(); &#125; private static void method5() throws ClassNotFoundException, NoSuchMethodException &#123; // Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)：// 返回单个成员方法对象 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取一个成员方法show Method method = clazz.getDeclaredMethod(\"show\"); //3.打印一下 System.out.println(method); &#125; private static void method4() throws ClassNotFoundException, NoSuchMethodException &#123; //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取一个有形参的方法function2 Method method = clazz.getMethod(\"function2\", String.class); //3.打印一下 System.out.println(method); &#125; private static void method3() throws ClassNotFoundException, NoSuchMethodException &#123; // Method getMethod(String name, Class&lt;?&gt;... parameterTypes) ：// 返回单个公共成员方法对象 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取成员方法function1 Method method1 = clazz.getMethod(\"function1\"); //3.打印一下 System.out.println(method1); &#125; private static void method2() throws ClassNotFoundException &#123; // Method[] getDeclaredMethods()：// 返回所有成员方法对象的数组，不包括继承的 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取Method对象 Method[] methods = clazz.getDeclaredMethods(); //3.遍历一下数组 for (Method method : methods) &#123; System.out.println(method); &#125; &#125; private static void method1() throws ClassNotFoundException &#123; // Method[] getMethods()：返回所有公共成员方法对象的数组，包括继承的 //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取成员方法对象 Method[] methods = clazz.getMethods(); //3.遍历 for (Method method : methods) &#123; System.out.println(method); &#125; &#125;&#125; 2.5.2Method类用于执行方法的方法 方法介绍 方法名 说明 Object invoke(Object obj, Object… args) 运行方法 参数一: 用obj对象调用该方法 参数二: 调用方法的传递的参数(如果没有就不写) 返回值: 方法的返回值(如果没有就不写) 示例代码 1234567891011121314151617181920public class ReflectDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;// Object invoke(Object obj, Object... args)：运行方法// 参数一：用obj对象调用该方法// 参数二：调用方法的传递的参数（如果没有就不写）// 返回值：方法的返回值（如果没有就不写） //1.获取class对象 Class clazz = Class.forName(\"com.itheima.myreflect5.Student\"); //2.获取里面的Method对象 function4 Method method = clazz.getMethod(\"function4\", String.class); //3.运行function4方法就可以了 //3.1创建一个Student对象,当做方法的调用者 Student student = (Student) clazz.newInstance(); //3.2运行方法 Object result = method.invoke(student, \"zhangsan\"); //4.打印一下返回值 System.out.println(result); &#125;&#125;","categories":[],"tags":[]},{"title":"25_网络编程","slug":"25-网络编程","date":"2020-11-13T15:09:20.000Z","updated":"2020-11-13T15:10:14.375Z","comments":true,"path":"2020/11/13/25-网络编程/","link":"","permalink":"http://xiaojujing.com/2020/11/13/25-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"1.网络编程入门1.1 网络编程概述【理解】 计算机网络","text":"1.网络编程入门1.1 网络编程概述【理解】 计算机网络 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统 网络编程 在网络通信协议下，不同计算机上运行的程序，可以进行数据传输 1.2 网络编程三要素【理解】 IP地址 要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识 端口 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识 协议 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议 1.3 IP地址【理解】IP地址：是网络中设备的唯一标识 IP地址分为两大类 IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题 DOS常用命令： ipconfig：查看本机IP地址 ping IP地址：检查网络是否连通 特殊IP地址： 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用 1.4 InetAddress【应用】InetAddress：此类表示Internet协议（IP）地址 相关方法 方法名 说明 static InetAddress getByName(String host) 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 String getHostName() 获取此IP地址的主机名 String getHostAddress() 返回文本显示中的IP地址字符串 代码演示 1234567891011121314public class InetAddressDemo &#123; public static void main(String[] args) throws UnknownHostException &#123; //InetAddress address = InetAddress.getByName(\"itheima\"); InetAddress address = InetAddress.getByName(\"192.168.1.66\"); //public String getHostName()：获取此IP地址的主机名 String name = address.getHostName(); //public String getHostAddress()：返回文本显示中的IP地址字符串 String ip = address.getHostAddress(); System.out.println(\"主机名：\" + name); System.out.println(\"IP地址：\" + ip); &#125;&#125; 1.5 端口和协议【理解】 端口 设备上应用程序的唯一标识 端口号 用两个字节表示的整数，它的取值范围是065535。其中，01023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败 协议 计算机网络中，连接和通信的规则被称为网络通信协议 UDP协议 用户数据报协议(User Datagram Protocol) UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议 TCP协议 传输控制协议 (Transmission Control Protocol) TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手” 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠 第一次握手，客户端向服务器端发出连接请求，等待服务器确认 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 第三次握手，客户端再次向服务器端发送确认信息，确认连接 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等 2.UDP通信程序2.1 UDP发送数据【应用】 Java中的UDP通信 UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念 Java提供了DatagramSocket类作为基于UDP协议的Socket 构造方法 方法名 说明 DatagramSocket() 创建数据报套接字并将其绑定到本机地址上的任何可用端口 DatagramPacket(byte[] buf,int len,InetAddress add,int port) 创建数据包,发送长度为len的数据包到指定主机的指定端口 相关方法 方法名 说明 void send(DatagramPacket p) 发送数据报包 void close() 关闭数据报套接字 void receive(DatagramPacket p) 从此套接字接受数据报包 发送数据的步骤 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包 调用DatagramSocket对象的方法发送数据 关闭发送端 代码演示 12345678910111213141516171819202122public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口 DatagramSocket ds = new DatagramSocket(); //创建数据，并把数据打包 //DatagramPacket(byte[] buf, int length, InetAddress address, int port) //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。 byte[] bys = \"hello,udp,我来了\".getBytes(); DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName(\"127.0.0.1\"),10086); //调用DatagramSocket对象的方法发送数据 //void send(DatagramPacket p) 从此套接字发送数据报包 ds.send(dp); //关闭发送端 //void close() 关闭此数据报套接字 ds.close(); &#125;&#125; 2.2UDP接收数据【应用】 接收数据的步骤 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 构造方法 方法名 说明 DatagramPacket(byte[] buf, int len) 创建一个DatagramPacket用于接收长度为len的数据包 相关方法 方法名 说明 byte[] getData() 返回数据缓冲区 int getLength() 返回要发送的数据的长度或接收的数据的长度 示例代码 1234567891011121314151617public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println(\"数据是：\" + new String(dp.getData(), 0, dp.getLength())); &#125; &#125;&#125; 2.3UDP通信程序练习【应用】 案例需求 UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束 UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* UDP发送数据： 数据来自于键盘录入，直到输入的数据是886，发送数据结束 */public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); //键盘录入数据 Scanner sc = new Scanner(System.in); while (true) &#123; String s = sc.nextLine(); //输入的数据是886，发送数据结束 if (\"886\".equals(s)) &#123; break; &#125; //创建数据，并把数据打包 byte[] bys = s.getBytes(); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName(\"192.168.1.66\"), 12345); //调用DatagramSocket对象的方法发送数据 ds.send(dp); &#125; //关闭发送端 ds.close(); &#125;&#125;/* UDP接收数据： 因为接收端不知道发送端什么时候停止发送，故采用死循环接收 */public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) &#123; //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println(\"数据是：\" + new String(dp.getData(), 0, dp.getLength())); &#125; //关闭接收端// ds.close(); &#125;&#125; 2.4UDP三种通讯方式【理解】 单播 单播用于两个主机之间的端对端通信 组播 组播用于对一组特定的主机进行通信 广播 广播用于一个主机对整个局域网上所有主机上的数据通信 2.5UDP组播实现【理解】 实现步骤 发送端 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包(DatagramPacket) 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) 释放资源 接收端 创建接收端Socket对象(MulticastSocket) 创建一个箱子,用于接收数据 把当前计算机绑定一个组播地址 将数据接收到箱子中 解析数据包,并打印数据 释放资源 代码实现 123456789101112131415161718192021222324252627282930313233343536// 发送端public class ClinetDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); String s = \"hello 组播\"; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName(\"224.0.1.0\"); int port = 10000; // 2. 创建数据，并把数据打包(DatagramPacket) DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) ds.send(dp); // 4. 释放资源 ds.close(); &#125;&#125;// 接收端public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建接收端Socket对象(MulticastSocket) MulticastSocket ms = new MulticastSocket(10000); // 2. 创建一个箱子,用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中. ms.joinGroup(InetAddress.getByName(\"224.0.1.0\")); // 4. 将数据接收到箱子中 ms.receive(dp); // 5. 解析数据包,并打印数据 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 6. 释放资源 ms.close(); &#125;&#125; 2.6UDP广播实现【理解】 实现步骤 发送端 创建发送端Socket对象(DatagramSocket) 创建存储数据的箱子,将广播地址封装进去 发送数据 释放资源 接收端 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 代码实现 12345678910111213141516171819202122232425262728293031323334// 发送端public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建发送端Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); // 2. 创建存储数据的箱子,将广播地址封装进去 String s = \"广播 hello\"; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName(\"255.255.255.255\"); int port = 10000; DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); // 3. 发送数据 ds.send(dp); // 4. 释放资源 ds.close(); &#125;&#125;// 接收端public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(10000); // 2. 创建一个数据包，用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 调用DatagramSocket对象的方法接收数据 ds.receive(dp); // 4. 解析数据包，并把数据在控制台显示 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 5. 关闭接收端 ds.close(); &#125;&#125; 3.TCP通信程序3.1TCP发送数据【应用】 Java中的TCP通信 Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。 Java为客户端提供了Socket类，为服务器端提供了ServerSocket类 构造方法 方法名 说明 Socket(InetAddress address,int port) 创建流套接字并将其连接到指定IP指定端口号 Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 相关方法 方法名 说明 InputStream getInputStream() 返回此套接字的输入流 OutputStream getOutputStream() 返回此套接字的输出流 示例代码 123456789101112131415public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; //创建客户端的Socket对象(Socket) //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 Socket s = new Socket(\"127.0.0.1\",10000); //获取输出流，写数据 //OutputStream getOutputStream() 返回此套接字的输出流 OutputStream os = s.getOutputStream(); os.write(\"hello,tcp,我来了\".getBytes()); //释放资源 s.close(); &#125;&#125; 3.2TCP接收数据【应用】 构造方法 方法名 说明 ServletSocket(int port) 创建绑定到指定端口的服务器套接字 相关方法 方法名 说明 Socket accept() 监听要连接到此的套接字并接受它 注意事项 accept方法是阻塞的,作用就是等待客户端连接 客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接 针对客户端来讲,是往外写的,所以是输出流针对服务器来讲,是往里读的,所以是输入流 read方法也是阻塞的 客户端在关流的时候,还多了一个往服务器写结束标记的动作 最后一步断开连接,通过四次挥手协议保证连接终止 三次握手和四次挥手 三次握手 四次挥手 示例代码 123456789101112131415161718192021public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; //创建服务器端的Socket对象(ServerSocket) //ServerSocket(int port) 创建绑定到指定端口的服务器套接字 ServerSocket ss = new ServerSocket(10000); //Socket accept() 侦听要连接到此套接字并接受它 Socket s = ss.accept(); //获取输入流，读数据，并把数据显示在控制台 InputStream is = s.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); String data = new String(bys,0,len); System.out.println(\"数据是：\" + data); //释放资源 s.close(); ss.close(); &#125;&#125; 3.3TCP程序练习【应用】 案例需求 客户端：发送数据，接受服务器反馈 服务器：收到消息后给出反馈 案例分析 客户端创建对象，使用输出流输出数据 服务端创建对象，使用输入流接受数据 服务端使用输出流给出反馈数据 客户端使用输入流接受反馈数据 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 客户端public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(\"127.0.0.1\",10000); OutputStream os = socket.getOutputStream(); os.write(\"hello\".getBytes()); // os.close();如果在这里关流,会导致整个socket都无法使用 socket.shutdownOutput();//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; while((line = br.readLine())!=null)&#123; System.out.println(line); &#125; br.close(); os.close(); socket.close(); &#125;&#125;// 服务器public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); Socket accept = ss.accept(); InputStream is = accept.getInputStream(); int b; while((b = is.read())!=-1)&#123; System.out.println((char) b); &#125; System.out.println(\"看看我执行了吗?\"); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"你谁啊?\"); bw.newLine(); bw.flush(); bw.close(); is.close(); accept.close(); ss.close(); &#125;&#125; 3.4TCP程序文件上传练习【应用】 案例需求 客户端：数据来自于本地文件，接收服务器反馈 服务器：接收到的数据写入本地文件，给出反馈 案例分析 创建客户端对象，创建输入流对象指向文件，每读一次数据就给服务器输出一次数据，输出结束后使用shutdownOutput()方法告知服务端传输结束 创建服务器对象，创建输出流对象指向文件，每接受一次数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息 客户端接受服务端的回馈信息 相关方法 方法名 说明 void shutdownInput() 将此套接字的输入流放置在“流的末尾” void shutdownOutput() 禁止用此套接字的输出流 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 客户端public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(\"127.0.0.1\",10000); //是本地的流,用来读取本地文件的. BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"socketmodule\\\\ClientDir\\\\1.jpg\")); //写到服务器 --- 网络中的流 OutputStream os = socket.getOutputStream(); BufferedOutputStream bos = new BufferedOutputStream(os); int b; while((b = bis.read())!=-1)&#123; bos.write(b);//通过网络写到服务器中 &#125; bos.flush(); //给服务器一个结束标记,告诉服务器文件已经传输完毕 socket.shutdownOutput(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; while((line = br.readLine()) !=null)&#123; System.out.println(line); &#125; bis.close(); socket.close(); &#125;&#125;// 服务器public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"socketmodule\\\\ServerDir\\\\copy.jpg\")); int b; while((b = bis.read()) !=-1)&#123; bos.write(b); &#125; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); bos.close(); accept.close(); ss.close(); &#125;&#125; 3.5TCP程序服务器优化【应用】 优化方案一 需求 服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。 解决方案 使用循环 代码实现 123456789101112131415161718192021222324252627282930// 服务器代码如下,客户端代码同上个案例,此处不再给出public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); while (true) &#123; Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"optimizeserver\\\\ServerDir\\\\copy.jpg\")); int b; while((b = bis.read()) !=-1)&#123; bos.write(b); &#125; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); bos.close(); accept.close(); &#125; //ss.close(); &#125;&#125; 优化方案二 需求 第二次上传文件的时候，会把第一次的文件给覆盖。 解决方案 UUID. randomUUID()方法生成随机的文件名 代码实现 123456789101112131415161718192021222324252627282930// 服务器代码如下,客户端代码同上个案例,此处不再给出public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); while (true) &#123; Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"optimizeserver\\\\ServerDir\\\\\" + UUID.randomUUID().toString() + \".jpg\")); int b; while((b = bis.read()) !=-1)&#123; bos.write(b); &#125; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); bos.close(); accept.close(); &#125; //ss.close(); &#125;&#125; 优化方案三 需求 使用循环虽然可以让服务器处理多个客户端请求。但是还是无法同时跟多个客户端进行通信。 解决方案 开启多线程处理 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 线程任务类public class ThreadSocket implements Runnable &#123; private Socket acceptSocket; public ThreadSocket(Socket accept) &#123; this.acceptSocket = accept; &#125; @Override public void run() &#123; BufferedOutputStream bos = null; try &#123; //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(acceptSocket.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 bos = new BufferedOutputStream(new FileOutputStream(\"optimizeserver\\\\ServerDir\\\\\" + UUID.randomUUID().toString() + \".jpg\")); int b; while((b = bis.read()) !=-1)&#123; bos.write(b); &#125; BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(acceptSocket.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (acceptSocket != null)&#123; try &#123; acceptSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;// 服务器代码public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); while (true) &#123; Socket accept = ss.accept(); ThreadSocket ts = new ThreadSocket(accept); new Thread(ts).start(); &#125; //ss.close(); &#125;&#125; 优化方案四 需求 使用多线程虽然可以让服务器同时处理多个客户端请求。但是资源消耗太大。 解决方案 加入线程池 代码实现 1234567891011121314151617181920212223// 服务器代码如下,线程任务类代码同上,此处不再给出public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); ThreadPoolExecutor pool = new ThreadPoolExecutor( 3,//核心线程数量 10, //线程池的总数量 60, //临时线程空闲时间 TimeUnit.SECONDS, //临时线程空闲时间的单位 new ArrayBlockingQueue&lt;&gt;(5),//阻塞队列 Executors.defaultThreadFactory(),//创建线程的方式 new ThreadPoolExecutor.AbortPolicy()//任务拒绝策略 ); while (true) &#123; Socket accept = ss.accept(); ThreadSocket ts = new ThreadSocket(accept); //new Thread(ts).start(); pool.submit(ts); &#125; //ss.close(); &#125;&#125;","categories":[],"tags":[]},{"title":"24_多线程02","slug":"24-多线程02","date":"2020-11-12T13:18:36.000Z","updated":"2020-11-12T13:21:02.390Z","comments":true,"path":"2020/11/12/24-多线程02/","link":"","permalink":"http://xiaojujing.com/2020/11/12/24-%E5%A4%9A%E7%BA%BF%E7%A8%8B02/","excerpt":"1.线程池1.1 线程状态介绍当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程","text":"1.线程池1.1 线程状态介绍当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程 状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下： 123456789101112131415161718192021222324252627282930public class Thread &#123; public enum State &#123; /* 新建 */ NEW , /* 可运行状态 */ RUNNABLE , /* 阻塞状态 */ BLOCKED , /* 无限等待状态 */ WAITING , /* 计时等待 */ TIMED_WAITING , /* 终止 */ TERMINATED; &#125; // 获取当前线程的状态 public State getState() &#123; return jdk.internal.misc.VM.toThreadState(threadStatus); &#125; &#125; 通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下 线程状态 具体含义 NEW 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 RUNNABLE 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 BLOCKED 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 WAITING 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 TIMED_WAITING 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 TERMINATED 一个完全运行完成的线程的状态。也称之为终止状态、结束状态 各个状态的转换，如下图所示： 1.2 线程池-基本原理概述 : ​ 提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。 线程池存在的意义： ​ 系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系 ​ 统资源的消耗，这样就有点”舍本逐末”了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就 ​ 会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。 线程池的设计思路 : 准备一个任务容器 一次性启动多个(2个)消费者线程 刚开始任务容器是空的，所以线程都在wait 直到一个外部线程向这个任务容器中扔了一个”任务”，就会有一个消费者线程被唤醒 这个消费者线程取出”任务”，并且执行这个任务，执行完毕后，继续等待下一次任务的到来 1.3 线程池-Executors默认线程池概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。 我们可以使用Executors中所提供的静态方法来创建线程池 ​ static ExecutorService newCachedThreadPool() 创建一个默认的线程池​ static newFixedThreadPool(int nThreads) 创建一个指定最多线程数量的线程池 代码实现 : 123456789101112131415161718192021222324252627282930package com.itheima.mythreadpool;//static ExecutorService newCachedThreadPool() 创建一个默认的线程池//static newFixedThreadPool(int nThreads) 创建一个指定最多线程数量的线程池import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class MyThreadPoolDemo &#123; public static void main(String[] args) throws InterruptedException &#123; //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值. ExecutorService executorService = Executors.newCachedThreadPool(); //Executors --- 可以帮助我们创建线程池对象 //ExecutorService --- 可以帮助我们控制线程池 executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + \"在执行了\"); &#125;); //Thread.sleep(2000); executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + \"在执行了\"); &#125;); executorService.shutdown(); &#125;&#125; 1.4 线程池-Executors创建指定上限的线程池使用Executors中所提供的静态方法来创建线程池 ​ static ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池 代码实现 : 1234567891011121314151617181920212223242526272829package com.itheima.mythreadpool;//static ExecutorService newFixedThreadPool(int nThreads)//创建一个指定最多线程数量的线程池import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;public class MyThreadPoolDemo2 &#123; public static void main(String[] args) &#123; //参数不是初始值而是最大值 ExecutorService executorService = Executors.newFixedThreadPool(10); ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService; System.out.println(pool.getPoolSize());//0 executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + \"在执行了\"); &#125;); executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + \"在执行了\"); &#125;); System.out.println(pool.getPoolSize());//2// executorService.shutdown(); &#125;&#125; 1.5 线程池-ThreadPoolExecutor创建线程池对象 : ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略); 代码实现 : 1234567891011121314151617181920212223package com.itheima.mythreadpool;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class MyThreadPoolDemo3 &#123;// 参数一：核心线程数量// 参数二：最大线程数// 参数三：空闲线程最大存活时间// 参数四：时间单位// 参数五：任务队列// 参数六：创建线程工厂// 参数七：任务的拒绝策略 public static void main(String[] args) &#123; ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy()); pool.submit(new MyRunnable()); pool.submit(new MyRunnable()); pool.shutdown(); &#125;&#125; 1.6 线程池-参数详解 123456789101112131415public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize： 核心线程的最大值，不能小于0maximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize &gt;= corePoolSizekeepAliveTime： 空闲线程最大存活时间,不能小于0unit： 时间单位workQueue： 任务队列，不能为nullthreadFactory： 创建线程工厂,不能为null handler： 任务的拒绝策略,不能为null 1.7 线程池-非默认任务拒绝策略RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。 1234ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。是默认的策略。ThreadPoolExecutor.DiscardPolicy： 丢弃任务，但是不抛出异常 这是不推荐的做法。ThreadPoolExecutor.DiscardOldestPolicy： 抛弃队列中等待最久的任务 然后把当前任务加入队列中。ThreadPoolExecutor.CallerRunsPolicy: 调用任务的run()方法绕过线程池直接执行。 注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数 案例演示1：演示ThreadPoolExecutor.AbortPolicy任务处理策略 123456789101112131415161718public class ThreadPoolExecutorDemo01 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ; // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常 for(int x = 0 ; x &lt; 5 ; x++) &#123; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"----&gt;&gt; 执行了任务\"); &#125;); &#125; &#125;&#125; 控制台输出结果 1234pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务 控制台报错，仅仅执行了4个任务，有一个任务被丢弃了 案例演示2：演示ThreadPoolExecutor.DiscardPolicy任务处理策略 12345678910111213141516public class ThreadPoolExecutorDemo02 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ; // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错 for(int x = 0 ; x &lt; 5 ; x++) &#123; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"----&gt;&gt; 执行了任务\"); &#125;); &#125; &#125;&#125; 控制台输出结果 1234pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务 控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了 案例演示3：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略 123456789101112131415161718public class ThreadPoolExecutorDemo02 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor; threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy()); // 提交5个任务 for(int x = 0 ; x &lt; 5 ; x++) &#123; // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰 final int y = x ; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"----&gt;&gt; 执行了任务\" + y); &#125;); &#125; &#125;&#125; 控制台输出结果 1234pool-1-thread-2----&gt;&gt; 执行了任务2pool-1-thread-1----&gt;&gt; 执行了任务0pool-1-thread-3----&gt;&gt; 执行了任务3pool-1-thread-1----&gt;&gt; 执行了任务4 由于任务1在线程池中等待时间最长，因此任务1被丢弃。 案例演示4：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略 123456789101112131415161718public class ThreadPoolExecutorDemo04 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor; threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy()); // 提交5个任务 for(int x = 0 ; x &lt; 5 ; x++) &#123; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"----&gt;&gt; 执行了任务\"); &#125;); &#125; &#125;&#125; 控制台输出结果 12345pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务pool-1-thread-1----&gt;&gt; 执行了任务main----&gt;&gt; 执行了任务 通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。 2. 原子性2.1 volatile-问题代码分析 : 12345678910111213package com.itheima.myvolatile;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); t1.setName(\"小路同学\"); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(\"小皮同学\"); t2.start(); &#125;&#125; 12345package com.itheima.myvolatile;public class Money &#123; public static int money = 100000;&#125; 123456789101112package com.itheima.myvolatile;public class MyThread1 extends Thread &#123; @Override public void run() &#123; while(Money.money == 100000)&#123; &#125; System.out.println(\"结婚基金已经不是十万了\"); &#125;&#125; 1234567891011121314package com.itheima.myvolatile;public class MyThread2 extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Money.money = 90000; &#125;&#125; 程序问题 : 女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。 2.2 volatile解决以上案例出现的问题 : ​ 当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 ​ 1，堆内存是唯一的，每一个线程都有自己的线程栈。 ​ 2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。 ​ 3 ，在线程中，每一次使用是从变量的副本中获取的。 Volatile关键字 : 强制线程每次在使用的时候，都会看一下共享区域最新的值 代码实现 : 使用volatile关键字解决 12345678910111213package com.itheima.myvolatile;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); t1.setName(\"小路同学\"); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(\"小皮同学\"); t2.start(); &#125;&#125; 12345package com.itheima.myvolatile;public class Money &#123; public static volatile int money = 100000;&#125; 123456789101112package com.itheima.myvolatile;public class MyThread1 extends Thread &#123; @Override public void run() &#123; while(Money.money == 100000)&#123; &#125; System.out.println(\"结婚基金已经不是十万了\"); &#125;&#125; 1234567891011121314package com.itheima.myvolatile;public class MyThread2 extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Money.money = 90000; &#125;&#125; 2.3 synchronized解决synchronized解决 : ​ 1 ，线程获得锁 ​ 2 ，清空变量副本 ​ 3 ，拷贝共享变量最新的值到变量副本中 ​ 4 ，执行代码 ​ 5 ，将修改后变量副本中的值赋值给共享数据 ​ 6 ，释放锁 代码实现 : 12345678910111213package com.itheima.myvolatile2;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); t1.setName(\"小路同学\"); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(\"小皮同学\"); t2.start(); &#125;&#125; 123456package com.itheima.myvolatile2;public class Money &#123; public static Object lock = new Object(); public static volatile int money = 100000;&#125; 123456789101112131415package com.itheima.myvolatile2;public class MyThread1 extends Thread &#123; @Override public void run() &#123; while(true)&#123; synchronized (Money.lock)&#123; if(Money.money != 100000)&#123; System.out.println(\"结婚基金已经不是十万了\"); break; &#125; &#125; &#125; &#125;&#125; 12345678910111213141516package com.itheima.myvolatile2;public class MyThread2 extends Thread &#123; @Override public void run() &#123; synchronized (Money.lock) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Money.money = 90000; &#125; &#125;&#125; 2.4 原子性概述 : 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。 代码实现 : 12345678910111213141516171819202122232425package com.itheima.threadatom;public class AtomDemo &#123; public static void main(String[] args) &#123; MyAtomThread atom = new MyAtomThread(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(atom).start(); &#125; &#125;&#125;class MyAtomThread implements Runnable &#123; private volatile int count = 0; //送冰淇淋的数量 @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; //1,从共享数据中读取数据到本线程栈中. //2,修改本线程栈中变量副本的值 //3,会把本线程栈中变量副本的值赋值给共享数据. count++; System.out.println(\"已经送了\" + count + \"个冰淇淋\"); &#125; &#125;&#125; 代码总结 : count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断 2.5 volatile关键字不能保证原子性解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。 12345678910111213141516171819202122232425262728package com.itheima.threadatom2;public class AtomDemo &#123; public static void main(String[] args) &#123; MyAtomThread atom = new MyAtomThread(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(atom).start(); &#125; &#125;&#125;class MyAtomThread implements Runnable &#123; private volatile int count = 0; //送冰淇淋的数量 private Object lock = new Object(); @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; //1,从共享数据中读取数据到本线程栈中. //2,修改本线程栈中变量副本的值 //3,会把本线程栈中变量副本的值赋值给共享数据. synchronized (lock) &#123; count++; System.out.println(\"已经送了\" + count + \"个冰淇淋\"); &#125; &#125; &#125;&#125; 2.6 原子性_AtomicInteger概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变 量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解 使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类： AtomicBoolean： 原子更新布尔类型 AtomicInteger： 原子更新整型 AtomicLong： 原子更新长整型 以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下： 12345678public AtomicInteger()： 初始化一个默认值为0的原子型Integerpublic AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integerint get(): 获取值int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。int addAndGet(int data): 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 代码实现 : 12345678910111213141516package com.itheima.threadatom3;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomIntergerDemo1 &#123;// public AtomicInteger()： 初始化一个默认值为0的原子型Integer// public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer public static void main(String[] args) &#123; AtomicInteger ac = new AtomicInteger(); System.out.println(ac); AtomicInteger ac2 = new AtomicInteger(10); System.out.println(ac2); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.itheima.threadatom3;import java.lang.reflect.Field;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomIntergerDemo2 &#123;// int get(): 获取值// int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。// int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。// int addAndGet(int data): 以原子方式将参数与对象中的值相加，并返回结果。// int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 public static void main(String[] args) &#123;// AtomicInteger ac1 = new AtomicInteger(10);// System.out.println(ac1.get());// AtomicInteger ac2 = new AtomicInteger(10);// int andIncrement = ac2.getAndIncrement();// System.out.println(andIncrement);// System.out.println(ac2.get());// AtomicInteger ac3 = new AtomicInteger(10);// int i = ac3.incrementAndGet();// System.out.println(i);//自增后的值// System.out.println(ac3.get());// AtomicInteger ac4 = new AtomicInteger(10);// int i = ac4.addAndGet(20);// System.out.println(i);// System.out.println(ac4.get()); AtomicInteger ac5 = new AtomicInteger(100); int andSet = ac5.getAndSet(20); System.out.println(andSet); System.out.println(ac5.get()); &#125;&#125; 2.7 AtomicInteger-内存解析AtomicInteger原理 : 自旋锁 + CAS 算法 CAS算法： ​ 有3个操作数（内存值V， 旧的预期值A，要修改的值B） ​ 当旧的预期值A == 内存值 此时修改成功，将V改为B ​ 当旧的预期值A！=内存值 此时修改失败，不做任何操作 ​ 并重新获取现在的最新值（这个重新获取的动作就是自旋） 2.8 AtomicInteger-源码解析代码实现 : 1234567891011package com.itheima.threadatom4;public class AtomDemo &#123; public static void main(String[] args) &#123; MyAtomThread atom = new MyAtomThread(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(atom).start(); &#125; &#125;&#125; 123456789101112131415161718192021222324package com.itheima.threadatom4;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomThread implements Runnable &#123; //private volatile int count = 0; //送冰淇淋的数量 //private Object lock = new Object(); AtomicInteger ac = new AtomicInteger(0); @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; //1,从共享数据中读取数据到本线程栈中. //2,修改本线程栈中变量副本的值 //3,会把本线程栈中变量副本的值赋值给共享数据. //synchronized (lock) &#123;// count++;// ac++; int count = ac.incrementAndGet(); System.out.println(\"已经送了\" + count + \"个冰淇淋\"); // &#125; &#125; &#125;&#125; 源码解析 : 1234567891011121314151617181920212223242526//先自增，然后获取自增后的结果public final int incrementAndGet() &#123; //+ 1 自增后的结果 //this 就表示当前的atomicInteger（值） //1 自增一次 return U.getAndAddInt(this, VALUE, 1) + 1;&#125;public final int getAndAddInt(Object o, long offset, int delta) &#123; //v 旧值 int v; //自旋的过程 do &#123; //不断的获取旧值 v = getIntVolatile(o, offset); //如果这个方法的返回值为false，那么继续自旋 //如果这个方法的返回值为true，那么自旋结束 //o 表示的就是内存值 //v 旧值 //v + delta 修改后的值 &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta)); //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。 // 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。 //如果修改失败，那么继续自旋。 return v;&#125; 2.9 悲观锁和乐观锁synchronized和CAS的区别 : 相同点：在多线程情况下，都可以保证共享数据的安全性。 不同点：synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每 次操作共享数据之前，都会上锁。（悲观锁） ​ cas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。 ​ 如果别人修改过，那么我再次获取现在最新的值。 ​ 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁） 3. 并发工具类3.1 并发工具类-Hashtable​ Hashtable出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。 代码实现 : 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.mymap;import java.util.HashMap;import java.util.Hashtable;public class MyHashtableDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Hashtable&lt;String, String&gt; hm = new Hashtable&lt;&gt;(); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 25; i++) &#123; hm.put(i + \"\", i + \"\"); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 25; i &lt; 51; i++) &#123; hm.put(i + \"\", i + \"\"); &#125; &#125;); t1.start(); t2.start(); System.out.println(\"----------------------------\"); //为了t1和t2能把数据全部添加完毕 Thread.sleep(1000); //0-0 1-1 ..... 50- 50 for (int i = 0; i &lt; 51; i++) &#123; System.out.println(hm.get(i + \"\")); &#125;//0 1 2 3 .... 50 &#125;&#125; 3.2 并发工具类-ConcurrentHashMap基本使用​ ConcurrentHashMap出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。 基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。 体系结构 : 总结 : ​ 1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题 ​ 2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下 ​ 3，ConcurrentHashMap也是线程安全的，效率较高。 在JDK7和JDK8中，底层原理不一样。 代码实现 : 123456789101112131415161718192021222324252627282930313233343536package com.itheima.mymap;import java.util.Hashtable;import java.util.concurrent.ConcurrentHashMap;public class MyConcurrentHashMapDemo &#123; public static void main(String[] args) throws InterruptedException &#123; ConcurrentHashMap&lt;String, String&gt; hm = new ConcurrentHashMap&lt;&gt;(100); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 25; i++) &#123; hm.put(i + \"\", i + \"\"); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 25; i &lt; 51; i++) &#123; hm.put(i + \"\", i + \"\"); &#125; &#125;); t1.start(); t2.start(); System.out.println(\"----------------------------\"); //为了t1和t2能把数据全部添加完毕 Thread.sleep(1000); //0-0 1-1 ..... 50- 50 for (int i = 0; i &lt; 51; i++) &#123; System.out.println(hm.get(i + \"\")); &#125;//0 1 2 3 .... 50 &#125;&#125; 3.3 并发工具类-ConcurrentHashMap1.7原理 3.4 并发工具类-ConcurrentHashMap1.8原理 总结 : ​ 1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。 在第一次添加元素的时候创建哈希表 ​ 2，计算当前元素应存入的索引。 ​ 3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。 ​ 4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。 ​ 5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性 3.5 并发工具类-CountDownLatchCountDownLatch类 : 方法 解释 public CountDownLatch(int count) 参数传递线程数，表示等待线程数量 public void await() 让线程等待 public void countDown() 当前线程执行完毕 使用场景： 让某一条线程等待其他线程执行完毕之后再执行 代码实现 : 12345678910111213141516171819202122package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread1 extends Thread &#123; private CountDownLatch countDownLatch; public ChileThread1(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.吃饺子 for (int i = 1; i &lt;= 10; i++) &#123; System.out.println(getName() + \"在吃第\" + i + \"个饺子\"); &#125; //2.吃完说一声 //每一次countDown方法的时候，就让计数器-1 countDownLatch.countDown(); &#125;&#125; 123456789101112131415161718192021package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread2 extends Thread &#123; private CountDownLatch countDownLatch; public ChileThread2(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.吃饺子 for (int i = 1; i &lt;= 15; i++) &#123; System.out.println(getName() + \"在吃第\" + i + \"个饺子\"); &#125; //2.吃完说一声 //每一次countDown方法的时候，就让计数器-1 countDownLatch.countDown(); &#125;&#125; 123456789101112131415161718192021package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread3 extends Thread &#123; private CountDownLatch countDownLatch; public ChileThread3(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.吃饺子 for (int i = 1; i &lt;= 20; i++) &#123; System.out.println(getName() + \"在吃第\" + i + \"个饺子\"); &#125; //2.吃完说一声 //每一次countDown方法的时候，就让计数器-1 countDownLatch.countDown(); &#125;&#125; 1234567891011121314151617181920212223package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class MotherThread extends Thread &#123; private CountDownLatch countDownLatch; public MotherThread(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.等待 try &#123; //当计数器变成0的时候，会自动唤醒这里等待的线程。 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //2.收拾碗筷 System.out.println(\"妈妈在收拾碗筷\"); &#125;&#125; 123456789101112131415161718192021222324252627package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class MyCountDownLatchDemo &#123; public static void main(String[] args) &#123; //1.创建CountDownLatch的对象，需要传递给四个线程。 //在底层就定义了一个计数器，此时计数器的值就是3 CountDownLatch countDownLatch = new CountDownLatch(3); //2.创建四个线程对象并开启他们。 MotherThread motherThread = new MotherThread(countDownLatch); motherThread.start(); ChileThread1 t1 = new ChileThread1(countDownLatch); t1.setName(\"小明\"); ChileThread2 t2 = new ChileThread2(countDownLatch); t2.setName(\"小红\"); ChileThread3 t3 = new ChileThread3(countDownLatch); t3.setName(\"小刚\"); t1.start(); t2.start(); t3.start(); &#125;&#125; 总结 : ​ 1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。 ​ 2. await()：让线程等待，当计数器为0时，会唤醒等待的线程 ​ 3. countDown()： 线程执行完毕时调用，会将计数器-1。 3.6 并发工具类-Semaphore使用场景 : ​ 可以控制访问特定资源的线程数量。 实现步骤 : ​ 1，需要有人管理这个通道 ​ 2，当有车进来了，发通行许可证 ​ 3，当车出去了，收回通行许可证 ​ 4，如果通行许可证发完了，那么其他车辆只能等着 代码实现 : 1234567891011121314151617181920212223package com.itheima.mysemaphore;import java.util.concurrent.Semaphore;public class MyRunnable implements Runnable &#123; //1.获得管理员对象， private Semaphore semaphore = new Semaphore(2); @Override public void run() &#123; //2.获得通行证 try &#123; semaphore.acquire(); //3.开始行驶 System.out.println(\"获得了通行证开始行驶\"); Thread.sleep(2000); System.out.println(\"归还通行证\"); //4.归还通行证 semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011package com.itheima.mysemaphore;public class MySemaphoreDemo &#123; public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(mr).start(); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"23_多线程01","slug":"23-多线程01","date":"2020-11-12T13:18:22.000Z","updated":"2020-11-12T13:20:16.433Z","comments":true,"path":"2020/11/12/23-多线程01/","link":"","permalink":"http://xiaojujing.com/2020/11/12/23-%E5%A4%9A%E7%BA%BF%E7%A8%8B01/","excerpt":"1.实现多线程1.1简单了解多线程【理解】是指从软件或者硬件上实现多个线程并发执行的技术。","text":"1.实现多线程1.1简单了解多线程【理解】是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。 1.2并发和并行【理解】 并行：在同一时刻，有多个指令在多个CPU上同时执行。 并发：在同一时刻，有多个指令在单个CPU上交替执行。 1.3进程和线程【理解】 进程：是正在运行的程序 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的并发性：任何进程都可以同其他进程一起并发执行 线程：是进程中的单个顺序控制流，是一条执行路径 ​ 单线程：一个进程如果只有一条执行路径，则称为单线程程序 ​ 多线程：一个进程如果有多条执行路径，则称为多线程程序 ​ 1.4实现多线程方式一：继承Thread类【应用】 方法介绍 方法名 说明 void run() 在线程开启后，此方法将被调用执行 void start() 使此线程开始执行，Java虚拟机会调用run方法() 实现步骤 定义一个类MyThread继承Thread类 在MyThread类中重写run()方法 创建MyThread类的对象 启动线程 代码演示 123456789101112131415161718192021public class MyThread extends Thread &#123; @Override public void run() &#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(i); &#125; &#125;&#125;public class MyThreadDemo &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); MyThread my2 = new MyThread();// my1.run();// my2.run(); //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法 my1.start(); my2.start(); &#125;&#125; 两个小问题 为什么要重写run()方法？ 因为run()是用来封装被线程执行的代码 run()方法和start()方法的区别？ run()：封装线程执行的代码，直接调用，相当于普通方法的调用 start()：启动线程；然后由JVM调用此线程的run()方法 1.5实现多线程方式二：实现Runnable接口【应用】 Thread构造方法 方法名 说明 Thread(Runnable target) 分配一个新的Thread对象 Thread(Runnable target, String name) 分配一个新的Thread对象 实现步骤 定义一个类MyRunnable实现Runnable接口 在MyRunnable类中重写run()方法 创建MyRunnable类的对象 创建Thread类的对象，把MyRunnable对象作为构造方法的参数 启动线程 代码演示 1234567891011121314151617181920212223242526public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(Thread.currentThread().getName()+\":\"+i); &#125; &#125;&#125;public class MyRunnableDemo &#123; public static void main(String[] args) &#123; //创建MyRunnable类的对象 MyRunnable my = new MyRunnable(); //创建Thread类的对象，把MyRunnable对象作为构造方法的参数 //Thread(Runnable target)// Thread t1 = new Thread(my);// Thread t2 = new Thread(my); //Thread(Runnable target, String name) Thread t1 = new Thread(my,\"坦克\"); Thread t2 = new Thread(my,\"飞机\"); //启动线程 t1.start(); t2.start(); &#125;&#125; 1.6实现多线程方式三: 实现Callable接口【应用】 方法介绍 方法名 说明 V call() 计算结果，如果无法计算结果，则抛出一个异常 FutureTask(Callable callable) 创建一个 FutureTask，一旦运行就执行给定的 Callable V get() 如有必要，等待计算完成，然后获取其结果 实现步骤 定义一个类MyCallable实现Callable接口 在MyCallable类中重写call()方法 创建MyCallable类的对象 创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数 创建Thread类的对象，把FutureTask对象作为构造方法的参数 启动线程 再调用get方法，就可以获取线程结束之后的结果。 代码演示 12345678910111213141516171819202122232425262728293031public class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"跟女孩表白\" + i); &#125; //返回值就表示线程运行完毕之后的结果 return \"答应\"; &#125;&#125;public class Demo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //线程开启之后需要执行里面的call方法 MyCallable mc = new MyCallable(); //Thread t1 = new Thread(mc); //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象 FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(mc); //创建线程对象 Thread t1 = new Thread(ft); String s = ft.get(); //开启线程 t1.start(); //String s = ft.get(); System.out.println(s); &#125;&#125; 三种实现方式的对比 实现Runnable、Callable接口 好处: 扩展性强，实现该接口的同时还可以继承其他的类 缺点: 编程相对复杂，不能直接使用Thread类中的方法 继承Thread类 好处: 编程比较简单，可以直接使用Thread类中的方法 缺点: 可以扩展性较差，不能再继承其他的类 1.7设置和获取线程名称【应用】 方法介绍 方法名 说明 void setName(String name) 将此线程的名称更改为等于参数name String getName() 返回此线程的名称 Thread currentThread() 返回对当前正在执行的线程对象的引用 代码演示 123456789101112131415161718192021222324252627282930313233public class MyThread extends Thread &#123; public MyThread() &#123;&#125; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(getName()+\":\"+i); &#125; &#125;&#125;public class MyThreadDemo &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); MyThread my2 = new MyThread(); //void setName(String name)：将此线程的名称更改为等于参数 name my1.setName(\"高铁\"); my2.setName(\"飞机\"); //Thread(String name) MyThread my1 = new MyThread(\"高铁\"); MyThread my2 = new MyThread(\"飞机\"); my1.start(); my2.start(); //static Thread currentThread() 返回对当前正在执行的线程对象的引用 System.out.println(Thread.currentThread().getName()); &#125;&#125; 1.8线程休眠【应用】 相关方法 方法名 说明 static void sleep(long millis) 使当前正在执行的线程停留（暂停执行）指定的毫秒数 代码演示 1234567891011121314151617181920212223242526272829public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"---\" + i); &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) throws InterruptedException &#123; /*System.out.println(\"睡觉前\"); Thread.sleep(3000); System.out.println(\"睡醒了\");*/ MyRunnable mr = new MyRunnable(); Thread t1 = new Thread(mr); Thread t2 = new Thread(mr); t1.start(); t2.start(); &#125;&#125; 1.9线程优先级【应用】 线程调度 两种调度方式 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些 Java使用的是抢占式调度模型 随机性 假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的 优先级相关方法 方法名 说明 final int getPriority() 返回此线程的优先级 final void setPriority(int newPriority) 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 代码演示 123456789101112131415161718192021222324252627282930313233public class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + \"---\" + i); &#125; return \"线程执行完毕了\"; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; //优先级: 1 - 10 默认值:5 MyCallable mc = new MyCallable(); FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(mc); Thread t1 = new Thread(ft); t1.setName(\"飞机\"); t1.setPriority(10); //System.out.println(t1.getPriority());//5 t1.start(); MyCallable mc2 = new MyCallable(); FutureTask&lt;String&gt; ft2 = new FutureTask&lt;&gt;(mc2); Thread t2 = new Thread(ft2); t2.setName(\"坦克\"); t2.setPriority(1); //System.out.println(t2.getPriority());//5 t2.start(); &#125;&#125; 1.10守护线程【应用】 相关方法 方法名 说明 void setDaemon(boolean on) 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 代码演示 1234567891011121314151617181920212223242526272829303132public class MyThread1 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + \"---\" + i); &#125; &#125;&#125;public class MyThread2 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(getName() + \"---\" + i); &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); MyThread2 t2 = new MyThread2(); t1.setName(\"女神\"); t2.setName(\"备胎\"); //把第二个线程设置为守护线程 //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了. t2.setDaemon(true); t1.start(); t2.start(); &#125;&#125; 2.线程同步2.1卖票【应用】 案例需求 某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票 实现步骤 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100; 在SellTicket类中重写run()方法实现卖票，代码步骤如下 判断票数大于0，就卖票，并告知是哪个窗口卖的 卖了票之后，总票数要减1 票卖没了，线程停止 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下 创建SellTicket类的对象 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 启动线程 代码实现 12345678910111213141516171819202122232425262728293031323334353637public class SellTicket implements Runnable &#123; private int tickets = 100; //在SellTicket类中重写run()方法实现卖票，代码步骤如下 @Override public void run() &#123; while (true) &#123; if(ticket &lt;= 0)&#123; //卖完了 break; &#125;else&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ticket--; System.out.println(Thread.currentThread().getName() + \"在卖票,还剩下\" + ticket + \"张票\"); &#125; &#125; &#125;&#125;public class SellTicketDemo &#123; public static void main(String[] args) &#123; //创建SellTicket类的对象 SellTicket st = new SellTicket(); //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 Thread t1 = new Thread(st,\"窗口1\"); Thread t2 = new Thread(st,\"窗口2\"); Thread t3 = new Thread(st,\"窗口3\"); //启动线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 2.2卖票案例的问题【理解】 卖票出现了问题 相同的票出现了多次 出现了负数的票 问题产生原因 线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题 2.3同步代码块解决数据安全问题【应用】 安全问题出现的条件 是多线程环境 有共享数据 有多条语句操作共享数据 如何解决多线程安全问题呢? 基本思想：让程序没有安全问题的环境 怎么实现呢? 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可 Java提供了同步代码块的方式来解决 同步代码块格式： 123synchronized(任意对象) &#123; 多条语句操作共享数据的代码 &#125; synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁 同步的好处和弊端 好处：解决了多线程的数据安全问题 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率 代码演示 123456789101112131415161718192021222324252627282930313233343536373839public class SellTicket implements Runnable &#123; private int tickets = 100; private Object obj = new Object(); @Override public void run() &#123; while (true) &#123; synchronized (obj) &#123; // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁 //t1进来后，就会把这段代码给锁起来 if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); //t1休息100毫秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //窗口1正在出售第100张票 System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\"); tickets--; //tickets = 99; &#125; &#125; //t1出来了，这段代码的锁就被释放了 &#125; &#125;&#125;public class SellTicketDemo &#123; public static void main(String[] args) &#123; SellTicket st = new SellTicket(); Thread t1 = new Thread(st, \"窗口1\"); Thread t2 = new Thread(st, \"窗口2\"); Thread t3 = new Thread(st, \"窗口3\"); t1.start(); t2.start(); t3.start(); &#125;&#125; 2.4同步方法解决数据安全问题【应用】 同步方法的格式 同步方法：就是把synchronized关键字加到方法上 123修饰符 synchronized 返回值类型 方法名(方法参数) &#123; 方法体；&#125; 同步方法的锁对象是什么呢? ​ this 静态同步方法 同步静态方法：就是把synchronized关键字加到静态方法上 123修饰符 static synchronized 返回值类型 方法名(方法参数) &#123; 方法体；&#125; 同步静态方法的锁对象是什么呢? ​ 类名.class 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyRunnable implements Runnable &#123; private static int ticketCount = 100; @Override public void run() &#123; while(true)&#123; if(\"窗口一\".equals(Thread.currentThread().getName()))&#123; //同步方法 boolean result = synchronizedMthod(); if(result)&#123; break; &#125; &#125; if(\"窗口二\".equals(Thread.currentThread().getName()))&#123; //同步代码块 synchronized (MyRunnable.class)&#123; if(ticketCount == 0)&#123; break; &#125;else&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ticketCount--; System.out.println(Thread.currentThread().getName() + \"在卖票,还剩下\" + ticketCount + \"张票\"); &#125; &#125; &#125; &#125; &#125; private static synchronized boolean synchronizedMthod() &#123; if(ticketCount == 0)&#123; return true; &#125;else&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ticketCount--; System.out.println(Thread.currentThread().getName() + \"在卖票,还剩下\" + ticketCount + \"张票\"); return false; &#125; &#125;&#125; public class Demo { public static void main(String[] args) { MyRunnable mr = new MyRunnable(); Thread t1 = new Thread(mr); Thread t2 = new Thread(mr); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t1.start(); t2.start(); } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869### 2.5Lock锁【应用】虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象LockLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化- ReentrantLock构造方法 | 方法名 | 说明 | | --------------- | -------------------- | | ReentrantLock() | 创建一个ReentrantLock的实例 |- 加锁解锁方法 | 方法名 | 说明 | | ------------- | ---- | | void lock() | 获得锁 | | void unlock() | 释放锁 |- 代码演示 &#96;&#96;&#96;java public class Ticket implements Runnable &#123; &#x2F;&#x2F;票的数量 private int ticket &#x3D; 100; private Object obj &#x3D; new Object(); private ReentrantLock lock &#x3D; new ReentrantLock(); @Override public void run() &#123; while (true) &#123; &#x2F;&#x2F;synchronized (obj)&#123;&#x2F;&#x2F;多个线程必须使用同一把锁. try &#123; lock.lock(); if (ticket &lt;&#x3D; 0) &#123; &#x2F;&#x2F;卖完了 break; &#125; else &#123; Thread.sleep(100); ticket--; System.out.println(Thread.currentThread().getName() + &quot;在卖票,还剩下&quot; + ticket + &quot;张票&quot;); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#x2F;&#x2F; &#125; &#125; &#125; &#125; public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket &#x3D; new Ticket(); Thread t1 &#x3D; new Thread(ticket); Thread t2 &#x3D; new Thread(ticket); Thread t3 &#x3D; new Thread(ticket); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125; &#125; 2.6死锁【理解】 概述 线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行 什么情况下会产生死锁 资源有限 同步嵌套 代码演示 12345678910111213141516171819202122232425262728public class Demo &#123; public static void main(String[] args) &#123; Object objA = new Object(); Object objB = new Object(); new Thread(()-&gt;&#123; while(true)&#123; synchronized (objA)&#123; //线程一 synchronized (objB)&#123; System.out.println(\"小康同学正在走路\"); &#125; &#125; &#125; &#125;).start(); new Thread(()-&gt;&#123; while(true)&#123; synchronized (objB)&#123; //线程二 synchronized (objA)&#123; System.out.println(\"小薇同学正在走路\"); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 3.生产者消费者3.1生产者和消费者模式概述【应用】 概述 生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。 所谓生产者消费者问题，实际上主要是包含了两类线程： ​ 一类是生产者线程用于生产数据 ​ 一类是消费者线程用于消费数据 为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库 生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为 消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为 Object类的等待和唤醒方法 方法名 说明 void wait() 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 void notify() 唤醒正在等待对象监视器的单个线程 void notifyAll() 唤醒正在等待对象监视器的所有线程 3.2生产者和消费者案例【应用】 案例需求 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务 1.判断是否有包子,决定当前线程是否执行 2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子 3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务 1.判断是否有包子,决定当前线程是否执行 2.如果没有包子,就进入等待状态,如果有包子,就消费包子 3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子 测试类(Demo)：里面有main方法，main方法中的代码步骤如下 创建生产者线程和消费者线程对象 分别开启两个线程 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class Desk &#123; //定义一个标记 //true 就表示桌子上有汉堡包的,此时允许吃货执行 //false 就表示桌子上没有汉堡包的,此时允许厨师执行 public static boolean flag = false; //汉堡包的总数量 public static int count = 10; //锁对象 public static final Object lock = new Object();&#125;public class Cooker extends Thread &#123;// 生产者步骤：// 1，判断桌子上是否有汉堡包// 如果有就等待，如果没有才生产。// 2，把汉堡包放在桌子上。// 3，叫醒等待的消费者开吃。 @Override public void run() &#123; while(true)&#123; synchronized (Desk.lock)&#123; if(Desk.count == 0)&#123; break; &#125;else&#123; if(!Desk.flag)&#123; //生产 System.out.println(\"厨师正在生产汉堡包\"); Desk.flag = true; Desk.lock.notifyAll(); &#125;else&#123; try &#123; Desk.lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Foodie extends Thread &#123; @Override public void run() &#123;// 1，判断桌子上是否有汉堡包。// 2，如果没有就等待。// 3，如果有就开吃// 4，吃完之后，桌子上的汉堡包就没有了// 叫醒等待的生产者继续生产// 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while(true)&#123; synchronized (Desk.lock)&#123; if(Desk.count == 0)&#123; break; &#125;else&#123; if(Desk.flag)&#123; //有 System.out.println(\"吃货在吃汉堡包\"); Desk.flag = false; Desk.lock.notifyAll(); Desk.count--; &#125;else&#123; //没有就等待 //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法. try &#123; Desk.lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; /*消费者步骤： 1，判断桌子上是否有汉堡包。 2，如果没有就等待。 3，如果有就开吃 4，吃完之后，桌子上的汉堡包就没有了 叫醒等待的生产者继续生产 汉堡包的总数量减一*/ /*生产者步骤： 1，判断桌子上是否有汉堡包 如果有就等待，如果没有才生产。 2，把汉堡包放在桌子上。 3，叫醒等待的消费者开吃。*/ Foodie f = new Foodie(); Cooker c = new Cooker(); f.start(); c.start(); &#125;&#125; 3.3生产者和消费者案例优化【应用】 需求 将Desk类中的变量,采用面向对象的方式封装起来 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用 创建生产者和消费者线程对象,构造方法中传入Desk类对象 开启两个线程 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171public class Desk &#123; //定义一个标记 //true 就表示桌子上有汉堡包的,此时允许吃货执行 //false 就表示桌子上没有汉堡包的,此时允许厨师执行 //public static boolean flag = false; private boolean flag; //汉堡包的总数量 //public static int count = 10; //以后我们在使用这种必须有默认值的变量 // private int count = 10; private int count; //锁对象 //public static final Object lock = new Object(); private final Object lock = new Object(); public Desk() &#123; this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了 &#125; public Desk(boolean flag, int count) &#123; this.flag = flag; this.count = count; &#125; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; public Object getLock() &#123; return lock; &#125; @Override public String toString() &#123; return \"Desk&#123;\" + \"flag=\" + flag + \", count=\" + count + \", lock=\" + lock + '&#125;'; &#125;&#125;public class Cooker extends Thread &#123; private Desk desk; public Cooker(Desk desk) &#123; this.desk = desk; &#125;// 生产者步骤：// 1，判断桌子上是否有汉堡包// 如果有就等待，如果没有才生产。// 2，把汉堡包放在桌子上。// 3，叫醒等待的消费者开吃。 @Override public void run() &#123; while(true)&#123; synchronized (desk.getLock())&#123; if(desk.getCount() == 0)&#123; break; &#125;else&#123; //System.out.println(\"验证一下是否执行了\"); if(!desk.isFlag())&#123; //生产 System.out.println(\"厨师正在生产汉堡包\"); desk.setFlag(true); desk.getLock().notifyAll(); &#125;else&#123; try &#123; desk.getLock().wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Foodie extends Thread &#123; private Desk desk; public Foodie(Desk desk) &#123; this.desk = desk; &#125; @Override public void run() &#123;// 1，判断桌子上是否有汉堡包。// 2，如果没有就等待。// 3，如果有就开吃// 4，吃完之后，桌子上的汉堡包就没有了// 叫醒等待的生产者继续生产// 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while(true)&#123; synchronized (desk.getLock())&#123; if(desk.getCount() == 0)&#123; break; &#125;else&#123; //System.out.println(\"验证一下是否执行了\"); if(desk.isFlag())&#123; //有 System.out.println(\"吃货在吃汉堡包\"); desk.setFlag(false); desk.getLock().notifyAll(); desk.setCount(desk.getCount() - 1); &#125;else&#123; //没有就等待 //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法. try &#123; desk.getLock().wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; /*消费者步骤： 1，判断桌子上是否有汉堡包。 2，如果没有就等待。 3，如果有就开吃 4，吃完之后，桌子上的汉堡包就没有了 叫醒等待的生产者继续生产 汉堡包的总数量减一*/ /*生产者步骤： 1，判断桌子上是否有汉堡包 如果有就等待，如果没有才生产。 2，把汉堡包放在桌子上。 3，叫醒等待的消费者开吃。*/ Desk desk = new Desk(); Foodie f = new Foodie(desk); Cooker c = new Cooker(desk); f.start(); c.start(); &#125;&#125; 3.4阻塞队列基本使用【理解】 阻塞队列继承结构 常见BlockingQueue: ArrayBlockingQueue: 底层是数组,有界 LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值 BlockingQueue的核心方法: put(anObject): 将参数放入队列,如果放不进去会阻塞 take(): 取出第一个数据,取不到会阻塞 代码示例 123456789101112131415public class Demo02 &#123; public static void main(String[] args) throws Exception &#123; // 创建阻塞队列的对象,容量为 1 ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(1); // 存储元素 arrayBlockingQueue.put(\"汉堡包\"); // 取元素 System.out.println(arrayBlockingQueue.take()); System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞 System.out.println(\"程序结束了\"); &#125;&#125; 3.5阻塞队列实现等待唤醒机制【理解】 案例需求 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务 1.构造方法中接收一个阻塞队列对象 2.在run方法中循环向阻塞队列中添加包子 3.打印添加结果 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务 1.构造方法中接收一个阻塞队列对象 2.在run方法中循环获取阻塞队列中的包子 3.打印获取结果 测试类(Demo)：里面有main方法，main方法中的代码步骤如下 创建阻塞队列对象 创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象 分别开启两个线程 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Cooker extends Thread &#123; private ArrayBlockingQueue&lt;String&gt; bd; public Cooker(ArrayBlockingQueue&lt;String&gt; bd) &#123; this.bd = bd; &#125;// 生产者步骤：// 1，判断桌子上是否有汉堡包// 如果有就等待，如果没有才生产。// 2，把汉堡包放在桌子上。// 3，叫醒等待的消费者开吃。 @Override public void run() &#123; while (true) &#123; try &#123; bd.put(\"汉堡包\"); System.out.println(\"厨师放入一个汉堡包\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Foodie extends Thread &#123; private ArrayBlockingQueue&lt;String&gt; bd; public Foodie(ArrayBlockingQueue&lt;String&gt; bd) &#123; this.bd = bd; &#125; @Override public void run() &#123;// 1，判断桌子上是否有汉堡包。// 2，如果没有就等待。// 3，如果有就开吃// 4，吃完之后，桌子上的汉堡包就没有了// 叫醒等待的生产者继续生产// 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while (true) &#123; try &#123; String take = bd.take(); System.out.println(\"吃货将\" + take + \"拿出来吃了\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; ArrayBlockingQueue&lt;String&gt; bd = new ArrayBlockingQueue&lt;&gt;(1); Foodie f = new Foodie(bd); Cooker c = new Cooker(bd); f.start(); c.start(); &#125;&#125;","categories":[],"tags":[]},{"title":"22_IO流02","slug":"22-IO流02","date":"2020-11-11T06:31:17.000Z","updated":"2020-11-11T06:40:06.228Z","comments":true,"path":"2020/11/11/22-IO流02/","link":"","permalink":"http://xiaojujing.com/2020/11/11/22-IO%E6%B5%8102/","excerpt":"1.字符流1.1为什么会出现字符流【理解】 字符流的介绍","text":"1.字符流1.1为什么会出现字符流【理解】 字符流的介绍 由于字节流操作中文不是特别的方便，所以Java就提供字符流 字符流 = 字节流 + 编码表 中文的字节存储方式 用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？ 汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数 1.2编码表【理解】 什么是字符集 是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等 常见的字符集 ASCII字符集： lASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) 基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 GBXXX字符集： GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等 Unicode字符集： UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码 编码规则： 128个US-ASCII字符，只需一个字节编码 拉丁文等字符，需要二个字节编码 大部分常用字（含中文），使用三个字节编码 其他极少使用的Unicode辅助字符，使用四字节编码 1.3字符串中的编码解码问题【应用】 相关方法 方法名 说明 byte[] getBytes() 使用平台的默认字符集将该 String编码为一系列字节 byte[] getBytes(String charsetName) 使用指定的字符集将该 String编码为一系列字节 String(byte[] bytes) 使用平台的默认字符集解码指定的字节数组来创建字符串 String(byte[] bytes, String charsetName) 通过指定的字符集解码指定的字节数组来创建字符串 代码演示 12345678910111213141516public class StringDemo &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; //定义一个字符串 String s = \"中国\"; //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67] //byte[] bys = s.getBytes(\"UTF-8\"); //[-28, -72, -83, -27, -101, -67] byte[] bys = s.getBytes(\"GBK\"); //[-42, -48, -71, -6] System.out.println(Arrays.toString(bys)); //String ss = new String(bys); //String ss = new String(bys,\"UTF-8\"); String ss = new String(bys,\"GBK\"); System.out.println(ss); &#125;&#125; 1.4字符流写数据【应用】 介绍 Writer: 用于写入字符流的抽象父类 FileWriter: 用于写入字符流的常用子类 构造方法 方法名 说明 FileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象 FileWriter(File file, boolean append) 根据给定的 File 对象构造一个 FileWriter 对象 FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象 FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象 成员方法 方法名 说明 void write(int c) 写一个字符 void write(char[] cbuf) 写入一个字符数组 void write(char[] cbuf, int off, int len) 写入字符数组的一部分 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分 刷新和关闭的方法 方法名 说明 flush() 刷新流，之后还可以继续写数据 close() 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 代码演示 12345678910111213141516171819202122232425262728public class OutputStreamWriterDemo &#123; public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWriter(\"myCharStream\\\\a.txt\"); //void write(int c)：写一个字符// fw.write(97);// fw.write(98);// fw.write(99); //void writ(char[] cbuf)：写入一个字符数组 char[] chs = &#123;'a', 'b', 'c', 'd', 'e'&#125;;// fw.write(chs); //void write(char[] cbuf, int off, int len)：写入字符数组的一部分// fw.write(chs, 0, chs.length);// fw.write(chs, 1, 3); //void write(String str)：写一个字符串// fw.write(\"abcde\"); //void write(String str, int off, int len)：写一个字符串的一部分// fw.write(\"abcde\", 0, \"abcde\".length()); fw.write(\"abcde\", 1, 3); //释放资源 fw.close(); &#125;&#125; 1.5字符流读数据【应用】 介绍 Reader: 用于读取字符流的抽象父类 FileReader: 用于读取字符流的常用子类 构造方法 方法名 说明 FileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader 成员方法 方法名 说明 int read() 一次读一个字符数据 int read(char[] cbuf) 一次读一个字符数组数据 代码演示 12345678910111213141516171819202122public class InputStreamReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader(\"myCharStream\\\\b.txt\"); //int read()：一次读一个字符数据// int ch;// while ((ch=fr.read())!=-1) &#123;// System.out.print((char)ch);// &#125; //int read(char[] cbuf)：一次读一个字符数组数据 char[] chs = new char[1024]; int len; while ((len = fr.read(chs)) != -1) &#123; System.out.print(new String(chs, 0, len)); &#125; //释放资源 fr.close(); &#125;&#125; 1.6字符流用户注册案例【应用】 案例需求 将键盘录入的用户名和密码保存到本地实现永久化存储 实现步骤 获取用户输入的用户名和密码 将用户输入的用户名和密码写入到本地文件中 关流,释放资源 代码实现 1234567891011121314151617181920212223242526public class CharStreamDemo8 &#123; public static void main(String[] args) throws IOException &#123; //需求: 将键盘录入的用户名和密码保存到本地实现永久化存储 //要求：用户名独占一行，密码独占一行 //分析： //1，实现键盘录入，把用户名和密码录入进来 Scanner sc = new Scanner(System.in); System.out.println(\"请录入用户名\"); String username = sc.next(); System.out.println(\"请录入密码\"); String password = sc.next(); //2.分别把用户名和密码写到本地文件。 FileWriter fw = new FileWriter(\"charstream\\\\a.txt\"); //将用户名和密码写到文件中 fw.write(username); //表示写出一个回车换行符 windows \\r\\n MacOS \\r Linux \\n fw.write(\"\\r\\n\"); fw.write(password); //刷新流 fw.flush(); //3.关流,释放资源 fw.close(); &#125;&#125; 1.7字符缓冲流【应用】 字符缓冲流介绍 BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途 BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途 构造方法 方法名 说明 BufferedWriter(Writer out) 创建字符缓冲输出流对象 BufferedReader(Reader in) 创建字符缓冲输入流对象 代码演示 123456789101112131415161718192021222324252627public class BufferedStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //BufferedWriter(Writer out) BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); bw.write(\"hello\\r\\n\"); bw.write(\"world\\r\\n\"); bw.close(); //BufferedReader(Reader in) BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); //一次读取一个字符数据// int ch;// while ((ch=br.read())!=-1) &#123;// System.out.print((char)ch);// &#125; //一次读取一个字符数组数据 char[] chs = new char[1024]; int len; while ((len=br.read(chs))!=-1) &#123; System.out.print(new String(chs,0,len)); &#125; br.close(); &#125;&#125; 1.8字符缓冲流特有功能【应用】 方法介绍 BufferedWriter： 方法名 说明 void newLine() 写一行行分隔符，行分隔符字符串由系统属性定义 BufferedReader: 方法名 说明 String readLine() 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null 代码演示 12345678910111213141516171819202122232425262728public class BufferedStreamDemo02 &#123; public static void main(String[] args) throws IOException &#123; //创建字符缓冲输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); //写数据 for (int i = 0; i &lt; 10; i++) &#123; bw.write(\"hello\" + i); //bw.write(\"\\r\\n\"); bw.newLine(); bw.flush(); &#125; //释放资源 bw.close(); //创建字符缓冲输入流 BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); String line; while ((line=br.readLine())!=null) &#123; System.out.println(line); &#125; br.close(); &#125;&#125; 1.9字符缓冲流操作文件中数据排序案例【应用】 案例需求 使用字符缓冲流读取文件中的数据，排序后再次写到本地文件 实现步骤 将文件中的数据读取到程序中 对读取到的数据进行处理 将处理后的数据添加到集合中 对集合中的数据进行排序 将排序后的集合中的数据写入到文件中 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041public class CharStreamDemo14 &#123; public static void main(String[] args) throws IOException &#123; //需求：读取文件中的数据，排序后再次写到本地文件 //分析： //1.要把文件中的数据读取进来。 BufferedReader br = new BufferedReader(new FileReader(\"charstream\\\\sort.txt\")); //输出流一定不能写在这里，因为会清空文件中的内容 //BufferedWriter bw = new BufferedWriter(new FileWriter(\"charstream\\\\sort.txt\")); String line = br.readLine(); System.out.println(\"读取到的数据为\" + line); br.close(); //2.按照空格进行切割 String[] split = line.split(\" \");//9 1 2 5 3 10 4 6 7 8 //3.把字符串类型的数组变成int类型 int [] arr = new int[split.length]; //遍历split数组，可以进行类型转换。 for (int i = 0; i &lt; split.length; i++) &#123; String smallStr = split[i]; //类型转换 int number = Integer.parseInt(smallStr); //把转换后的结果存入到arr中 arr[i] = number; &#125; //4.排序 Arrays.sort(arr); System.out.println(Arrays.toString(arr)); //5.把排序之后结果写回到本地 1 2 3 4... BufferedWriter bw = new BufferedWriter(new FileWriter(\"charstream\\\\sort.txt\")); //写出 for (int i = 0; i &lt; arr.length; i++) &#123; bw.write(arr[i] + \" \"); bw.flush(); &#125; //释放资源 bw.close(); &#125;&#125; 1.10IO流小结【理解】 IO流小结 2.转换流2.1字符流中和编码解码问题相关的两个类【理解】 InputStreamReader：是从字节流到字符流的桥梁,父类是Reader ​ 它读取字节，并使用指定的编码将其解码为字符 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 OutputStreamWriter：是从字符流到字节流的桥梁,父类是Writer ​ 是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 2.2转换流读写数据【应用】 构造方法 方法名 说明 InputStreamReader(InputStream in) 使用默认字符编码创建InputStreamReader对象 InputStreamReader(InputStream in,String chatset) 使用指定的字符编码创建InputStreamReader对象 OutputStreamWriter(OutputStream out) 使用默认字符编码创建OutputStreamWriter对象 OutputStreamWriter(OutputStream out,String charset) 使用指定的字符编码创建OutputStreamWriter对象 代码演示 1234567891011121314151617public class ConversionStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\")); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); osw.write(\"中国\"); osw.close(); //InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\")); InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); //一次读取一个字符数据 int ch; while ((ch=isr.read())!=-1) &#123; System.out.print((char)ch); &#125; isr.close(); &#125;&#125; 3.对象操作流3.1对象序列化流【应用】 对象序列化介绍 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化 对象序列化流： ObjectOutputStream 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 构造方法 方法名 说明 ObjectOutputStream(OutputStream out) 创建一个写入指定的OutputStream的ObjectOutputStream 序列化对象的方法 方法名 说明 void writeObject(Object obj) 将指定的对象写入ObjectOutputStream 示例代码 学生类 123456789101112131415161718192021222324252627282930313233343536public class Student implements Serializable &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类 123456789101112131415public class ObjectOutputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); //创建对象 Student s = new Student(\"佟丽娅\",30); //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream oos.writeObject(s); //释放资源 oos.close(); &#125;&#125; 注意事项 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口 Serializable是一个标记接口，实现该接口，不需要重写任何方法 3.2对象反序列化流【应用】 对象反序列化流： ObjectInputStream ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象 构造方法 方法名 说明 ObjectInputStream(InputStream in) 创建从指定的InputStream读取的ObjectInputStream 反序列化对象的方法 方法名 说明 Object readObject() 从ObjectInputStream读取一个对象 示例代码 1234567891011121314public class ObjectInputStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); //Object readObject()：从ObjectInputStream读取一个对象 Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); &#125;&#125; 3.3serialVersionUID&amp;transient【应用】 serialVersionUID 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？ 会出问题，会抛出InvalidClassException异常 如果出问题了，如何解决呢？ 重新序列化 给对象所属的类加一个serialVersionUID private static final long serialVersionUID = 42L; transient 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？ 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程 示例代码 学生类 1234567891011121314151617181920212223242526272829303132333435363738public class Student implements Serializable &#123; private static final long serialVersionUID = 42L; private String name;// private int age; private transient int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;// @Override// public String toString() &#123;// return \"Student&#123;\" +// \"name='\" + name + '\\'' +// \", age=\" + age +// '&#125;';// &#125;&#125; 测试类 1234567891011121314151617181920212223public class ObjectStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123;// write(); read(); &#125; //反序列化 private static void read() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); &#125; //序列化 private static void write() throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); Student s = new Student(\"佟丽娅\", 30); oos.writeObject(s); oos.close(); &#125;&#125; 3.4对象操作流练习【应用】 案例需求 创建多个学生类对象写到文件中,再次读取到内存中 实现步骤 创建序列化流对象 创建多个学生对象 将学生对象添加到集合中 将集合对象序列化到文件中 创建反序列化流对象 将文件中的对象数据,读取到内存中 代码实现 学生类 12345678910111213141516171819202122232425262728293031public class Student implements Serializable&#123; private static final long serialVersionUID = 2L; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738public class Demo03 &#123; /** * read(): * 读取到文件末尾返回值是 -1 * readLine(): * 读取到文件的末尾返回值 null * readObject(): * 读取到文件的末尾 直接抛出异常 * 如果要序列化的对象有多个,不建议直接将多个对象序列化到文件中,因为反序列化时容易出异常 * 建议: 将要序列化的多个对象存储到集合中,然后将集合序列化到文件中 */ public static void main(String[] args) throws Exception &#123; /*// 序列化 //1.创建序列化流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myCode\\\\oos.txt\")); ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;(); //2.创建多个学生对象 Student s = new Student(\"佟丽娅\",30); Student s01 = new Student(\"佟丽娅\",30); //3.将学生对象添加到集合中 arrayList.add(s); arrayList.add(s01); //4.将集合对象序列化到文件中 oos.writeObject(arrayList); oos.close();*/ // 反序列化 //5.创建反序列化流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myCode\\\\oos.txt\")); //6.将文件中的对象数据,读取到内存中 Object obj = ois.readObject(); ArrayList&lt;Student&gt; arrayList = (ArrayList&lt;Student&gt;)obj; ois.close(); for (Student s : arrayList) &#123; System.out.println(s.getName() + \",\" + s.getAge()); &#125; &#125;&#125; 4.Properties集合4.1Properties作为Map集合的使用【应用】 Properties介绍 是一个Map体系的集合类 Properties可以保存到流中或从流中加载 属性列表中的每个键及其对应的值都是一个字符串 Properties基本使用 12345678910111213141516171819public class PropertiesDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象// Properties&lt;String,String&gt; prop = new Properties&lt;String,String&gt;(); //错误 Properties prop = new Properties(); //存储元素 prop.put(\"itheima001\", \"佟丽娅\"); prop.put(\"itheima002\", \"赵丽颖\"); prop.put(\"itheima003\", \"刘诗诗\"); //遍历集合 Set&lt;Object&gt; keySet = prop.keySet(); for (Object key : keySet) &#123; Object value = prop.get(key); System.out.println(key + \",\" + value); &#125; &#125;&#125; 4.2Properties作为Map集合的特有方法【应用】 特有方法 方法名 说明 Object setProperty(String key, String value) 设置集合的键和值，都是String类型，底层调用 Hashtable方法 put String getProperty(String key) 使用此属性列表中指定的键搜索属性 Set stringPropertyNames() 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 示例代码 12345678910111213141516171819202122232425public class PropertiesDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Properties prop = new Properties(); //Object setProperty(String key, String value)：设置集合的键和值，都是String类型 prop.setProperty(\"itheima001\", \"佟丽娅\"); prop.setProperty(\"itheima002\", \"赵丽颖\"); prop.setProperty(\"itheima003\", \"刘诗诗\"); //String getProperty(String key)：使用此属性列表中指定的键搜索属性// System.out.println(prop.getProperty(\"itheima001\"));// System.out.println(prop.getProperty(\"itheima0011\"));// System.out.println(prop); //Set&lt;String&gt; stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 Set&lt;String&gt; names = prop.stringPropertyNames(); for (String key : names) &#123;// System.out.println(key); String value = prop.getProperty(key); System.out.println(key + \",\" + value); &#125; &#125;&#125; 4.3Properties和IO流相结合的方法【应用】 和IO流结合的方法 方法名 说明 void load(Reader reader) 从输入字符流读取属性列表（键和元素对） void store(Writer writer, String comments) 将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 示例代码 12345678910111213141516171819202122232425262728293031323334public class PropertiesDemo03 &#123; public static void main(String[] args) throws IOException &#123; //把集合中的数据保存到文件// myStore(); //把文件中的数据加载到集合 myLoad(); &#125; private static void myLoad() throws IOException &#123; Properties prop = new Properties(); //void load(Reader reader)： FileReader fr = new FileReader(\"myOtherStream\\\\fw.txt\"); prop.load(fr); fr.close(); System.out.println(prop); &#125; private static void myStore() throws IOException &#123; Properties prop = new Properties(); prop.setProperty(\"itheima001\",\"佟丽娅\"); prop.setProperty(\"itheima002\",\"赵丽颖\"); prop.setProperty(\"itheima003\",\"刘诗诗\"); //void store(Writer writer, String comments)： FileWriter fw = new FileWriter(\"myOtherStream\\\\fw.txt\"); prop.store(fw,null); fw.close(); &#125;&#125; 4.4Properties集合练习【应用】 案例需求 在Properties文件中手动写上姓名和年龄,读取到集合中,将该数据封装成学生对象,写到本地文件 实现步骤 创建Properties集合,将本地文件中的数据加载到集合中 获取集合中的键值对数据,封装到学生对象中 创建序列化流对象,将学生对象序列化到本地文件中 代码实现 学生类 1234567891011121314151617181920212223242526272829303132333435363738public class Student implements Serializable &#123; private static final long serialVersionUID = 1L; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类 123456789101112131415161718public class Test &#123; public static void main(String[] args) throws IOException &#123; //1.创建Properties集合,将本地文件中的数据加载到集合中 Properties prop = new Properties(); FileReader fr = new FileReader(\"prop.properties\"); prop.load(fr); fr.close(); //2.获取集合中的键值对数据,封装到学生对象中 String name = prop.getProperty(\"name\"); int age = Integer.parseInt(prop.getProperty(\"age\")); Student s = new Student(name,age); //3.创建序列化流对象,将学生对象序列化到本地文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"a.txt\")); oos.writeObject(s); oos.close(); &#125;&#125;","categories":[],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://xiaojujing.com/tags/IO%E6%B5%81/"}]},{"title":"21_IO流01","slug":"21-IO流01","date":"2020-11-11T06:31:06.000Z","updated":"2020-11-11T06:39:22.531Z","comments":true,"path":"2020/11/11/21-IO流01/","link":"","permalink":"http://xiaojujing.com/2020/11/11/21-IO%E6%B5%8101/","excerpt":"1.File类1.1File类概述和构造方法【应用】 File类介绍 它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的","text":"1.File类1.1File类概述和构造方法【应用】 File类介绍 它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的 对于File而言,其封装的并不是一个真正存在的文件,仅仅是一个路径名而已.它可以是存在的,也可以是不存在的.将来是要通过具体的操作把这个路径的内容转换为具体存在的 File类的构造方法 方法名 说明 File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例 File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例 示例代码 12345678910111213141516public class FileDemo01 &#123; public static void main(String[] args) &#123; //File(String pathname): 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1); //File(String parent, String child): 从父路径名字符串和子路径名字符串创建新的 File实例 File f2 = new File(\"E:\\\\itcast\",\"java.txt\"); System.out.println(f2); //File(File parent, String child): 从父抽象路径名和子路径名字符串创建新的 File实例 File f3 = new File(\"E:\\\\itcast\"); File f4 = new File(f3,\"java.txt\"); System.out.println(f4); &#125;&#125; 1.2绝对路径和相对路径【理解】 绝对路径 是一个完整的路径,从盘符开始 相对路径 是一个简化的路径,相对当前项目下的路径 示例代码 12345678910public class FileDemo02 &#123; public static void main(String[] args) &#123; // 是一个完整的路径,从盘符开始 File file1 = new File(\"D:\\\\itheima\\\\a.txt\"); // 是一个简化的路径,从当前项目根目录开始 File file2 = new File(\"a.txt\"); File file3 = new File(\"模块名\\\\a.txt\"); &#125;&#125; 1.3File类创建功能【应用】 方法分类 方法名 说明 public boolean createNewFile() 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 public boolean mkdir() 创建由此抽象路径名命名的目录 public boolean mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录 示例代码 123456789101112131415161718192021222324public class FileDemo02 &#123; public static void main(String[] args) throws IOException &#123; //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1.createNewFile()); System.out.println(\"--------\"); //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE File f2 = new File(\"E:\\\\itcast\\\\JavaSE\"); System.out.println(f2.mkdir()); System.out.println(\"--------\"); //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML File f3 = new File(\"E:\\\\itcast\\\\JavaWEB\\\\HTML\");// System.out.println(f3.mkdir()); System.out.println(f3.mkdirs()); System.out.println(\"--------\"); //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt File f4 = new File(\"E:\\\\itcast\\\\javase.txt\");// System.out.println(f4.mkdir()); System.out.println(f4.createNewFile()); &#125;&#125; 1.4File类删除功能【应用】 方法分类 方法名 说明 public boolean delete() 删除由此抽象路径名表示的文件或目录 示例代码 123456789101112131415161718192021222324252627282930public class FileDemo03 &#123; public static void main(String[] args) throws IOException &#123;// File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); //需求1：在当前模块目录下创建java.txt文件 File f1 = new File(\"myFile\\\\java.txt\");// System.out.println(f1.createNewFile()); //需求2：删除当前模块目录下的java.txt文件 System.out.println(f1.delete()); System.out.println(\"--------\"); //需求3：在当前模块目录下创建itcast目录 File f2 = new File(\"myFile\\\\itcast\");// System.out.println(f2.mkdir()); //需求4：删除当前模块目录下的itcast目录 System.out.println(f2.delete()); System.out.println(\"--------\"); //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt File f3 = new File(\"myFile\\\\itcast\");// System.out.println(f3.mkdir()); File f4 = new File(\"myFile\\\\itcast\\\\java.txt\");// System.out.println(f4.createNewFile()); //需求6：删除当前模块下的目录itcast System.out.println(f4.delete()); System.out.println(f3.delete()); &#125;&#125; 1.5File类判断和获取功能【应用】 判断功能 方法名 说明 public boolean isDirectory() 测试此抽象路径名表示的File是否为目录 public boolean isFile() 测试此抽象路径名表示的File是否为文件 public boolean exists() 测试此抽象路径名表示的File是否存在 获取功能 方法名 说明 public String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串 public String getPath() 将此抽象路径名转换为路径名字符串 public String getName() 返回由此抽象路径名表示的文件或目录的名称 public File[] listFiles() 返回此抽象路径名表示的目录中的文件和目录的File对象数组 示例代码 1234567891011121314151617181920212223242526272829303132public class FileDemo04 &#123; public static void main(String[] args) &#123; //创建一个File对象 File f = new File(\"myFile\\\\java.txt\");// public boolean isDirectory()：测试此抽象路径名表示的File是否为目录// public boolean isFile()：测试此抽象路径名表示的File是否为文件// public boolean exists()：测试此抽象路径名表示的File是否存在 System.out.println(f.isDirectory()); System.out.println(f.isFile()); System.out.println(f.exists());// public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串// public String getPath()：将此抽象路径名转换为路径名字符串// public String getName()：返回由此抽象路径名表示的文件或目录的名称 System.out.println(f.getAbsolutePath()); System.out.println(f.getPath()); System.out.println(f.getName()); System.out.println(\"--------\");// public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组 File f2 = new File(\"E:\\\\itcast\"); File[] fileArray = f2.listFiles(); for(File file : fileArray) &#123;// System.out.println(file);// System.out.println(file.getName()); if(file.isFile()) &#123; System.out.println(file.getName()); &#125; &#125; &#125;&#125; 1.6File类练习一【应用】 案例需求 在当前模块下的aaa文件夹中创建一个a.txt文件 实现步骤 创建File对象,指向aaa文件夹 判断aaa文件夹是否存在,如果不存在则创建 创建File对象,指向aaa文件夹下的a.txt文件 创建这个文件 代码实现 1234567891011121314151617181920public class Test1 &#123; public static void main(String[] args) throws IOException &#123; //练习一：在当前模块下的aaa文件夹中创建一个a.txt文件 /* File file = new File(\"filemodule\\\\aaa\\\\a.txt\"); file.createNewFile();*/ //注意点:文件所在的文件夹必须要存在. //1.创建File对象,指向aaa文件夹 File file = new File(\"filemodule\\\\aaa\"); //2.判断aaa文件夹是否存在,如果不存在则创建 if(!file.exists())&#123; //如果文件夹不存在,就创建出来 file.mkdirs(); &#125; //3.创建File对象,指向aaa文件夹下的a.txt文件 File newFile = new File(file,\"a.txt\"); //4.创建这个文件 newFile.createNewFile(); &#125;&#125; 1.7File类练习二【应用】 案例需求 删除一个多级文件夹 实现步骤 定义一个方法,接收一个File对象 遍历这个File对象,获取它下边的每个文件和文件夹对象 判断当前遍历到的File对象是文件还是文件夹 如果是文件,直接删除 如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 代码实现 1234567891011121314151617181920212223242526272829303132333435public class Test2 &#123; public static void main(String[] args) &#123; //练习二：删除一个多级文件夹 //delete方法 //只能删除文件和空文件夹. //如果现在要删除一个有内容的文件夹? //先删掉这个文件夹里面所有的内容. //最后再删除这个文件夹 File src = new File(\"C:\\\\Users\\\\apple\\\\Desktop\\\\src\"); deleteDir(src); &#125; //1.定义一个方法,接收一个File对象 private static void deleteDir(File src) &#123; //先删掉这个文件夹里面所有的内容. //递归 方法在方法体中自己调用自己. //注意: 可以解决所有文件夹和递归相结合的题目 //2.遍历这个File对象,获取它下边的每个文件和文件夹对象 File[] files = src.listFiles(); //3.判断当前遍历到的File对象是文件还是文件夹 for (File file : files) &#123; //4.如果是文件,直接删除 if(file.isFile())&#123; file.delete(); &#125;else&#123; //5.如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 deleteDir(file);//参数一定要是src文件夹里面的文件夹File对象 &#125; &#125; //6.参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 src.delete(); &#125;&#125; 1.8File类练习三【应用】 案例需求 统计一个文件夹中每种文件的个数并打印 打印格式如下： txt:3个 doc:4个 jpg:6个 … 实现步骤 定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 遍历File对象,获取它下边的每一个文件和文件夹对象 判断当前File对象是文件还是文件夹 如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 没出现过,将这种类型文件的后缀名存入集合中,次数存1 出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Test3 &#123; public static void main(String[] args) &#123; //统计一个文件夹中,每种文件出现的次数. //统计 --- 定义一个变量用来统计. ---- 弊端:同时只能统计一种文件 //利用map集合进行数据统计,键 --- 文件后缀名 值 ---- 次数 File file = new File(\"filemodule\"); HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;(); getCount(hm, file); System.out.println(hm); &#125; //1.定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 private static void getCount(HashMap&lt;String, Integer&gt; hm, File file) &#123; //2.遍历File对象,获取它下边的每一个文件和文件夹对象 File[] files = file.listFiles(); for (File f : files) &#123; //3.判断当前File对象是文件还是文件夹 if(f.isFile())&#123; //如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 String fileName = f.getName(); String[] fileNameArr = fileName.split(\"\\\\.\"); if(fileNameArr.length == 2)&#123; String fileEndName = fileNameArr[1]; if(hm.containsKey(fileEndName))&#123; //出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 Integer count = hm.get(fileEndName); //这种文件又出现了一次. count++; //把已经出现的次数给覆盖掉. hm.put(fileEndName,count); &#125;else&#123; // 没出现过,将这种类型文件的后缀名存入集合中,次数存1 hm.put(fileEndName,1); &#125; &#125; &#125;else&#123; //如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象代码实现 getCount(hm,f); &#125; &#125; &#125; &#125; 2.字节流2.1 IO流概述和分类【理解】 IO流介绍 IO：输入/输出(Input/Output) 流：是一种抽象概念,是对数据传输的总称.也就是说数据在设备间的传输称为流,流的本质是数据传输 IO流就是用来处理设备间数据传输问题的.常见的应用: 文件复制; 文件上传; 文件下载 IO流的分类 按照数据的流向 输入流：读数据 输出流：写数据 按照数据类型来分 字节流 字节输入流 字节输出流 字符流 字符输入流 字符输出流 IO流的使用场景 如果操作的是纯文本文件,优先使用字符流 如果操作的是图片、视频、音频等二进制文件,优先使用字节流 如果不确定文件类型,优先使用字节流.字节流是万能的流 2.2字节流写数据【应用】 字节流抽象基类 InputStream：这个抽象类是表示字节输入流的所有类的超类 OutputStream：这个抽象类是表示字节输出流的所有类的超类 子类名特点：子类名称都是以其父类名作为子类名的后缀 字节输出流 FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 使用字节输出流写数据的步骤 创建字节输出流对象(调用系统功能创建了文件,创建字节输出流对象,让字节输出流对象指向文件) 调用字节输出流对象的写数据方法 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源) 示例代码 123456789101112131415161718192021public class FileOutputStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输出流对象 /* 注意点: 1.如果文件不存在,会帮我们创建 2.如果文件存在,会把文件清空 */ //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //void write(int b)：将指定的字节写入此文件输出流 fos.write(97);// fos.write(57);// fos.write(55); //最后都要释放资源 //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。 fos.close(); &#125;&#125; 2.3字节流写数据的三种方式【应用】 写数据的方法分类 方法名 说明 void write(int b) 将指定的字节写入此文件输出流 一次写一个字节数据 void write(byte[] b) 将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据 void write(byte[] b, int off, int len) 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一次写一个字节数组的部分数据 示例代码 12345678910111213141516171819202122232425262728public class FileOutputStreamDemo02 &#123; public static void main(String[] args) throws IOException &#123; //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件// FileOutputStream fos = new FileOutputStream(new File(\"myByteStream\\\\fos.txt\")); //void write(int b)：将指定的字节写入此文件输出流// fos.write(97);// fos.write(98);// fos.write(99);// fos.write(100);// fos.write(101);// void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流// byte[] bys = &#123;97, 98, 99, 100, 101&#125;; //byte[] getBytes()：返回字符串对应的字节数组 byte[] bys = \"abcde\".getBytes();// fos.write(bys); //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流// fos.write(bys,0,bys.length); fos.write(bys,1,3); //释放资源 fos.close(); &#125;&#125; 2.4字节流写数据的两个小问题【应用】 字节流写数据如何实现换行 windows:\\r\\n linux:\\n mac:\\r 字节流写数据如何实现追加写入 public FileOutputStream(String name,boolean append) 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头 示例代码 12345678910111213141516public class FileOutputStreamDemo03 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输出流对象// FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\",true); //写数据 for (int i = 0; i &lt; 10; i++) &#123; fos.write(\"hello\".getBytes()); fos.write(\"\\r\\n\".getBytes()); &#125; //释放资源 fos.close(); &#125;&#125; 2.5字节流写数据加异常处理【应用】 异常处理格式 try-catch-finally 1234567try&#123; 可能出现异常的代码;&#125;catch(异常类名 变量名)&#123; 异常的处理代码;&#125;finally&#123; 执行所有清除操作;&#125; finally特点 被finally控制的语句一定会执行，除非JVM退出 示例代码 1234567891011121314151617181920public class FileOutputStreamDemo04 &#123; public static void main(String[] args) &#123; //加入finally来实现释放资源 FileOutputStream fos = null; try &#123; fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); fos.write(\"hello\".getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 2.6字节流读数据(一次读一个字节数据)【应用】 字节输入流 FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream,该文件由文件系统中的路径名name命名 字节输入流读取数据的步骤 创建字节输入流对象 调用字节输入流对象的读数据方法 释放资源 示例代码 1234567891011121314151617181920public class FileInputStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输入流对象 //FileInputStream(String name) FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); int by; /* fis.read()：读数据 by=fis.read()：把读取到的数据赋值给by by != -1：判断读取到的数据是否是-1 */ while ((by=fis.read())!=-1) &#123; System.out.print((char)by); &#125; //释放资源 fis.close(); &#125;&#125; 2.7字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt” (文件可以是任意文件) 实现步骤 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地) 数据源： ​ E:\\itcast\\窗里窗外.txt — 读数据 — InputStream — FileInputStream 目的地： ​ myByteStream\\窗里窗外.txt — 写数据 — OutputStream — FileOutputStream 代码实现 123456789101112131415161718public class CopyTxtDemo &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\窗里窗外.txt\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\窗里窗外.txt\"); //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节) int by; while ((by=fis.read())!=-1) &#123; fos.write(by); &#125; //释放资源 fos.close(); fis.close(); &#125;&#125; 2.8字节流读数据(一次读一个字节数组数据)【应用】 一次读一个字节数组的方法 public int read(byte[] b)：从输入流读取最多b.length个字节的数据 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数 示例代码 12345678910111213141516public class FileInputStreamDemo02 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输入流对象 FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); byte[] bys = new byte[1024]; //1024及其整数倍 int len; //循环读取 while ((len=fis.read(bys))!=-1) &#123; System.out.print(new String(bys,0,len)); &#125; //释放资源 fis.close(); &#125;&#125; 2.9字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\mn.jpg”复制到模块目录下的“mn.jpg” (文件可以是任意文件去) 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) 释放资源 代码实现 12345678910111213141516171819public class CopyJpgDemo &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\mn.jpg\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\mn.jpg\"); //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) byte[] bys = new byte[1024]; int len; while ((len=fis.read(bys))!=-1) &#123; fos.write(bys,0,len); &#125; //释放资源 fos.close(); fis.close(); &#125;&#125; 3.字节缓冲流3.1字节缓冲流构造方法【应用】 字节缓冲流介绍 lBufferOutputStream：该类实现缓冲输出流.通过设置这样的输出流,应用程序可以向底层输出流写入字节,而不必为写入的每个字节导致底层系统的调用 lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组.当从流中读取或跳过字节时,内部缓冲区将根据需要从所包含的输入流中重新填充,一次很多字节 构造方法： 方法名 说明 BufferedOutputStream(OutputStream out) 创建字节缓冲输出流对象 BufferedInputStream(InputStream in) 创建字节缓冲输入流对象 示例代码 1234567891011121314151617181920212223242526272829303132public class BufferStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //字节缓冲输出流：BufferedOutputStream(OutputStream out) BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\bos.txt\")); //写数据 bos.write(\"hello\\r\\n\".getBytes()); bos.write(\"world\\r\\n\".getBytes()); //释放资源 bos.close(); //字节缓冲输入流：BufferedInputStream(InputStream in) BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"myByteStream\\\\bos.txt\")); //一次读取一个字节数据// int by;// while ((by=bis.read())!=-1) &#123;// System.out.print((char)by);// &#125; //一次读取一个字节数组数据 byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) &#123; System.out.print(new String(bys,0,len)); &#125; //释放资源 bis.close(); &#125;&#125; 3.2字节缓冲流复制视频【应用】 案例需求 把“E:\\itcast\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi” 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制视频 释放资源 代码实现 123456789101112131415161718192021222324252627282930313233343536373839public class CopyAviDemo &#123; public static void main(String[] args) throws IOException &#123; //复制视频// method1(); method2(); &#125; //字节缓冲流一次读写一个字节数组 public static void method2() throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) &#123; bos.write(bys,0,len); &#125; bos.close(); bis.close(); &#125; //字节缓冲流一次读写一个字节 public static void method1() throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); int by; while ((by=bis.read())!=-1) &#123; bos.write(by); &#125; bos.close(); bis.close(); &#125;&#125;","categories":[],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://xiaojujing.com/tags/IO%E6%B5%81/"}]},{"title":"20_集合04","slug":"20-集合04","date":"2020-11-10T09:01:27.000Z","updated":"2020-11-10T09:02:44.817Z","comments":true,"path":"2020/11/10/20-集合04/","link":"","permalink":"http://xiaojujing.com/2020/11/10/20-%E9%9B%86%E5%90%8804/","excerpt":"1.可变参数1.1可变参数【应用】 可变参数介绍 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了","text":"1.可变参数1.1可变参数【应用】 可变参数介绍 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了 方法的参数类型已经确定,个数不确定,我们可以使用可变参数 可变参数定义格式 1修饰符 返回值类型 方法名(数据类型… 变量名) &#123; &#125; 可变参数的注意事项 这里的变量其实是一个数组 如果一个方法有多个参数，包含可变参数，可变参数要放在最后 可变参数的基本使用 123456789101112131415161718192021222324public class ArgsDemo01 &#123; public static void main(String[] args) &#123; System.out.println(sum(10, 20)); System.out.println(sum(10, 20, 30)); System.out.println(sum(10, 20, 30, 40)); System.out.println(sum(10,20,30,40,50)); System.out.println(sum(10,20,30,40,50,60)); System.out.println(sum(10,20,30,40,50,60,70)); System.out.println(sum(10,20,30,40,50,60,70,80,90,100)); &#125;// public static int sum(int b,int... a) &#123;// return 0;// &#125; public static int sum(int... a) &#123; int sum = 0; for(int i : a) &#123; sum += i; &#125; return sum; &#125;&#125; 1.2创建不可变集合【理解】 方法介绍 在List、Set、Map接口中,都存在of方法,可以创建一个不可变的集合 这个集合不能添加,不能删除,不能修改 但是可以结合集合的带参构造,实现集合的批量添加 在Map接口中,还有一个ofEntries方法可以提高代码的阅读性 首先会把键值对封装成一个Entry对象,再把这个Entry对象添加到集合当中 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyVariableParameter4 &#123; public static void main(String[] args) &#123; // static &lt;E&gt; List&lt;E&gt; of(E…elements) 创建一个具有指定元素的List集合对象 //static &lt;E&gt; Set&lt;E&gt; of(E…elements) 创建一个具有指定元素的Set集合对象 //static &lt;K , V&gt; Map&lt;K，V&gt; of(E…elements) 创建一个具有指定元素的Map集合对象 //method1(); //method2(); //method3(); //method4(); &#125; private static void method4() &#123; Map&lt;String, String&gt; map = Map.ofEntries( Map.entry(\"zhangsan\", \"江苏\"), Map.entry(\"lisi\", \"北京\")); System.out.println(map); &#125; private static void method3() &#123; Map&lt;String, String&gt; map = Map.of(\"zhangsan\", \"江苏\", \"lisi\", \"北京\", \"wangwu\", \"天津\"); System.out.println(map); &#125; private static void method2() &#123; //传递的参数当中，不能存在重复的元素。 Set&lt;String&gt; set = Set.of(\"a\", \"b\", \"c\", \"d\",\"a\"); System.out.println(set); &#125; private static void method1() &#123; List&lt;String&gt; list = List.of(\"a\", \"b\", \"c\", \"d\"); System.out.println(list); //list.add(\"Q\"); //list.remove(\"a\"); //list.set(0,\"A\"); //System.out.println(list);// ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();// list2.add(\"aaa\");// list2.add(\"aaa\");// list2.add(\"aaa\");// list2.add(\"aaa\"); //集合的批量添加。 //首先是通过调用List.of方法来创建一个不可变的集合，of方法的形参就是一个可变参数。 //再创建一个ArrayList集合，并把这个不可变的集合中所有的数据，都添加到ArrayList中。 ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(List.of(\"a\", \"b\", \"c\", \"d\")); System.out.println(list3); &#125;&#125; 2.Stream流2.1体验Stream流【理解】 案例需求 按照下面的要求完成集合的创建和遍历 创建一个集合，存储多个字符串元素 把集合中所有以”张”开头的元素存储到一个新的集合 把”张”开头的集合中的长度为3的元素存储到一个新的集合 遍历上一步得到的集合 原始方式示例代码 12345678910111213141516171819202122232425public class MyStream1 &#123; public static void main(String[] args) &#123; //集合的批量添加 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\")); //list.add() //遍历list1把以张开头的元素添加到list2中。 ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); for (String s : list1) &#123; if(s.startsWith(\"张\"))&#123; list2.add(s); &#125; &#125; //遍历list2集合，把其中长度为3的元素，再添加到list3中。 ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(); for (String s : list2) &#123; if(s.length() == 3)&#123; list3.add(s); &#125; &#125; for (String s : list3) &#123; System.out.println(s); &#125; &#125;&#125; 使用Stream流示例代码 1234567891011public class StreamDemo &#123; public static void main(String[] args) &#123; //集合的批量添加 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\")); //Stream流 list1.stream().filter(s-&gt;s.startsWith(\"张\")) .filter(s-&gt;s.length() == 3) .forEach(s-&gt; System.out.println(s)); &#125;&#125; Stream流的好处 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印 Stream流把真正的函数式编程风格引入到Java中 代码简洁 2.2Stream流的常见生成方式【应用】 Stream流的思想 Stream流的三类方法 获取Stream流 创建一条流水线,并把数据放到流水线上准备进行操作 中间方法 流水线上的操作 一次操作完毕之后,还可以继续进行其他操作 终结方法 一个Stream流只能有一个终结方法 是流水线上的最后一个操作 生成Stream流的方式 Collection体系集合 使用默认方法stream()生成流， default Stream stream() Map体系集合 把Map转成Set集合，间接的生成流 数组 通过Arrays中的静态方法stream生成流 同种数据类型的多个数据 通过Stream接口的静态方法of(T… values)生成流 代码演示 123456789101112131415161718192021222324public class StreamDemo &#123; public static void main(String[] args) &#123; //Collection体系的集合可以使用默认方法stream()生成流 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Stream&lt;String&gt; listStream = list.stream(); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); Stream&lt;String&gt; setStream = set.stream(); //Map体系的集合间接的生成流 Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;Integer&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream(); //数组可以通过Arrays中的静态方法stream生成流 String[] strArray = &#123;\"hello\",\"world\",\"java\"&#125;; Stream&lt;String&gt; strArrayStream = Arrays.stream(strArray); //同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流 Stream&lt;String&gt; strArrayStream2 = Stream.of(\"hello\", \"world\", \"java\"); Stream&lt;Integer&gt; intStream = Stream.of(10, 20, 30); &#125;&#125; 2.3Stream流中间操作方法【应用】 概念 中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作 常见方法 方法名 说明 Stream filter(Predicate predicate) 用于对流中的数据进行过滤 Stream limit(long maxSize) 返回此流中的元素组成的流，截取前指定参数个数的数据 Stream skip(long n) 跳过指定参数个数的数据，返回由该流的剩余元素组成的流 static Stream concat(Stream a, Stream b) 合并a和b两个流为一个流 Stream distinct() 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 filter代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyStream3 &#123; public static void main(String[] args) &#123;// Stream&lt;T&gt; filter(Predicate predicate)：过滤// Predicate接口中的方法 boolean test(T t)：对给定的参数进行判断，返回一个布尔值 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张三丰\"); list.add(\"张无忌\"); list.add(\"张翠山\"); list.add(\"王二麻子\"); list.add(\"张良\"); list.add(\"谢广坤\"); //filter方法获取流中的 每一个数据. //而test方法中的s,就依次表示流中的每一个数据. //我们只要在test方法中对s进行判断就可以了. //如果判断的结果为true,则当前的数据留下 //如果判断的结果为false,则当前数据就不要.// list.stream().filter(// new Predicate&lt;String&gt;() &#123;// @Override// public boolean test(String s) &#123;// boolean result = s.startsWith(\"张\");// return result;// &#125;// &#125;// ).forEach(s-&gt; System.out.println(s)); //因为Predicate接口中只有一个抽象方法test //所以我们可以使用lambda表达式来简化// list.stream().filter(// (String s)-&gt;&#123;// boolean result = s.startsWith(\"张\");// return result;// &#125;// ).forEach(s-&gt; System.out.println(s)); list.stream().filter(s -&gt;s.startsWith(\"张\")).forEach(s-&gt; System.out.println(s)); &#125;&#125; limit&amp;skip代码演示 123456789101112131415161718192021222324public class StreamDemo02 &#123; public static void main(String[] args) &#123; //创建一个集合，存储多个字符串元素 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：取前3个数据在控制台输出 list.stream().limit(3).forEach(s-&gt; System.out.println(s)); System.out.println(\"--------\"); //需求2：跳过3个元素，把剩下的元素在控制台输出 list.stream().skip(3).forEach(s-&gt; System.out.println(s)); System.out.println(\"--------\"); //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出 list.stream().skip(2).limit(2).forEach(s-&gt; System.out.println(s)); &#125;&#125; concat&amp;distinct代码演示 12345678910111213141516171819202122232425public class StreamDemo03 &#123; public static void main(String[] args) &#123; //创建一个集合，存储多个字符串元素 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：取前4个数据组成一个流 Stream&lt;String&gt; s1 = list.stream().limit(4); //需求2：跳过2个数据组成一个流 Stream&lt;String&gt; s2 = list.stream().skip(2); //需求3：合并需求1和需求2得到的流，并把结果在控制台输出// Stream.concat(s1,s2).forEach(s-&gt; System.out.println(s)); //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复 Stream.concat(s1,s2).distinct().forEach(s-&gt; System.out.println(s)); &#125;&#125; 2.4Stream流终结操作方法【应用】 概念 终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作 常见方法 方法名 说明 void forEach(Consumer action) 对此流的每个元素执行操作 long count() 返回此流中的元素数 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyStream5 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"张三丰\"); list.add(\"张无忌\"); list.add(\"张翠山\"); list.add(\"王二麻子\"); list.add(\"张良\"); list.add(\"谢广坤\"); //method1(list); // long count()：返回此流中的元素数 long count = list.stream().count(); System.out.println(count); &#125; private static void method1(ArrayList&lt;String&gt; list) &#123; // void forEach(Consumer action)：对此流的每个元素执行操作 // Consumer接口中的方法void accept(T t)：对给定的参数执行此操作 //在forEach方法的底层,会循环获取到流中的每一个数据. //并循环调用accept方法,并把每一个数据传递给accept方法 //s就依次表示了流中的每一个数据. //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了. list.stream().forEach( new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125; ); System.out.println(\"====================\"); //lambda表达式的简化格式 //是因为Consumer接口中,只有一个accept方法 list.stream().forEach( (String s)-&gt;&#123; System.out.println(s); &#125; ); System.out.println(\"====================\"); //lambda表达式还是可以进一步简化的. list.stream().forEach(s-&gt;System.out.println(s)); &#125;&#125; 2.5Stream流的收集操作【应用】 概念 对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中 常用方法 方法名 说明 R collect(Collector collector) 把结果收集到集合中 工具类Collectors提供了具体的收集方式 方法名 说明 public static Collector toList() 把元素收集到List集合中 public static Collector toSet() 把元素收集到Set集合中 public static Collector toMap(Function keyMapper,Function valueMapper) 把元素收集到Map集合中 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// toList和toSet方法演示 public class MyStream7 &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; list1.add(i); &#125; list1.add(10); list1.add(10); list1.add(10); list1.add(10); list1.add(10); //filter负责过滤数据的. //collect负责收集数据. //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中. //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中. List&lt;Integer&gt; list = list1.stream().filter(number -&gt; number % 2 == 0) .collect(Collectors.toList()); System.out.println(list); Set&lt;Integer&gt; set = list1.stream().filter(number -&gt; number % 2 == 0) .collect(Collectors.toSet()); System.out.println(set);&#125;&#125;/**Stream流的收集方法 toMap方法演示创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄\"zhangsan,23\"\"lisi,24\"\"wangwu,25\"保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值*/public class MyStream8 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"zhangsan,23\"); list.add(\"lisi,24\"); list.add(\"wangwu,25\"); Map&lt;String, Integer&gt; map = list.stream().filter( s -&gt; &#123; String[] split = s.split(\",\"); int age = Integer.parseInt(split[1]); return age &gt;= 24; &#125; // collect方法只能获取到流中剩余的每一个数据. //在底层不能创建容器,也不能把数据添加到容器当中 //Collectors.toMap 创建一个map集合并将数据添加到集合当中 // s 依次表示流中的每一个数据 //第一个lambda表达式就是如何获取到Map中的键 //第二个lambda表达式就是如何获取Map中的值 ).collect(Collectors.toMap( s -&gt; s.split(\",\")[0], s -&gt; Integer.parseInt(s.split(\",\")[1]) )); System.out.println(map); &#125;&#125; 5.6Stream流综合练习【应用】 案例需求 现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作 男演员只要名字为3个字的前三人 女演员只要姓林的，并且不要第一个 把过滤后的男演员姓名和女演员姓名合并到一起 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据 演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法 代码实现 演员类 123456789101112131415public class Actor &#123; private String name; public Actor(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435public class StreamTest &#123; public static void main(String[] args) &#123; //创建集合 ArrayList&lt;String&gt; manList = new ArrayList&lt;String&gt;(); manList.add(\"周润发\"); manList.add(\"成龙\"); manList.add(\"刘德华\"); manList.add(\"吴京\"); manList.add(\"周星驰\"); manList.add(\"李连杰\"); ArrayList&lt;String&gt; womanList = new ArrayList&lt;String&gt;(); womanList.add(\"林心如\"); womanList.add(\"张曼玉\"); womanList.add(\"林青霞\"); womanList.add(\"柳岩\"); womanList.add(\"林志玲\"); womanList.add(\"王祖贤\"); //男演员只要名字为3个字的前三人 Stream&lt;String&gt; manStream = manList.stream().filter(s -&gt; s.length() == 3).limit(3); //女演员只要姓林的，并且不要第一个 Stream&lt;String&gt; womanStream = womanList.stream().filter(s -&gt; s.startsWith(\"林\")).skip(1); //把过滤后的男演员姓名和女演员姓名合并到一起 Stream&lt;String&gt; stream = Stream.concat(manStream, womanStream); // 将流中的数据封装成Actor对象之后打印 stream.forEach(name -&gt; &#123; Actor actor = new Actor(name); System.out.println(actor); &#125;); &#125;&#125;","categories":[],"tags":[]},{"title":"19_集合03","slug":"19-集合03","date":"2020-11-10T09:01:15.000Z","updated":"2020-11-10T09:02:56.560Z","comments":true,"path":"2020/11/10/19-集合03/","link":"","permalink":"http://xiaojujing.com/2020/11/10/19-%E9%9B%86%E5%90%8803/","excerpt":"1.红黑树1.1概述【理解】 红黑树的特点 平衡二叉B树 每一个节点可以是红或者黑","text":"1.红黑树1.1概述【理解】 红黑树的特点 平衡二叉B树 每一个节点可以是红或者黑 红黑树不是高度平衡的,它的平衡是通过”自己的红黑规则”进行实现的 红黑树的红黑规则有哪些 每一个节点或是红色的,或者是黑色的 根节点必须是黑色 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况) 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点 红黑树添加节点的默认颜色 添加节点时,默认为红色,效率高 红黑树添加节点后如何保持红黑规则 根节点位置 直接变为黑色 非根节点位置 父节点为黑色 不需要任何操作,默认红色即可 父节点为红色 叔叔节点为红色 将”父节点”设为黑色,将”叔叔节点”设为黑色 将”祖父节点”设为红色 如果”祖父节点”为根节点,则将根节点再次变成黑色 叔叔节点为黑色 将”父节点”设为黑色 将”祖父节点”设为红色 以”祖父节点”为支点进行旋转 1.2成绩排序案例【应用】 案例需求 用TreeSet集合存储多个学生信息(姓名,语文成绩,数学成绩,英语成绩),并遍历该集合 要求: 按照总分从高到低出现 代码实现 学生类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Student implements Comparable&lt;Student&gt; &#123; private String name; private int chinese; private int math; private int english; public Student() &#123; &#125; public Student(String name, int chinese, int math, int english) &#123; this.name = name; this.chinese = chinese; this.math = math; this.english = english; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getChinese() &#123; return chinese; &#125; public void setChinese(int chinese) &#123; this.chinese = chinese; &#125; public int getMath() &#123; return math; &#125; public void setMath(int math) &#123; this.math = math; &#125; public int getEnglish() &#123; return english; &#125; public void setEnglish(int english) &#123; this.english = english; &#125; public int getSum() &#123; return this.chinese + this.math + this.english; &#125; @Override public int compareTo(Student o) &#123; // 主要条件: 按照总分进行排序 int result = o.getSum() - this.getSum(); // 次要条件: 如果总分一样,就按照语文成绩排序 result = result == 0 ? o.getChinese() - this.getChinese() : result; // 如果语文成绩也一样,就按照数学成绩排序 result = result == 0 ? o.getMath() - this.getMath() : result; // 如果总分一样,各科成绩也都一样,就按照姓名排序 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; &#125;&#125; 测试类 12345678910111213141516171819public class TreeSetDemo &#123; public static void main(String[] args) &#123; //创建TreeSet集合对象，通过比较器排序进行排序 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(); //创建学生对象 Student s1 = new Student(\"jack\", 98, 100, 95); Student s2 = new Student(\"rose\", 95, 95, 95); Student s3 = new Student(\"sam\", 100, 93, 98); //把学生对象添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); //遍历集合 for (Student s : ts) &#123; System.out.println(s.getName() + \",\" + s.getChinese() + \",\" + s.getMath() + \",\" + s.getEnglish() + \",\" + s.getSum()); &#125; &#125;&#125; 2.HashSet集合2.1HashSet集合概述和特点【应用】 底层数据结构是哈希表 存取无序 不可以存储重复元素 没有索引,不能使用普通for循环遍历 2.2HashSet集合的基本应用【应用】存储字符串并遍历 123456789101112131415161718public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建集合对象 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(\"hello\"); set.add(\"world\"); set.add(\"java\"); //不包含重复元素的集合 set.add(\"world\"); //遍历 for(String s : set) &#123; System.out.println(s); &#125; &#125;&#125; 2.3哈希值【理解】 哈希值简介 ​ 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值 如何获取哈希值 ​ Object类中的public int hashCode()：返回对象的哈希码值 哈希值的特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同 2.4哈希表结构【理解】 JDK1.8以前 ​ 数组 + 链表 JDK1.8以后 节点个数少于等于8个 ​ 数组 + 链表 节点个数多于8个 ​ 数组 + 红黑树 2.5HashSet集合存储学生对象并遍历【应用】 案例需求 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合 要求：学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125;&#125; 测试类 123456789101112131415161718192021222324public class HashSetDemo02 &#123; public static void main(String[] args) &#123; //创建HashSet集合对象 HashSet&lt;Student&gt; hs = new HashSet&lt;Student&gt;(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"张曼玉\", 35); Student s3 = new Student(\"王祖贤\", 33); Student s4 = new Student(\"王祖贤\", 33); //把学生添加到集合 hs.add(s1); hs.add(s2); hs.add(s3); hs.add(s4); //遍历集合(增强for) for (Student s : hs) &#123; System.out.println(s.getName() + \",\" + s.getAge()); &#125; &#125;&#125; 总结 ​ HashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法 3.Map集合3.1Map集合概述和特点【理解】 Map集合概述 1interface Map&lt;K,V&gt; K：键的类型；V：值的类型 Map集合的特点 双列集合,一个键对应一个值 键不可以重复,值可以重复 Map集合的基本使用 123456789101112131415public class MapDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //V put(K key, V value) 将指定的值与该映射中的指定键相关联 map.put(\"itheima001\",\"林青霞\"); map.put(\"itheima002\",\"张曼玉\"); map.put(\"itheima003\",\"王祖贤\"); map.put(\"itheima003\",\"柳岩\"); //输出集合对象 System.out.println(map); &#125;&#125; 3.2Map集合的基本功能【应用】 方法介绍 方法名 说明 V put(K key,V value) 添加元素 V remove(Object key) 根据键删除键值对元素 void clear() 移除所有的键值对元素 boolean containsKey(Object key) 判断集合是否包含指定的键 boolean containsValue(Object value) 判断集合是否包含指定的值 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中键值对的个数 示例代码 12345678910111213141516171819202122232425262728293031public class MapDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //V put(K key,V value)：添加元素 map.put(\"张无忌\",\"赵敏\"); map.put(\"郭靖\",\"黄蓉\"); map.put(\"杨过\",\"小龙女\"); //V remove(Object key)：根据键删除键值对元素// System.out.println(map.remove(\"郭靖\"));// System.out.println(map.remove(\"郭襄\")); //void clear()：移除所有的键值对元素// map.clear(); //boolean containsKey(Object key)：判断集合是否包含指定的键// System.out.println(map.containsKey(\"郭靖\"));// System.out.println(map.containsKey(\"郭襄\")); //boolean isEmpty()：判断集合是否为空// System.out.println(map.isEmpty()); //int size()：集合的长度，也就是集合中键值对的个数 System.out.println(map.size()); //输出集合对象 System.out.println(map); &#125;&#125; 3.3Map集合的获取功能【应用】 方法介绍 方法名 说明 V get(Object key) 根据键获取值 Set keySet() 获取所有键的集合 Collection values() 获取所有值的集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 获取所有键值对对象的集合 示例代码 123456789101112131415161718192021222324252627public class MapDemo03 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //V get(Object key):根据键获取值// System.out.println(map.get(\"张无忌\"));// System.out.println(map.get(\"张三丰\")); //Set&lt;K&gt; keySet():获取所有键的集合// Set&lt;String&gt; keySet = map.keySet();// for(String key : keySet) &#123;// System.out.println(key);// &#125; //Collection&lt;V&gt; values():获取所有值的集合 Collection&lt;String&gt; values = map.values(); for(String value : values) &#123; System.out.println(value); &#125; &#125;&#125; 3.4Map集合的遍历(方式1)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 把所有的丈夫给集中起来 遍历丈夫的集合，获取到每一个丈夫 根据丈夫去找对应的妻子 步骤分析 获取所有键的集合。用keySet()方法实现 遍历键的集合，获取到每一个键。用增强for实现 根据键去找值。用get(Object key)方法实现 代码实现 1234567891011121314151617181920public class MapDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //获取所有键的集合。用keySet()方法实现 Set&lt;String&gt; keySet = map.keySet(); //遍历键的集合，获取到每一个键。用增强for实现 for (String key : keySet) &#123; //根据键去找值。用get(Object key)方法实现 String value = map.get(key); System.out.println(key + \",\" + value); &#125; &#125;&#125; 3.5Map集合的遍历(方式2)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 获取所有结婚证的集合 遍历结婚证的集合，得到每一个结婚证 根据结婚证获取丈夫和妻子 步骤分析 获取所有键值对对象的集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取所有键值对对象的集合 遍历键值对对象的集合，得到每一个键值对对象 用增强for实现，得到每一个Map.Entry 根据键值对对象获取键和值 用getKey()得到键 用getValue()得到值 代码实现 123456789101112131415161718192021public class MapDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //获取所有键值对对象的集合 Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); //遍历键值对对象的集合，得到每一个键值对对象 for (Map.Entry&lt;String, String&gt; me : entrySet) &#123; //根据键值对对象获取键和值 String key = me.getKey(); String value = me.getValue(); System.out.println(key + \",\" + value); &#125; &#125;&#125; 4.HashMap集合4.1HashMap集合概述和特点【理解】 HashMap底层是哈希表结构的 依赖hashCode方法和equals方法保证键的唯一 如果键要存储的是自定义对象，需要重写hashCode和equals方法 4.2HashMap集合应用案例【应用】 案例需求 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125;&#125; 测试类 12345678910111213141516171819202122232425public class HashMapDemo &#123; public static void main(String[] args) &#123; //创建HashMap集合对象 HashMap&lt;Student, String&gt; hm = new HashMap&lt;Student, String&gt;(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"张曼玉\", 35); Student s3 = new Student(\"王祖贤\", 33); Student s4 = new Student(\"王祖贤\", 33); //把学生添加到集合 hm.put(s1, \"西安\"); hm.put(s2, \"武汉\"); hm.put(s3, \"郑州\"); hm.put(s4, \"北京\"); //遍历集合 Set&lt;Student&gt; keySet = hm.keySet(); for (Student key : keySet) &#123; String value = hm.get(key); System.out.println(key.getName() + \",\" + key.getAge() + \",\" + value); &#125; &#125;&#125; 5.TreeMap集合5.1TreeMap集合概述和特点【理解】 TreeMap底层是红黑树结构 依赖自然排序或者比较器排序,对键进行排序 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则 5.2TreeMap集合应用案例【应用】 案例需求 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序 代码实现 学生类 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; @Override public int compareTo(Student o) &#123; //按照年龄进行排序 int result = o.getAge() - this.getAge(); //次要条件，按照姓名排序。 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; &#125;&#125; 测试类 1234567891011121314151617181920212223public class Test1 &#123; public static void main(String[] args) &#123; // 创建TreeMap集合对象 TreeMap&lt;Student,String&gt; tm = new TreeMap&lt;&gt;(); // 创建学生对象 Student s1 = new Student(\"xiaohei\",23); Student s2 = new Student(\"dapang\",22); Student s3 = new Student(\"xiaomei\",22); // 将学生对象添加到TreeMap集合中 tm.put(s1,\"江苏\"); tm.put(s2,\"北京\"); tm.put(s3,\"天津\"); // 遍历TreeMap集合,打印每个学生的信息 tm.forEach( (Student key, String value)-&gt;&#123; System.out.println(key + \"---\" + value); &#125; ); &#125;&#125;","categories":[],"tags":[]},{"title":"18_集合02","slug":"18-集合02","date":"2020-11-09T15:40:41.000Z","updated":"2020-11-09T15:41:50.074Z","comments":true,"path":"2020/11/09/18-集合02/","link":"","permalink":"http://xiaojujing.com/2020/11/09/18-%E9%9B%86%E5%90%8802/","excerpt":"1.泛型1.1泛型概述【理解】 泛型的介绍 ​ 泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制 泛型的好处","text":"1.泛型1.1泛型概述【理解】 泛型的介绍 ​ 泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制 泛型的好处 把运行时期的问题提前到了编译期间 避免了强制类型转换 泛型的定义格式 &lt;类型&gt;: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: &lt;类型1,类型2…&gt;: 指定多种类型的格式,多种类型之间用逗号隔开.例如: &lt;E,T&gt; &lt;K,V&gt; 1.2泛型类【应用】 定义格式 1修饰符 class 类名&lt;类型&gt; &#123; &#125; 示例代码 泛型类 1234567891011public class Generic&lt;T&gt; &#123; private T t; public T getT() &#123; return t; &#125; public void setT(T t) &#123; this.t = t; &#125;&#125; 测试类 123456789101112131415public class GenericDemo1 &#123; public static void main(String[] args) &#123; Generic&lt;String&gt; g1 = new Generic&lt;String&gt;(); g1.setT(\"杨幂\"); System.out.println(g1.getT()); Generic&lt;Integer&gt; g2 = new Generic&lt;Integer&gt;(); g2.setT(30); System.out.println(g2.getT()); Generic&lt;Boolean&gt; g3 = new Generic&lt;Boolean&gt;(); g3.setT(true); System.out.println(g3.getT()); &#125;&#125; 1.3泛型方法【应用】 定义格式 1修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名) &#123; &#125; 示例代码 带有泛型方法的类 12345public class Generic &#123; public &lt;T&gt; void show(T t) &#123; System.out.println(t); &#125;&#125; 测试类 123456789public class GenericDemo2 &#123; public static void main(String[] args) &#123; Generic g = new Generic(); g.show(\"柳岩\"); g.show(30); g.show(true); g.show(12.34); &#125;&#125; 1.4泛型接口【应用】 定义格式 1修饰符 interface 接口名&lt;类型&gt; &#123; &#125; 示例代码 泛型接口 123public interface Generic&lt;T&gt; &#123; void show(T t);&#125; 泛型接口实现类1 ​ 定义实现类时,定义和接口相同泛型,创建实现类对象时明确泛型的具体类型 123456public class GenericImpl1&lt;T&gt; implements Generic&lt;T&gt; &#123; @Override public void show(T t) &#123; System.out.println(t); &#125;&#125; 泛型接口实现类2 ​ 定义实现类时,直接明确泛型的具体类型 123456public class GenericImpl2 implements Generic&lt;Integer&gt;&#123; @Override public void show(Integer t) &#123; System.out.println(t); &#125;&#125; 测试类 1234567891011public class GenericDemo3 &#123; public static void main(String[] args) &#123; GenericImpl1&lt;String&gt; g1 = new GenericImpl&lt;String&gt;(); g1.show(\"林青霞\"); GenericImpl1&lt;Integer&gt; g2 = new GenericImpl&lt;Integer&gt;(); g2.show(30); GenericImpl2 g3 = new GenericImpl2(); g3.show(10); &#125;&#125; 1.5类型通配符 类型通配符: &lt;?&gt; ArrayList&lt;?&gt;: 表示元素类型未知的ArrayList,它的元素可以匹配任何的类型 但是并不能把元素添加到ArrayList中了,获取出来的也是父类类型 类型通配符上限: &lt;? extends 类型&gt; ArrayListList &lt;? extends Number&gt;: 它表示的类型是Number或者其子类型 类型通配符下限: &lt;? super 类型&gt; ArrayListList &lt;? super Number&gt;: 它表示的类型是Number或者其父类型 泛型通配符的使用 12345678910111213141516171819202122232425262728293031public class GenericDemo4 &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); ArrayList&lt;Number&gt; list3 = new ArrayList&lt;&gt;(); ArrayList&lt;Object&gt; list4 = new ArrayList&lt;&gt;(); method(list1); method(list2); method(list3); method(list4); getElement1(list1); getElement1(list2);//报错 getElement1(list3); getElement1(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125; // 泛型通配符: 此时的泛型?,可以是任意类型 public static void method(ArrayList&lt;?&gt; list)&#123;&#125; // 泛型的上限: 此时的泛型?,必须是Number类型或者Number类型的子类 public static void getElement1(ArrayList&lt;? extends Number&gt; list)&#123;&#125; // 泛型的下限: 此时的泛型?,必须是Number类型或者Number类型的父类 public static void getElement2(ArrayList&lt;? super Number&gt; list)&#123;&#125;&#125; 2.Set集合2.1Set集合概述和特点【应用】 不可以存储重复元素 没有索引,不能使用普通for循环遍历 2.2Set集合的使用【应用】存储字符串并遍历 1234567891011121314151617181920212223242526public class MySet1 &#123; public static void main(String[] args) &#123; //创建集合对象 Set&lt;String&gt; set = new TreeSet&lt;&gt;(); //添加元素 set.add(\"ccc\"); set.add(\"aaa\"); set.add(\"aaa\"); set.add(\"bbb\");// for (int i = 0; i &lt; set.size(); i++) &#123;// //Set集合是没有索引的，所以不能使用通过索引获取元素的方法// &#125; //遍历集合 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; System.out.println(\"-----------------------------------\"); for (String s : set) &#123; System.out.println(s); &#125; &#125;&#125; 3.TreeSet集合3.1TreeSet集合概述和特点【应用】 不可以存储重复元素 没有索引 可以将元素按照规则进行排序 TreeSet()：根据其元素的自然排序进行排序 TreeSet(Comparator comparator) ：根据指定的比较器进行排序 3.2TreeSet集合基本使用【应用】存储Integer类型的整数并遍历 1234567891011121314151617181920public class TreeSetDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Integer&gt; ts = new TreeSet&lt;Integer&gt;(); //添加元素 ts.add(10); ts.add(40); ts.add(30); ts.add(50); ts.add(20); ts.add(30); //遍历集合 for(Integer i : ts) &#123; System.out.println(i); &#125; &#125;&#125; 3.3自然排序Comparable的使用【应用】 案例需求 存储学生对象并遍历，创建TreeSet集合使用无参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 使用空参构造创建TreeSet集合 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的 自定义的Student类实现Comparable接口 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法 重写接口中的compareTo方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; @Override public int compareTo(Student o) &#123; //按照对象的年龄进行排序 //主要判断条件: 按照年龄从小到大排序 int result = this.age - o.age; //次要判断条件: 年龄相同时，按照姓名的字母顺序排序 result = result == 0 ? this.name.compareTo(o.getName()) : result; return result; &#125;&#125; 测试类 12345678910111213141516171819202122public class MyTreeSet2 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(); //创建学生对象 Student s1 = new Student(\"zhangsan\",28); Student s2 = new Student(\"lisi\",27); Student s3 = new Student(\"wangwu\",29); Student s4 = new Student(\"zhaoliu\",28); Student s5 = new Student(\"qianqi\",30); //把学生添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); //遍历集合 for (Student student : ts) &#123; System.out.println(student); &#125; &#125;&#125; 3.4比较器排序Comparator的使用【应用】 案例需求 存储老师对象并遍历，创建TreeSet集合使用带参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 老师类 123456789101112131415161718192021222324252627282930313233343536public class Teacher &#123; private String name; private int age; public Teacher() &#123; &#125; public Teacher(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Teacher&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132public class MyTreeSet4 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Teacher&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Teacher&gt;() &#123; @Override public int compare(Teacher o1, Teacher o2) &#123; //o1表示现在要存入的那个元素 //o2表示已经存入到集合中的元素 //主要条件 int result = o1.getAge() - o2.getAge(); //次要条件 result = result == 0 ? o1.getName().compareTo(o2.getName()) : result; return result; &#125; &#125;); //创建老师对象 Teacher t1 = new Teacher(\"zhangsan\",23); Teacher t2 = new Teacher(\"lisi\",22); Teacher t3 = new Teacher(\"wangwu\",24); Teacher t4 = new Teacher(\"zhaoliu\",24); //把老师添加到集合 ts.add(t1); ts.add(t2); ts.add(t3); ts.add(t4); //遍历集合 for (Teacher teacher : ts) &#123; System.out.println(teacher); &#125; &#125;&#125; 3.5两种比较方式总结【理解】 两种比较方式小结 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序 两种方式中关于返回值的规则 如果返回值为负数，表示当前存入的元素是较小值，存左边 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存 如果返回值为正数，表示当前存入的元素是较大值，存右边 4.数据结构4.1二叉树【理解】 二叉树的特点 二叉树中,任意一个节点的度要小于等于2 节点: 在树结构中,每一个元素称之为节点 度: 每一个节点的子节点数量称之为度 二叉树结构图 4.2二叉查找树【理解】 二叉查找树的特点 二叉查找树,又称二叉排序树或者二叉搜索树 每一个节点上最多有两个子节点 左子树上所有节点的值都小于根节点的值 右子树上所有节点的值都大于根节点的值 二叉查找树结构图 二叉查找树和二叉树对比结构图 二叉查找树添加节点规则 小的存左边 大的存右边 一样的不存 4.3平衡二叉树【理解】 平衡二叉树的特点 二叉树左右两个子树的高度差不超过1 任意节点的左右两个子树都是一颗平衡二叉树 平衡二叉树旋转 旋转触发时机 当添加一个节点之后,该树不再是一颗平衡二叉树 左旋 就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点 右旋 就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点 平衡二叉树和二叉查找树对比结构图 平衡二叉树旋转的四种情况 左左 左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行右旋即可 左右 左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋 右右 右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行左旋即可 右左 右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋","categories":[],"tags":[]},{"title":"17_集合01","slug":"17-集合01","date":"2020-11-09T15:40:23.000Z","updated":"2020-11-09T15:41:15.926Z","comments":true,"path":"2020/11/09/17-集合01/","link":"","permalink":"http://xiaojujing.com/2020/11/09/17-%E9%9B%86%E5%90%8801/","excerpt":"1.Collection集合1.1数组和集合的区别【理解】 相同点 都是容器,可以存储多个数据","text":"1.Collection集合1.1数组和集合的区别【理解】 相同点 都是容器,可以存储多个数据 不同点 数组的长度是不可变的,集合的长度是可变的 数组可以存基本数据类型和引用数据类型 集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类 1.2集合类体系结构【理解】 1.3Collection 集合概述和使用【应用】 Collection集合概述 是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素 JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现 创建Collection集合的对象 多态的方式 具体的实现类ArrayList Collection集合常用方法 方法名 说明 boolean add(E e) 添加元素 boolean remove(Object o) 从集合中移除指定的元素 boolean removeIf(Object o) 根据条件进行移除 void clear() 清空集合中的元素 boolean contains(Object o) 判断集合中是否存在指定的元素 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中元素的个数 1.4Collection集合的遍历【应用】 迭代器介绍 迭代器,集合的专用遍历方式 Iterator iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到 Iterator中的常用方法 ​ boolean hasNext(): 判断当前位置是否有元素可以被取出​ E next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置 Collection集合的遍历 123456789101112131415161718192021public class IteratorDemo1 &#123; public static void main(String[] args) &#123; //创建集合对象 Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); //添加元素 c.add(\"hello\"); c.add(\"world\"); c.add(\"java\"); c.add(\"javaee\"); //Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到 Iterator&lt;String&gt; it = c.iterator(); //用while循环改进元素的判断和获取 while (it.hasNext()) &#123; String s = it.next(); System.out.println(s); &#125; &#125;&#125; 迭代器中删除的方法 ​ void remove(): 删除迭代器对象当前指向的元素 1234567891011121314151617181920public class IteratorDemo2 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"b\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); if(\"b\".equals(s))&#123; //指向谁,那么此时就删除谁. it.remove(); &#125; &#125; System.out.println(list); &#125;&#125; 1.5增强for循环【应用】 介绍 它是JDK5之后出现的,其内部原理是一个Iterator迭代器 实现Iterable接口的类才可以使用迭代器和增强for 简化数组和Collection集合的遍历 格式 ​ for(集合/数组中元素的数据类型 变量名 : 集合/数组名) { ​ // 已经将当前遍历到的元素封装到变量中了,直接使用变量即可 ​ } 代码 123456789101112131415161718public class MyCollectonDemo1 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\"); list.add(\"f\"); //1,数据类型一定是集合或者数组中元素的类型 //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素 //3,list就是要遍历的集合或者数组 for(String str : list)&#123; System.out.println(str); &#125; &#125;&#125; 2.List集合2.1List集合的概述和特点【记忆】 List集合的概述 有序集合,这里的有序指的是存取顺序 用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素 与Set集合不同,列表通常允许重复的元素 List集合的特点 存取有序 可以重复 有索引 2.2List集合的特有方法【应用】 方法介绍 方法名 描述 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyListDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); //method1(list); //method2(list); //method3(list); //method4(list); &#125; private static void method4(List&lt;String&gt; list) &#123; // E get(int index) 返回指定索引处的元素 String s = list.get(0); System.out.println(s); &#125; private static void method3(List&lt;String&gt; list) &#123; // E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 //被替换的那个元素,在集合中就不存在了. String result = list.set(0, \"qqq\"); System.out.println(result); System.out.println(list); &#125; private static void method2(List&lt;String&gt; list) &#123; // E remove(int index) 删除指定索引处的元素，返回被删除的元素 //在List集合中有两个删除的方法 //第一个 删除指定的元素,返回值表示当前元素是否删除成功 //第二个 删除指定索引的元素,返回值表示实际删除的元素 String s = list.remove(0); System.out.println(s); System.out.println(list); &#125; private static void method1(List&lt;String&gt; list) &#123; // void add(int index,E element) 在此集合中的指定位置插入指定的元素 //原来位置上的元素往后挪一个索引. list.add(0,\"qqq\"); System.out.println(list); &#125;&#125; 3.数据结构3.1数据结构之栈和队列【记忆】 栈结构 ​ 先进后出 队列结构 ​ 先进先出 3.2数据结构之数组和链表【记忆】 数组结构 ​ 查询快、增删慢 队列结构 ​ 查询慢、增删快 4.List集合的实现类4.1List集合子类的特点【记忆】 ArrayList集合 ​ 底层是数组结构实现，查询快、增删慢 LinkedList集合 ​ 底层是链表结构实现，查询慢、增删快 4.2LinkedList集合的特有功能【应用】 特有方法 方法名 说明 public void addFirst(E e) 在该列表开头插入指定的元素 public void addLast(E e) 将指定的元素追加到此列表的末尾 public E getFirst() 返回此列表中的第一个元素 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyLinkedListDemo4 &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\");// public void addFirst(E e) 在该列表开头插入指定的元素 //method1(list);// public void addLast(E e) 将指定的元素追加到此列表的末尾 //method2(list);// public E getFirst() 返回此列表中的第一个元素// public E getLast() 返回此列表中的最后一个元素 //method3(list);// public E removeFirst() 从此列表中删除并返回第一个元素// public E removeLast() 从此列表中删除并返回最后一个元素 //method4(list); &#125; private static void method4(LinkedList&lt;String&gt; list) &#123; String first = list.removeFirst(); System.out.println(first); String last = list.removeLast(); System.out.println(last); System.out.println(list); &#125; private static void method3(LinkedList&lt;String&gt; list) &#123; String first = list.getFirst(); String last = list.getLast(); System.out.println(first); System.out.println(last); &#125; private static void method2(LinkedList&lt;String&gt; list) &#123; list.addLast(\"www\"); System.out.println(list); &#125; private static void method1(LinkedList&lt;String&gt; list) &#123; list.addFirst(\"qqq\"); System.out.println(list); &#125;&#125; ​","categories":[],"tags":[]},{"title":"16-API02","slug":"16-API02","date":"2020-11-08T12:58:52.000Z","updated":"2020-11-08T13:00:15.957Z","comments":true,"path":"2020/11/08/16-API02/","link":"","permalink":"http://xiaojujing.com/2020/11/08/16-API02/","excerpt":"1.时间日期类1.1 Date类（应用） 计算机中时间原点 1970年1月1日 00:00:00","text":"1.时间日期类1.1 Date类（应用） 计算机中时间原点 1970年1月1日 00:00:00 时间换算单位 1秒 = 1000毫秒 Date类概述 Date 代表了一个特定的时间，精确到毫秒 Date类构造方法 方法名 说明 public Date() 分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 public Date(long date) 分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 示例代码 123456789101112public class DateDemo01 &#123; public static void main(String[] args) &#123; //public Date()：分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 Date d1 = new Date(); System.out.println(d1); //public Date(long date)：分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 long date = 1000*60*60; Date d2 = new Date(date); System.out.println(d2); &#125;&#125; 1.2 Date类常用方法（应用） 常用方法 方法名 说明 public long getTime() 获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 public void setTime(long time) 设置时间，给的是毫秒值 示例代码 1234567891011121314151617public class DateDemo02 &#123; public static void main(String[] args) &#123; //创建日期对象 Date d = new Date(); //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值// System.out.println(d.getTime());// System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + \"年\"); //public void setTime(long time):设置时间，给的是毫秒值// long time = 1000*60*60; long time = System.currentTimeMillis(); d.setTime(time); System.out.println(d); &#125;&#125; 1.3 SimpleDateFormat类（应用） SimpleDateFormat类概述 ​ SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。 ​ 我们重点学习日期格式化和解析 SimpleDateFormat类构造方法 方法名 说明 public SimpleDateFormat() 构造一个SimpleDateFormat，使用默认模式和日期格式 public SimpleDateFormat(String pattern) 构造一个SimpleDateFormat使用给定的模式和默认的日期格式 SimpleDateFormat类的常用方法 格式化(从Date到String) public final String format(Date date)：将日期格式化成日期/时间字符串 解析(从String到Date) public Date parse(String source)：从给定字符串的开始解析文本以生成日期 示例代码 123456789101112131415161718public class SimpleDateFormatDemo &#123; public static void main(String[] args) throws ParseException &#123; //格式化：从 Date 到 String Date d = new Date();// SimpleDateFormat sdf = new SimpleDateFormat(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String s = sdf.format(d); System.out.println(s); System.out.println(\"--------\"); //从 String 到 Date String ss = \"2048-08-09 11:11:11\"; //ParseException SimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date dd = sdf2.parse(ss); System.out.println(dd); &#125;&#125; 1.4 时间日期类练习 (应用) 需求 秒杀开始时间是2020年11月11日 00:00:00,结束时间是2020年11月11日 00:10:00,用户小贾下单时间是2020年11月11日 00:03:47,用户小皮下单时间是2020年11月11日 00:10:11,判断用户有没有成功参与秒杀活动 实现步骤 判断下单时间是否在开始到结束的范围内 把字符串形式的时间变成毫秒值 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class DateDemo5 &#123; public static void main(String[] args) throws ParseException &#123; //开始时间：2020年11月11日 0:0:0 //结束时间：2020年11月11日 0:10:0 //小贾2020年11月11日 0:03:47 //小皮2020年11月11日 0:10:11 //1.判断两位同学的下单时间是否在范围之内就可以了。 //2.要把每一个时间都换算成毫秒值。 String start = \"2020年11月11日 0:0:0\"; String end = \"2020年11月11日 0:10:0\"; String jia = \"2020年11月11日 0:03:47\"; String pi = \"2020年11月11日 0:10:11\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); long startTime = sdf.parse(start).getTime(); long endTime = sdf.parse(end).getTime();// System.out.println(startTime);// System.out.println(endTime); long jiaTime = sdf.parse(jia).getTime(); long piTime = sdf.parse(pi).getTime(); if(jiaTime &gt;= startTime &amp;&amp; jiaTime &lt;= endTime)&#123; System.out.println(\"小贾同学参加上了秒杀活动\"); &#125;else&#123; System.out.println(\"小贾同学没有参加上秒杀活动\"); &#125; System.out.println(\"------------------------\"); if(piTime &gt;= startTime &amp;&amp; piTime &lt;= endTime)&#123; System.out.println(\"小皮同学参加上了秒杀活动\"); &#125;else&#123; System.out.println(\"小皮同学没有参加上秒杀活动\"); &#125; &#125; &#125; 2.JDK8时间日期类2.1 JDK8新增日期类 (理解) LocalDate 表示日期（年月日） LocalTime 表示时间（时分秒） LocalDateTime 表示时间+ 日期 （年月日时分秒） 2.2 LocalDateTime创建方法 (应用) 方法说明 方法名 说明 public static LocalDateTime now() 获取当前系统时间 public static LocalDateTime of (年, 月 , 日, 时, 分, 秒) 使用指定年月日和时分秒初始化一个LocalDateTime对象 示例代码 123456789public class JDK8DateDemo2 &#123; public static void main(String[] args) &#123; LocalDateTime now = LocalDateTime.now(); System.out.println(now); LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 11); System.out.println(localDateTime); &#125;&#125; 2.3 LocalDateTime获取方法 (应用) 方法说明 方法名 说明 public int getYear() 获取年 public int getMonthValue() 获取月份（1-12） public int getDayOfMonth() 获取月份中的第几天（1-31） public int getDayOfYear() 获取一年中的第几天（1-366） public DayOfWeek getDayOfWeek() 获取星期 public int getMinute() 获取分钟 public int getHour() 获取小时 示例代码 12345678910111213141516171819202122232425262728293031323334public class JDK8DateDemo3 &#123; public static void main(String[] args) &#123; LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 20); //public int getYear() 获取年 int year = localDateTime.getYear(); System.out.println(\"年为\" +year); //public int getMonthValue() 获取月份（1-12） int month = localDateTime.getMonthValue(); System.out.println(\"月份为\" + month); Month month1 = localDateTime.getMonth();// System.out.println(month1); //public int getDayOfMonth() 获取月份中的第几天（1-31） int day = localDateTime.getDayOfMonth(); System.out.println(\"日期为\" + day); //public int getDayOfYear() 获取一年中的第几天（1-366） int dayOfYear = localDateTime.getDayOfYear(); System.out.println(\"这是一年中的第\" + dayOfYear + \"天\"); //public DayOfWeek getDayOfWeek()获取星期 DayOfWeek dayOfWeek = localDateTime.getDayOfWeek(); System.out.println(\"星期为\" + dayOfWeek); //public int getMinute() 获取分钟 int minute = localDateTime.getMinute(); System.out.println(\"分钟为\" + minute); //public int getHour() 获取小时 int hour = localDateTime.getHour(); System.out.println(\"小时为\" + hour); &#125;&#125; 2.4 LocalDateTime转换方法 (应用) 方法说明 方法名 说明 public LocalDate toLocalDate () 转换成为一个LocalDate对象 public LocalTime toLocalTime () 转换成为一个LocalTime对象 示例代码 123456789101112public class JDK8DateDemo4 &#123; public static void main(String[] args) &#123; LocalDateTime localDateTime = LocalDateTime.of(2020, 12, 12, 8, 10, 12); //public LocalDate toLocalDate () 转换成为一个LocalDate对象 LocalDate localDate = localDateTime.toLocalDate(); System.out.println(localDate); //public LocalTime toLocalTime () 转换成为一个LocalTime对象 LocalTime localTime = localDateTime.toLocalTime(); System.out.println(localTime); &#125;&#125; 2.5 LocalDateTime格式化和解析 (应用) 方法说明 方法名 说明 public String format (指定格式) 把一个LocalDateTime格式化成为一个字符串 public LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象 public static DateTimeFormatter ofPattern(String pattern) 使用指定的日期模板获取一个日期格式化器DateTimeFormatter对象 示例代码 1234567891011121314151617181920212223public class JDK8DateDemo5 &#123; public static void main(String[] args) &#123; //method1(); //method2(); &#125; private static void method2() &#123; //public static LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象 String s = \"2020年11月12日 13:14:15\"; DateTimeFormatter pattern = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss\"); LocalDateTime parse = LocalDateTime.parse(s, pattern); System.out.println(parse); &#125; private static void method1() &#123; LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 12, 13, 14, 15); System.out.println(localDateTime); //public String format (指定格式) 把一个LocalDateTime格式化成为一个字符串 DateTimeFormatter pattern = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss\"); String s = localDateTime.format(pattern); System.out.println(s); &#125;&#125; 2.6 LocalDateTime增加或者减少时间的方法 (应用) 方法说明 方法名 说明 public LocalDateTime plusYears (long years) 添加或者减去年 public LocalDateTime plusMonths(long months) 添加或者减去月 public LocalDateTime plusDays(long days) 添加或者减去日 public LocalDateTime plusHours(long hours) 添加或者减去时 public LocalDateTime plusMinutes(long minutes) 添加或者减去分 public LocalDateTime plusSeconds(long seconds) 添加或者减去秒 public LocalDateTime plusWeeks(long weeks) 添加或者减去周 示例代码 123456789101112131415/** * JDK8 时间类添加或者减去时间的方法 */public class JDK8DateDemo6 &#123; public static void main(String[] args) &#123; //public LocalDateTime plusYears (long years) 添加或者减去年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); //LocalDateTime newLocalDateTime = localDateTime.plusYears(1); //System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.plusYears(-1); System.out.println(newLocalDateTime); &#125;&#125; 2.7 LocalDateTime减少或者增加时间的方法 (应用) 方法说明 方法名 说明 public LocalDateTime minusYears (long years) 减去或者添加年 public LocalDateTime minusMonths(long months) 减去或者添加月 public LocalDateTime minusDays(long days) 减去或者添加日 public LocalDateTime minusHours(long hours) 减去或者添加时 public LocalDateTime minusMinutes(long minutes) 减去或者添加分 public LocalDateTime minusSeconds(long seconds) 减去或者添加秒 public LocalDateTime minusWeeks(long weeks) 减去或者添加周 示例代码 123456789101112131415/** * JDK8 时间类减少或者添加时间的方法 */public class JDK8DateDemo7 &#123; public static void main(String[] args) &#123; //public LocalDateTime minusYears (long years) 减去或者添加年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); //LocalDateTime newLocalDateTime = localDateTime.minusYears(1); //System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.minusYears(-1); System.out.println(newLocalDateTime); &#125;&#125; 2.8 LocalDateTime修改方法 (应用) 方法说明 方法名 说明 public LocalDateTime withYear(int year) 直接修改年 public LocalDateTime withMonth(int month) 直接修改月 public LocalDateTime withDayOfMonth(int dayofmonth) 直接修改日期(一个月中的第几天) public LocalDateTime withDayOfYear(int dayOfYear) 直接修改日期(一年中的第几天) public LocalDateTime withHour(int hour) 直接修改小时 public LocalDateTime withMinute(int minute) 直接修改分钟 public LocalDateTime withSecond(int second) 直接修改秒 示例代码 123456789101112131415/** * JDK8 时间类修改时间 */public class JDK8DateDemo8 &#123; public static void main(String[] args) &#123; //public LocalDateTime withYear(int year) 修改年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); // LocalDateTime newLocalDateTime = localDateTime.withYear(2048); // System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.withMonth(20); System.out.println(newLocalDateTime); &#125;&#125; 2.9 Period (应用) 方法说明 方法名 说明 public static Period between(开始时间,结束时间) 计算两个“时间”的间隔 public int getYears() 获得这段时间的年数 public int getMonths() 获得此期间的月数 public int getDays() 获得此期间的天数 public long toTotalMonths() 获取此期间的总月数 示例代码 123456789101112131415161718192021222324/** * 计算两个时间的间隔 */public class JDK8DateDemo9 &#123; public static void main(String[] args) &#123; //public static Period between(开始时间,结束时间) 计算两个\"时间\"的间隔 LocalDate localDate1 = LocalDate.of(2020, 1, 1); LocalDate localDate2 = LocalDate.of(2048, 12, 12); Period period = Period.between(localDate1, localDate2); System.out.println(period);//P28Y11M11D //public int getYears() 获得这段时间的年数 System.out.println(period.getYears());//28 //public int getMonths() 获得此期间的月数 System.out.println(period.getMonths());//11 //public int getDays() 获得此期间的天数 System.out.println(period.getDays());//11 //public long toTotalMonths() 获取此期间的总月数 System.out.println(period.toTotalMonths());//347 &#125;&#125; 2.10 Duration (应用) 方法说明 方法名 说明 public static Durationbetween(开始时间,结束时间) 计算两个“时间”的间隔 public long toSeconds() 获得此时间间隔的秒 public int toMillis() 获得此时间间隔的毫秒 public int toNanos() 获得此时间间隔的纳秒 示例代码 12345678910111213141516171819/** * 计算两个时间的间隔 */public class JDK8DateDemo10 &#123; public static void main(String[] args) &#123; //public static Duration between(开始时间,结束时间) 计算两个“时间\"的间隔 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 1, 13, 14, 15); LocalDateTime localDateTime2 = LocalDateTime.of(2020, 1, 2, 11, 12, 13); Duration duration = Duration.between(localDateTime1, localDateTime2); System.out.println(duration);//PT21H57M58S //public long toSeconds() 获得此时间间隔的秒 System.out.println(duration.toSeconds());//79078 //public int toMillis() 获得此时间间隔的毫秒 System.out.println(duration.toMillis());//79078000 //public int toNanos() 获得此时间间隔的纳秒 System.out.println(duration.toNanos());//79078000000000 &#125;&#125; 3.异常3.1 异常（记忆） 异常的概述 ​ 异常就是程序出现了不正常的情况 异常的体系结构 3.2 编译时异常和运行时异常的区别（记忆） 编译时异常 都是Exception类及其子类 必须显示处理，否则程序就会发生错误，无法通过编译 运行时异常 都是RuntimeException类及其子类 无需显示处理，也可以和编译时异常一样处理 图示 3.3 JVM默认处理异常的方式（理解） 如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤： 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台 程序停止执行 3.4 查看异常信息 (理解)控制台在打印异常信息时,会打印异常类名,异常出现的原因,异常出现的位置 我们调bug时,可以根据提示,找到异常出现的位置,分析原因,修改异常代码 3.5 throws方式处理异常（应用） 定义格式 123public void 方法() throws 异常类名 &#123; &#125; 示例代码 1234567891011121314151617181920212223public class ExceptionDemo &#123; public static void main(String[] args) throws ParseException&#123; System.out.println(\"开始\");// method(); method2(); System.out.println(\"结束\"); &#125; //编译时异常 public static void method2() throws ParseException &#123; String s = \"2048-08-09\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date d = sdf.parse(s); System.out.println(d); &#125; //运行时异常 public static void method() throws ArrayIndexOutOfBoundsException &#123; int[] arr = &#123;1, 2, 3&#125;; System.out.println(arr[3]); &#125;&#125; 注意事项 这个throws格式是跟在方法的括号后面的 编译时异常必须要进行处理，两种处理方案：try…catch …或者 throws，如果采用 throws 这种方案，在方法上进行显示声明,将来谁调用这个方法谁处理 运行时异常因为在运行时才会发生,所以在方法后面可以不写,运行时出现异常默认交给jvm处理 3.6 throw抛出异常 (应用) 格式 throw new 异常(); 注意 这个格式是在方法内的，表示当前代码手动抛出一个异常，下面的代码不用再执行了 throws和throw的区别 throws throw 用在方法声明后面，跟的是异常类名 用在方法体内，跟的是异常对象名 表示声明异常，调用该方法有可能会出现这样的异常 表示手动抛出异常对象，由方法体内的语句处理 示例代码 12345678910111213141516171819202122public class ExceptionDemo8 &#123; public static void main(String[] args) &#123; //int [] arr = &#123;1,2,3,4,5&#125;; int [] arr = null; printArr(arr);//就会 接收到一个异常. //我们还需要自己处理一下异常. &#125; private static void printArr(int[] arr) &#123; if(arr == null)&#123; //调用者知道成功打印了吗? //System.out.println(\"参数不能为null\"); throw new NullPointerException(); //当参数为null的时候 //手动创建了一个异常对象,抛给了调用者,产生了一个异常 &#125;else&#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; &#125;&#125; 3.7 try-catch方式处理异常（应用） 定义格式 12345try &#123; 可能出现异常的代码;&#125; catch(异常类名 变量名) &#123; 异常的处理代码;&#125; 执行流程 程序从 try 里面的代码开始执行 出现异常，就会跳转到对应的 catch 里面去执行 执行完毕之后，程序还可以继续往下执行 示例代码 1234567891011121314151617public class ExceptionDemo01 &#123; public static void main(String[] args) &#123; System.out.println(\"开始\"); method(); System.out.println(\"结束\"); &#125; public static void method() &#123; try &#123; int[] arr = &#123;1, 2, 3&#125;; System.out.println(arr[3]); System.out.println(\"这里能够访问到吗\"); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println(\"你访问的数组索引不存在，请回去修改为正确的索引\"); &#125; &#125;&#125; 注意 如果 try 中没有遇到问题，怎么执行？ 会把try中所有的代码全部执行完毕,不会执行catch里面的代码 如果 try 中遇到了问题，那么 try 下面的代码还会执行吗？ 那么直接跳转到对应的catch语句中,try下面的代码就不会再执行了当catch里面的语句全部执行完毕,表示整个体系全部执行完全,继续执行下面的代码 如果出现的问题没有被捕获，那么程序如何运行？ 那么try…catch就相当于没有写.那么也就是自己没有处理.默认交给虚拟机处理. 同时有可能出现多个异常怎么处理？ 出现多个异常,那么就写多个catch就可以了.注意点:如果多个异常之间存在子父类关系.那么父类一定要写在下面 3.8 Throwable成员方法（应用） 常用方法 方法名 说明 public String getMessage() 返回此 throwable 的详细消息字符串 public String toString() 返回此可抛出的简短描述 public void printStackTrace() 把异常的错误信息输出在控制台 示例代码 1234567891011121314151617181920212223242526272829303132public class ExceptionDemo02 &#123; public static void main(String[] args) &#123; System.out.println(\"开始\"); method(); System.out.println(\"结束\"); &#125; public static void method() &#123; try &#123; int[] arr = &#123;1, 2, 3&#125;; System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException(); System.out.println(\"这里能够访问到吗\"); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; //new ArrayIndexOutOfBoundsException();// e.printStackTrace(); //public String getMessage():返回此 throwable 的详细消息字符串// System.out.println(e.getMessage()); //Index 3 out of bounds for length 3 //public String toString():返回此可抛出的简短描述// System.out.println(e.toString()); //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 //public void printStackTrace():把异常的错误信息输出在控制台 e.printStackTrace();// java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3// at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18)// at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11) &#125; &#125;&#125; 3.9 异常的练习 (应用) 需求 键盘录入学生的姓名和年龄,其中年龄为18 - 25岁,超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止 实现步骤 创建学生对象 键盘录入姓名和年龄，并赋值给学生对象 如果是非法数据就再次录入 代码实现 学生类 1234567891011121314151617181920212223242526272829303132333435363738394041public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age &gt;= 18 &amp;&amp; age &lt;= 25)&#123; this.age = age; &#125;else&#123; //当年龄不合法时,产生一个异常 throw new RuntimeException(\"年龄超出了范围\"); &#125; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738public class ExceptionDemo12 &#123; public static void main(String[] args) &#123; // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(\"请输入姓名\"); String name = sc.nextLine(); s.setName(name); while(true)&#123; System.out.println(\"请输入年龄\"); String ageStr = sc.nextLine(); try &#123; int age = Integer.parseInt(ageStr); s.setAge(age); break; &#125; catch (NumberFormatException e) &#123; System.out.println(\"请输入一个整数\"); continue; &#125; catch (AgeOutOfBoundsException e) &#123; System.out.println(e.toString()); System.out.println(\"请输入一个符合范围的年龄\"); continue; &#125; /*if(age &gt;= 18 &amp;&amp; age &lt;=25)&#123; s.setAge(age); break; &#125;else&#123; System.out.println(\"请输入符合要求的年龄\"); continue; &#125;*/ &#125; System.out.println(s); &#125;&#125; 3.10 自定义异常（应用） 自定义异常概述 当Java中提供的异常不能满足我们的需求时,我们可以自定义异常 实现步骤 定义异常类 写继承关系 提供空参构造 提供带参构造 代码实现 异常类 12345678public class AgeOutOfBoundsException extends RuntimeException &#123; public AgeOutOfBoundsException() &#123; &#125; public AgeOutOfBoundsException(String message) &#123; super(message); &#125;&#125; 学生类 1234567891011121314151617181920212223242526272829303132333435363738394041public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age &gt;= 18 &amp;&amp; age &lt;= 25)&#123; this.age = age; &#125;else&#123; //如果Java中提供的异常不能满足我们的需求,我们可以使用自定义的异常 throw new AgeOutOfBoundsException(\"年龄超出了范围\"); &#125; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738public class ExceptionDemo12 &#123; public static void main(String[] args) &#123; // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(\"请输入姓名\"); String name = sc.nextLine(); s.setName(name); while(true)&#123; System.out.println(\"请输入年龄\"); String ageStr = sc.nextLine(); try &#123; int age = Integer.parseInt(ageStr); s.setAge(age); break; &#125; catch (NumberFormatException e) &#123; System.out.println(\"请输入一个整数\"); continue; &#125; catch (AgeOutOfBoundsException e) &#123; System.out.println(e.toString()); System.out.println(\"请输入一个符合范围的年龄\"); continue; &#125; /*if(age &gt;= 18 &amp;&amp; age &lt;=25)&#123; s.setAge(age); break; &#125;else&#123; System.out.println(\"请输入符合要求的年龄\"); continue; &#125;*/ &#125; System.out.println(s); &#125;&#125;","categories":[],"tags":[]},{"title":"15-API01","slug":"15-API01","date":"2020-11-08T12:58:41.000Z","updated":"2020-11-08T12:59:41.572Z","comments":true,"path":"2020/11/08/15-API01/","link":"","permalink":"http://xiaojujing.com/2020/11/08/15-API01/","excerpt":"1.API1.1 API概述【理解】 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API","text":"1.API1.1 API概述【理解】 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API ​ 指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。 1.2 如何使用API帮助文档【应用】 打开帮助文档 找到索引选项卡中的输入框 在输入框中输入Random 看类在哪个包下 看类的描述 看构造方法 看成员方法 2.常用API2.1 Math（应用） 1、Math类概述 Math 包含执行基本数字运算的方法 2、Math中方法的调用方式 Math类中无构造方法，但内部的方法都是静态的，则可以通过 类名.进行调用 3、Math类的常用方法 方法名 方法名 说明 public static int abs(int a) 返回参数的绝对值 public static double ceil(double a) 返回大于或等于参数的最小double值，等于一个整数 public static double floor(double a) 返回小于或等于参数的最大double值，等于一个整数 public static int round(float a) 按照四舍五入返回最接近参数的int public static int max(int a,int b) 返回两个int值中的较大值 public static int min(int a,int b) 返回两个int值中的较小值 public static double pow (double a,double b) 返回a的b次幂的值 public static double random() 返回值为double的正值，[0.0,1.0) 2.2 System（应用） System类的常用方法 方法名 说明 public static void exit(int status) 终止当前运行的 Java 虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前时间(以毫秒为单位) 示例代码 需求：在控制台输出1-10000，计算这段代码执行了多少毫秒 123456789101112public class SystemDemo &#123; public static void main(String[] args) &#123; // 获取开始的时间节点 long start = System.currentTimeMillis(); for (int i = 1; i &lt;= 10000; i++) &#123; System.out.println(i); &#125; // 获取代码运行结束后的时间节点 long end = System.currentTimeMillis(); System.out.println(\"共耗时：\" + (end - start) + \"毫秒\"); &#125;&#125; 2.3 Object类的toString方法（应用） Object类概述 Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份 查看方法源码的方式 选中方法，按下Ctrl + B 重写toString方法的方式 Alt + Insert 选择toString 在类的空白区域，右键 -&gt; Generate -&gt; 选择toString toString方法的作用： 以良好的格式，更方便的展示对象中的属性值 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Student extends Object &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125;public class ObjectDemo &#123; public static void main(String[] args) &#123; Student s = new Student(); s.setName(\"林青霞\"); s.setAge(30); System.out.println(s); System.out.println(s.toString()); &#125;&#125; 运行结果： 12Student&#123;name='林青霞', age=30&#125;Student&#123;name='林青霞', age=30&#125; 2.4 Object类的equals方法（应用） equals方法的作用 用于对象之间的比较，返回true和false的结果 举例：s1.equals(s2); s1和s2是两个对象 重写equals方法的场景 不希望比较对象的地址值，想要结合对象属性进行比较的时候。 重写equals方法的方式 alt + insert 选择equals() and hashCode()，IntelliJ Default，一路next，finish即可 在类的空白区域，右键 -&gt; Generate -&gt; 选择equals() and hashCode()，后面的同上。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; //this -- s1 //o -- s2 if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; //student -- s2 if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125;&#125;public class ObjectDemo &#123; public static void main(String[] args) &#123; Student s1 = new Student(); s1.setName(\"林青霞\"); s1.setAge(30); Student s2 = new Student(); s2.setName(\"林青霞\"); s2.setAge(30); //需求：比较两个对象的内容是否相同 System.out.println(s1.equals(s2)); &#125;&#125; 面试题 123456789101112131415161718// 看程序,分析结果String s = “abc”;StringBuilder sb = new StringBuilder(“abc”);s.equals(sb); sb.equals(s); public class InterviewTest &#123; public static void main(String[] args) &#123; String s1 = \"abc\"; StringBuilder sb = new StringBuilder(\"abc\"); //1.此时调用的是String类中的equals方法. //保证参数也是字符串,否则不会比较属性值而直接返回false //System.out.println(s1.equals(sb)); // false //StringBuilder类中是没有重写equals方法,用的就是Object类中的. System.out.println(sb.equals(s1)); // false &#125;&#125; 2.5 Objects (应用) 常用方法 方法名 说明 public static String toString(对象) 返回参数中对象的字符串表示形式。 public static String toString(对象, 默认字符串) 返回对象的字符串表示形式。 public static Boolean isNull(对象) 判断对象是否为空 public static Boolean nonNull(对象) 判断对象是否不为空 示例代码 学生类 123456789101112131415161718192021222324252627282930313233343536class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; &#125; 测试类 123456789101112131415161718192021222324252627public class MyObjectsDemo &#123; public static void main(String[] args) &#123; // public static String toString(对象): 返回参数中对象的字符串表示形式。 // Student s = new Student(\"小罗同学\",50); // String result = Objects.toString(s); // System.out.println(result); // System.out.println(s); // public static String toString(对象, 默认字符串): 返回对象的字符串表示形式。如果对象为空,那么返回第二个参数. //Student s = new Student(\"小花同学\",23); // Student s = null; // String result = Objects.toString(s, \"随便写一个\"); // System.out.println(result); // public static Boolean isNull(对象): 判断对象是否为空 //Student s = null; // Student s = new Student(); // boolean result = Objects.isNull(s); // System.out.println(result); // public static Boolean nonNull(对象): 判断对象是否不为空 //Student s = new Student(); Student s = null; boolean result = Objects.nonNull(s); System.out.println(result); &#125; &#125; 2.6 BigDecimal (应用) 作用 可以用来进行精确计算 构造方法 方法名 说明 BigDecimal(double val) 参数为double BigDecimal(String val) 参数为String 常用方法 方法名 说明 public BigDecimal add(另一个BigDecimal对象) 加法 public BigDecimal subtract (另一个BigDecimal对象) 减法 public BigDecimal multiply (另一个BigDecimal对象) 乘法 public BigDecimal divide (另一个BigDecimal对象) 除法 public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) 除法 总结 BigDecimal是用来进行精确计算的 创建BigDecimal的对象，构造方法使用参数类型为字符串的。 四则运算中的除法，如果除不尽请使用divide的三个参数的方法。 代码示例： 1234567BigDecimal divide = bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);参数1 ，表示参与运算的BigDecimal 对象。参数2 ，表示小数点后面精确到多少位参数3 ，舍入模式 BigDecimal.ROUND_UP 进一法 BigDecimal.ROUND_FLOOR 去尾法 BigDecimal.ROUND_HALF_UP 四舍五入 3.包装类3.1 基本类型包装类（记忆） 基本类型包装类的作用 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 常用的操作之一：用于基本数据类型与字符串之间的转换 基本类型对应的包装类 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 3.2 Integer类（应用） Integer类概述 包装一个对象中的原始类型 int 的值 Integer类构造方法 方法名 说明 public Integer(int value) 根据 int 值创建 Integer 对象(过时) public Integer(String s) 根据 String 值创建 Integer 对象(过时) public static Integer valueOf(int i) 返回表示指定的 int 值的 Integer 实例 public static Integer valueOf(String s) 返回一个保存指定值的 Integer 对象 String 示例代码 123456789101112131415161718192021public class IntegerDemo &#123; public static void main(String[] args) &#123; //public Integer(int value)：根据 int 值创建 Integer 对象(过时) Integer i1 = new Integer(100); System.out.println(i1); //public Integer(String s)：根据 String 值创建 Integer 对象(过时) Integer i2 = new Integer(\"100\");// Integer i2 = new Integer(\"abc\"); //NumberFormatException System.out.println(i2); System.out.println(\"--------\"); //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例 Integer i3 = Integer.valueOf(100); System.out.println(i3); //public static Integer valueOf(String s)：返回一个保存指定值的Integer对象 String Integer i4 = Integer.valueOf(\"100\"); System.out.println(i4); &#125;&#125; 3.3 自动拆箱和自动装箱（理解） 自动装箱 ​ 把基本数据类型转换为对应的包装类类型 自动拆箱 ​ 把包装类类型转换为对应的基本数据类型 示例代码 12Integer i = 100; // 自动装箱i += 200; // i = i + 200; i + 200 自动拆箱；i = i + 200; 是自动装箱 3.4 int和String类型的相互转换（记忆） int转换为String 转换方式 方式一：直接在数字后加一个空字符串 方式二：通过String类静态方法valueOf() 示例代码 1234567891011121314public class IntegerDemo &#123; public static void main(String[] args) &#123; //int --- String int number = 100; //方式1 String s1 = number + \"\"; System.out.println(s1); //方式2 //public static String valueOf(int i) String s2 = String.valueOf(number); System.out.println(s2); System.out.println(\"--------\"); &#125;&#125; String转换为int 转换方式 方式一：先将字符串数字转成Integer，再调用valueOf()方法 方式二：通过Integer静态方法parseInt()进行转换 示例代码 123456789101112131415public class IntegerDemo &#123; public static void main(String[] args) &#123; //String --- int String s = \"100\"; //方式1：String --- Integer --- int Integer i = Integer.valueOf(s); //public int intValue() int x = i.intValue(); System.out.println(x); //方式2 //public static int parseInt(String s) int y = Integer.parseInt(s); System.out.println(y); &#125;&#125; 3.5 字符串数据排序案例（应用） 案例需求 ​ 有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：27 38 46 50 91 代码实现 123456789101112131415161718192021222324public class IntegerTest &#123; public static void main(String[] args) &#123; //定义一个字符串 String s = \"91 27 46 38 50\"; //把字符串中的数字数据存储到一个int类型的数组中 String[] strArray = s.split(\" \");// for(int i=0; i&lt;strArray.length; i++) &#123;// System.out.println(strArray[i]);// &#125; //定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中 int[] arr = new int[strArray.length]; for(int i=0; i&lt;arr.length; i++) &#123; arr[i] = Integer.parseInt(strArray[i]); &#125; //对 int 数组进行排序 Arrays.sort(arr); for(int i=0; i&lt;arr.length; i++)&#123; System.out.print(arr[i] + \" \"); &#125;&#125; 4.递归4.1 递归【应用】 递归的介绍 以编程的角度来看，递归指的是方法定义中调用方法本身的现象 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算 递归的基本使用 1234567891011121314151617181920public class MyFactorialDemo2 &#123; public static void main(String[] args) &#123; int sum = getSum(100); System.out.println(sum); &#125; private static int getSum(int i) &#123; //1- 100之间的和 //100 + (1-99之间的和) // 99 + (1- 98之间的和) //.... //1 //方法的作用: 求 1- i 之间和 if(i == 1)&#123; return 1; &#125;else&#123; return i + getSum(i -1); &#125; &#125;&#125; 递归的注意事项 递归一定要有出口。否则内存溢出 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出 4.2 递归求阶乘【应用】 案例需求 ​ 用递归求5的阶乘，并把结果在控制台输出 代码实现 1234567891011121314151617181920public class DiGuiDemo01 &#123; public static void main(String[] args) &#123; //调用方法 int result = jc(5); //输出结果 System.out.println(\"5的阶乘是：\" + result); &#125; //定义一个方法，用于递归求阶乘，参数为一个int类型的变量 public static int jc(int n) &#123; //在方法内部判断该变量的值是否是1 if(n == 1) &#123; //是：返回1 return 1; &#125; else &#123; //不是：返回n*(n-1)! return n*jc(n-1); &#125; &#125;&#125; 内存图 5.数组的高级操作5.1 二分查找 (理解) 二分查找概述 查找指定元素在数组中的位置时,以前的方式是通过遍历,逐个获取每个元素,看是否是要查找的元素,这种方式当数组元素较多时,查找的效率很低 二分查找也叫折半查找,每次可以去掉一半的查找范围,从而提高查找的效率 需求 在数组{1,2,3,4,5,6,7,8,9,10}中,查找某个元素的位置 实现步骤 定义两个变量，表示要查找的范围。默认min = 0 ，max = 最大索引 循环查找，但是min &lt;= max 计算出mid的值 判断mid位置的元素是否为要查找的元素，如果是直接返回对应索引 如果要查找的值在mid的左半边，那么min值不变，max = mid -1.继续下次循环查找 如果要查找的值在mid的右半边，那么max值不变，min = mid + 1.继续下次循环查找 当min &gt; max 时，表示要查找的元素在数组中不存在，返回-1. 代码实现 1234567891011121314151617181920212223242526272829303132333435363738public class MyBinarySearchDemo &#123; public static void main(String[] args) &#123; int [] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int number = 11; //1,我现在要干嘛? --- 二分查找 //2.我干这件事情需要什么? --- 数组 元素 //3,我干完了,要不要把结果返回调用者 --- 把索引返回给调用者 int index = binarySearchForIndex(arr,number); System.out.println(index); &#125; private static int binarySearchForIndex(int[] arr, int number) &#123; //1,定义查找的范围 int min = 0; int max = arr.length - 1; //2.循环查找 min &lt;= max while(min &lt;= max)&#123; //3.计算出中间位置 mid int mid = (min + max) &gt;&gt; 1; //mid指向的元素 &gt; number if(arr[mid] &gt; number)&#123; //表示要查找的元素在左边. max = mid -1; &#125;else if(arr[mid] &lt; number)&#123; //mid指向的元素 &lt; number //表示要查找的元素在右边. min = mid + 1; &#125;else&#123; //mid指向的元素 == number return mid; &#125; &#125; //如果min大于了max就表示元素不存在,返回-1. return -1; &#125; &#125; 注意事项 有一个前提条件，数组内的元素一定要按照大小顺序排列，如果没有大小顺序，是不能使用二分查找法的 5.2 冒泡排序 (理解) 冒泡排序概述 一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序 如果有n个数据进行排序，总共需要比较n-1次 每一次比较完毕，下一次的比较就会少一个数据参与 代码实现 123456789101112131415161718192021222324252627282930313233public class MyBubbleSortDemo2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3, 5, 2, 1, 4&#125;; //1 2 3 4 5 bubbleSort(arr); &#125; private static void bubbleSort(int[] arr) &#123; //外层循环控制的是次数 比数组的长度少一次. for (int i = 0; i &lt; arr.length -1; i++) &#123; //内存循环就是实际循环比较的 //-1 是为了让数组不要越界 //-i 每一轮结束之后,我们就会少比一个数字. for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; printArr(arr); &#125; private static void printArr(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125; &#125; 5.3 快速排序 (理解) 快速排序概述 冒泡排序算法中,一次循环结束,就相当于确定了当前的最大值,也能确定最大值在数组中应存入的位置 快速排序算法中,每一次递归时以第一个数为基准数,找到数组中所有比基准数小的.再找到所有比基准数大的.小的全部放左边,大的全部放右边,确定基准数的正确位置 核心步骤 从右开始找比基准数小的 从左开始找比基准数大的 交换两个值的位置 红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止 基准数归位 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MyQuiteSortDemo2 &#123; public static void main(String[] args) &#123;// 1，从右开始找比基准数小的// 2，从左开始找比基准数大的// 3，交换两个值的位置// 4，红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止// 5，基准数归位 int[] arr = &#123;6, 1, 2, 7, 9, 3, 4, 5, 10, 8&#125;; quiteSort(arr,0,arr.length-1); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; &#125; private static void quiteSort(int[] arr, int left, int right) &#123; // 递归结束的条件 if(right &lt; left)&#123; return; &#125; int left0 = left; int right0 = right; //计算出基准数 int baseNumber = arr[left0]; while(left != right)&#123;// 1，从右开始找比基准数小的 while(arr[right] &gt;= baseNumber &amp;&amp; right &gt; left)&#123; right--; &#125;// 2，从左开始找比基准数大的 while(arr[left] &lt;= baseNumber &amp;&amp; right &gt; left)&#123; left++; &#125;// 3，交换两个值的位置 int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; &#125; //基准数归位 int temp = arr[left]; arr[left] = arr[left0]; arr[left0] = temp; // 递归调用自己,将左半部分排好序 quiteSort(arr,left0,left-1); // 递归调用自己,将右半部分排好序 quiteSort(arr,left +1,right0); &#125;&#125; 5.4 Arrays (应用) Arrays的常用方法 方法名 说明 public static String toString(int[] a) 返回指定数组的内容的字符串表示形式 public static void sort(int[] a) 按照数字顺序排列指定的数组 public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引 示例代码 123456789101112131415161718192021public class MyArraysDemo &#123; public static void main(String[] args) &#123; // public static String toString(int[] a) 返回指定数组的内容的字符串表示形式 // int [] arr = &#123;3,2,4,6,7&#125;; // System.out.println(Arrays.toString(arr)); // public static void sort(int[] a) 按照数字顺序排列指定的数组 // int [] arr = &#123;3,2,4,6,7&#125;; // Arrays.sort(arr); // System.out.println(Arrays.toString(arr)); // public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引 int [] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int index = Arrays.binarySearch(arr, 0); System.out.println(index); //1,数组必须有序 //2.如果要查找的元素存在,那么返回的是这个元素实际的索引 //3.如果要查找的元素不存在,那么返回的是 (-插入点-1) //插入点:如果这个元素在数组中,他应该在哪个索引上. &#125; &#125; 工具类设计思想 构造方法用 private 修饰 成员用 public static 修饰","categories":[],"tags":[]},{"title":"14_匿名内部类和Lambda表达式","slug":"14_匿名内部类和Lambda表达式","date":"2020-11-07T15:16:20.000Z","updated":"2020-11-07T15:17:16.330Z","comments":true,"path":"2020/11/07/14_匿名内部类和Lambda表达式/","link":"","permalink":"http://xiaojujing.com/2020/11/07/14_%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"1.内部类1.1 内部类的基本使用（理解） 内部类概念 在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类 内部类定义格式 格式&amp;举例：","text":"1.内部类1.1 内部类的基本使用（理解） 内部类概念 在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类 内部类定义格式 格式&amp;举例： 1234567891011121314/* 格式： class 外部类名&#123; 修饰符 class 内部类名&#123; &#125; &#125;*/class Outer &#123; public class Inner &#123; &#125;&#125; 内部类的访问特点 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 示例代码： 1234567891011121314151617/* 内部类访问特点： 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 */public class Outer &#123; private int num = 10; public class Inner &#123; public void show() &#123; System.out.println(num); &#125; &#125; public void method() &#123; Inner i = new Inner(); i.show(); &#125;&#125; 1.2 成员内部类（理解） 成员内部类的定义位置 在类中方法，跟成员变量是一个位置 外界创建成员内部类格式 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象; 举例：Outer.Inner oi = new Outer().new Inner(); 私有成员内部类 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。 示例代码： 1234567891011121314151617181920class Outer &#123; private int num = 10; private class Inner &#123; public void show() &#123; System.out.println(num); &#125; &#125; public void method() &#123; Inner i = new Inner(); i.show(); &#125;&#125;public class InnerDemo &#123; public static void main(String[] args) &#123; //Outer.Inner oi = new Outer().new Inner(); //oi.show(); Outer o = new Outer(); o.method(); &#125;&#125; 静态成员内部类 静态成员内部类访问格式：外部类名.内部类名 对象名 = new 外部类名.内部类名(); 静态成员内部类中的静态方法：外部类名.内部类名.方法名(); 示例代码 123456789101112131415161718192021222324class Outer &#123; static class Inner &#123; public void show()&#123; System.out.println(\"inner..show\"); &#125; public static void method()&#123; System.out.println(\"inner..method\"); &#125; &#125;&#125;public class Test3Innerclass &#123; /* 静态成员内部类演示 */ public static void main(String[] args) &#123; // 外部类名.内部类名 对象名 = new 外部类名.内部类名(); Outer.Inner oi = new Outer.Inner(); oi.show(); Outer.Inner.method(); &#125;&#125; 1.3 局部内部类（理解） 局部内部类定义位置 局部内部类是在方法中定义的类 局部内部类方式方式 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用 该类可以直接访问外部类的成员，也可以访问方法内的局部变量 示例代码 1234567891011121314151617181920class Outer &#123; private int num = 10; public void method() &#123; int num2 = 20; class Inner &#123; public void show() &#123; System.out.println(num); System.out.println(num2); &#125; &#125; Inner i = new Inner(); i.show(); &#125;&#125;public class OuterDemo &#123; public static void main(String[] args) &#123; Outer o = new Outer(); o.method(); &#125;&#125; 1.4 匿名内部类（应用） 匿名内部类的前提 存在一个类或者接口，这里的类可以是具体类也可以是抽象类 匿名内部类的格式 格式：new 类名 ( ) { 重写方法 } new 接口名 ( ) { 重写方法 } 举例： 1234new Inter()&#123; @Override public void method()&#123;&#125;&#125; 匿名内部类的本质 本质：是一个继承了该类或者实现了该接口的子类匿名对象 匿名内部类的细节 匿名内部类可以通过多态的形式接受 123456Inter i = new Inter()&#123; @Override public void method()&#123; &#125;&#125; 匿名内部类直接调用方法 1234567891011121314interface Inter&#123; void method();&#125;class Test&#123; public static void main(String[] args)&#123; new Inter()&#123; @Override public void method()&#123; System.out.println(\"我是匿名内部类\"); &#125; &#125;.method(); // 直接调用方法 &#125;&#125; 1.5 匿名内部类在开发中的使用（应用） 匿名内部类在开发中的使用 当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码 示例代码： 1234567891011121314151617181920212223242526272829303132/* 游泳接口 */interface Swimming &#123; void swim();&#125;public class TestSwimming &#123; public static void main(String[] args) &#123; goSwimming(new Swimming() &#123; @Override public void swim() &#123; System.out.println(\"铁汁, 我们去游泳吧\"); &#125; &#125;); &#125; /** * 使用接口的方法 */ public static void goSwimming(Swimming swimming)&#123; /* Swimming swim = new Swimming() &#123; @Override public void swim() &#123; System.out.println(\"铁汁, 我们去游泳吧\"); &#125; &#125; */ swimming.swim(); &#125;&#125; 2.Lambda表达式2.1体验Lambda表达式【理解】 代码演示 123456789101112131415161718192021222324252627282930/* 游泳接口 */interface Swimming &#123; void swim();&#125;public class TestSwimming &#123; public static void main(String[] args) &#123; // 通过匿名内部类实现 goSwimming(new Swimming() &#123; @Override public void swim() &#123; System.out.println(\"铁汁, 我们去游泳吧\"); &#125; &#125;); /* 通过Lambda表达式实现 理解: 对于Lambda表达式, 对匿名内部类进行了优化 */ goSwimming(() -&gt; System.out.println(\"铁汁, 我们去游泳吧\")); &#125; /** * 使用接口的方法 */ public static void goSwimming(Swimming swimming) &#123; swimming.swim(); &#125;&#125; 函数式编程思想概述 在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿数据做操作” 面向对象思想强调“必须通过对象的形式来做事情” 函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做” 而我们要学习的Lambda表达式就是函数式思想的体现 2.2Lambda表达式的标准格式【理解】 格式： ​ (形式参数) -&gt; {代码块} 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可 -&gt;：由英文中画线和大于符号组成，固定写法。代表指向动作 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容 组成Lambda表达式的三要素： 形式参数，箭头，代码块 2.3Lambda表达式练习1【应用】 Lambda表达式的使用前提 有一个接口 接口中有且仅有一个抽象方法 练习描述 ​ 无参无返回值抽象方法的练习 操作步骤 定义一个接口(Eatable)，里面定义一个抽象方法：void eat(); 定义一个测试类(EatableDemo)，在测试类中提供两个方法 一个方法是：useEatable(Eatable e) 一个方法是主方法，在主方法中调用useEatable方法 示例代码 123456789101112131415161718192021222324252627282930313233343536//接口public interface Eatable &#123; void eat();&#125;//实现类public class EatableImpl implements Eatable &#123; @Override public void eat() &#123; System.out.println(\"一天一苹果，医生远离我\"); &#125;&#125;//测试类public class EatableDemo &#123; public static void main(String[] args) &#123; //在主方法中调用useEatable方法 Eatable e = new EatableImpl(); useEatable(e); //匿名内部类 useEatable(new Eatable() &#123; @Override public void eat() &#123; System.out.println(\"一天一苹果，医生远离我\"); &#125; &#125;); //Lambda表达式 useEatable(() -&gt; &#123; System.out.println(\"一天一苹果，医生远离我\"); &#125;); &#125; private static void useEatable(Eatable e) &#123; e.eat(); &#125;&#125; 2.4Lambda表达式练习2【应用】 练习描述 有参无返回值抽象方法的练习 操作步骤 定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s); 定义一个测试类(FlyableDemo)，在测试类中提供两个方法 一个方法是：useFlyable(Flyable f) 一个方法是主方法，在主方法中调用useFlyable方法 示例代码 1234567891011121314151617181920212223242526272829public interface Flyable &#123; void fly(String s);&#125;public class FlyableDemo &#123; public static void main(String[] args) &#123; //在主方法中调用useFlyable方法 //匿名内部类 useFlyable(new Flyable() &#123; @Override public void fly(String s) &#123; System.out.println(s); System.out.println(\"飞机自驾游\"); &#125; &#125;); System.out.println(\"--------\"); //Lambda useFlyable((String s) -&gt; &#123; System.out.println(s); System.out.println(\"飞机自驾游\"); &#125;); &#125; private static void useFlyable(Flyable f) &#123; f.fly(\"风和日丽，晴空万里\"); &#125;&#125; 2.5Lambda表达式练习3【应用】 练习描述 有参有返回值抽象方法的练习 操作步骤 定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y); 定义一个测试类(AddableDemo)，在测试类中提供两个方法 一个方法是：useAddable(Addable a) 一个方法是主方法，在主方法中调用useAddable方法 示例代码 123456789101112131415161718public interface Addable &#123; int add(int x,int y);&#125;public class AddableDemo &#123; public static void main(String[] args) &#123; //在主方法中调用useAddable方法 useAddable((int x,int y) -&gt; &#123; return x + y; &#125;); &#125; private static void useAddable(Addable a) &#123; int sum = a.add(10, 20); System.out.println(sum); &#125;&#125; 2.6Lambda表达式的省略模式【应用】 省略的规则 参数类型可以省略。但是有多个参数的情况下，不能只省略一个 如果参数有且仅有一个，那么小括号可以省略 如果代码块的语句只有一条，可以省略大括号和分号，和return关键字 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142public interface Addable &#123; int add(int x, int y);&#125;public interface Flyable &#123; void fly(String s);&#125;public class LambdaDemo &#123; public static void main(String[] args) &#123;// useAddable((int x,int y) -&gt; &#123;// return x + y;// &#125;); //参数的类型可以省略 useAddable((x, y) -&gt; &#123; return x + y; &#125;);// useFlyable((String s) -&gt; &#123;// System.out.println(s);// &#125;); //如果参数有且仅有一个，那么小括号可以省略// useFlyable(s -&gt; &#123;// System.out.println(s);// &#125;); //如果代码块的语句只有一条，可以省略大括号和分号 useFlyable(s -&gt; System.out.println(s)); //如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉 useAddable((x, y) -&gt; x + y); &#125; private static void useFlyable(Flyable f) &#123; f.fly(\"风和日丽，晴空万里\"); &#125; private static void useAddable(Addable a) &#123; int sum = a.add(10, 20); System.out.println(sum); &#125;&#125; 2.7Lambda表达式的使用前提【理解】 使用Lambda必须要有接口 并且要求接口中有且仅有一个抽象方法 2.8Lambda表达式和匿名内部类的区别【理解】 所需类型不同 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类 Lambda表达式：只能是接口 使用限制不同 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式 实现原理不同 匿名内部类：编译之后，产生一个单独的.class字节码文件 Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成","categories":[],"tags":[]},{"title":"13_接口和多态","slug":"13_接口和多态","date":"2020-11-07T15:14:58.000Z","updated":"2020-11-07T15:17:23.142Z","comments":true,"path":"2020/11/07/13_接口和多态/","link":"","permalink":"http://xiaojujing.com/2020/11/07/13_%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81/","excerpt":"1.接口1.1黑马信息管理系统集合改进 (应用) 使用数组容器的弊端 容器长度是固定的，不能根据添加功能自动增长 没有提供用于赠删改查的方法","text":"1.接口1.1黑马信息管理系统集合改进 (应用) 使用数组容器的弊端 容器长度是固定的，不能根据添加功能自动增长 没有提供用于赠删改查的方法 优化步骤 创建新的StudentDao类，OtherStudentDao 创建ArrayList集合容器对象 OtherStudentDao中的方法声明，需要跟StudentDao保持一致 注意：如果不一致，StudentService中的代码就需要进行修改 完善方法（添加、删除、修改、查看） 替换StudentService中的Dao对象 代码实现 OtherStudentDao类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class OtherStudentDao &#123; // 集合容器 private static ArrayList&lt;Student&gt; stus = new ArrayList&lt;&gt;(); static &#123; Student stu1 = new Student(\"heima001\",\"张三\",\"23\",\"1999-11-11\"); Student stu2 = new Student(\"heima002\",\"李四\",\"24\",\"2000-11-11\"); stus.add(stu1); stus.add(stu2); &#125; // 添加学生方法 public boolean addStudent(Student stu) &#123; stus.add(stu); return true; &#125; // 查看学生方法 public Student[] findAllStudent() &#123; Student[] students = new Student[stus.size()]; for (int i = 0; i &lt; students.length; i++) &#123; students[i] = stus.get(i); &#125; return students; &#125; public void deleteStudentById(String delId) &#123; // 1. 查找id在容器中所在的索引位置 int index = getIndex(delId); stus.remove(index); &#125; public int getIndex(String id)&#123; int index = -1; for (int i = 0; i &lt; stus.size(); i++) &#123; Student stu = stus.get(i); if(stu != null &amp;&amp; stu.getId().equals(id))&#123; index = i; break; &#125; &#125; return index; &#125; public void updateStudent(String updateId, Student newStu) &#123; // 1. 查找updateId, 在容器中的索引位置 int index = getIndex(updateId); stus.set(index, newStu); &#125;&#125; StudentService类 12345public class StudentService &#123; // 创建StudentDao (库管) private OtherStudentDao studentDao = new OtherStudentDao(); // 其他方法没有变化,此处省略...&#125; 1.2黑马信息管理系统抽取Dao (应用) 优化步骤 将方法向上抽取，抽取出一个父类 （ BaseStudentDao ） 方法的功能实现在父类中无法给出具体明确，定义为抽象方法 让两个类分别继承 BaseStudentDao ，重写内部抽象方法 代码实现 BaseStudentDao类 123456789101112public abstract class BaseStudentDao &#123; // 添加学生方法 public abstract boolean addStudent(Student stu); // 查看学生方法 public abstract Student[] findAllStudent(); // 删除学生方法 public abstract void deleteStudentById(String delId); // 根据id找索引方法 public abstract int getIndex(String id); // 修改学生方法 public abstract void updateStudent(String updateId, Student newStu);&#125; StudentDao类 123public class StudentDao extends BaseStudentDao &#123; // 其他内容不变,此处省略&#125; OtherStudentDao类 123public class OtherStudentDao extends BaseStudentDao &#123; // 其他内容不变,此处省略&#125; 1.3接口的概述（理解） 接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。 Java中接口存在的两个意义 用来定义规范 用来做功能的拓展 1.4接口的特点（记忆） 接口用关键字interface修饰 1public interface 接口名 &#123;&#125; 类实现接口用implements表示 1public class 类名 implements 接口名 &#123;&#125; 接口不能实例化 ​ 我们可以创建接口的实现类对象使用 接口的子类 ​ 要么重写接口中的所有抽象方法 ​ 要么子类也是抽象类 1.5接口的成员特点（记忆） 成员特点 成员变量 ​ 只能是常量​ 默认修饰符：public static final 构造方法 ​ 没有，因为接口主要是扩展功能的，而没有具体存在 成员方法 ​ 只能是抽象方法 ​ 默认修饰符：public abstract ​ 关于接口中的方法，JDK8和JDK9中有一些新特性，后面再讲解 代码演示 接口 12345public interface Inter &#123; public static final int NUM = 10; public abstract void show();&#125; 实现类 1234567891011class InterImpl implements Inter&#123; public void method()&#123; // NUM = 20; System.out.println(NUM); &#125; public void show()&#123; &#125;&#125; 测试类 12345678910111213public class TestInterface &#123; /* 成员变量: 只能是常量 系统会默认加入三个关键字 public static final 构造方法: 没有 成员方法: 只能是抽象方法, 系统会默认加入两个关键字 public abstract */ public static void main(String[] args) &#123; System.out.println(Inter.NUM); &#125; &#125; 1.6类和接口的关系（记忆） 类与类的关系 ​ 继承关系，只能单继承，但是可以多层继承 类与接口的关系 ​ 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口 接口与接口的关系 ​ 继承关系，可以单继承，也可以多继承 1.7黑马信息管理系统使用接口改进 (应用) 实现步骤 将 BaseStudentDao 改进为一个接口 让 StudentDao 和 OtherStudentDao 去实现这个接口 代码实现 BaseStudentDao接口 123456789101112public interface BaseStudentDao &#123; // 添加学生方法 public abstract boolean addStudent(Student stu); // 查看学生方法 public abstract Student[] findAllStudent(); // 删除学生方法 public abstract void deleteStudentById(String delId); // 根据id找索引方法 public abstract int getIndex(String id); // 修改学生方法 public abstract void updateStudent(String updateId, Student newStu);&#125; StudentDao类 123public class StudentDao implements BaseStudentDao &#123; // 其他内容不变,此处省略&#125; OtherStudentDao类 123public class OtherStudentDao implements BaseStudentDao &#123; // 其他内容不变,此处省略&#125; 1.8黑马信息管理系统解耦合改进 (应用) 实现步骤 创建factory包，创建 StudentDaoFactory（工厂类） 提供 static 修改的 getStudentDao 方法，该方法用于创建StudentDao对象并返回 代码实现 StudentDaoFactory类 12345public class StudentDaoFactory &#123; public static OtherStudentDao getStudentDao()&#123; return new OtherStudentDao(); &#125;&#125; StudentService类 1234567public class StudentService &#123; // 创建StudentDao (库管) // private OtherStudentDao studentDao = new OtherStudentDao(); // 通过学生库管工厂类, 获取库管对象 private OtherStudentDao studentDao = StudentDaoFactory.getStudentDao();&#125; 2.接口组成更新2.1接口组成更新概述【理解】 常量 public static final 抽象方法 public abstract 默认方法(Java 8) 静态方法(Java 8) 私有方法(Java 9) 2.2接口中默认方法【应用】 格式 public default 返回值类型 方法名(参数列表) { } 作用 解决接口升级的问题 范例 12public default void show3() &#123; &#125; 注意事项 默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字 public可以省略，default不能省略 如果实现了多个接口，多个接口中存在相同的方法声明，子类就必须对该方法进行重写 2.3接口中静态方法【应用】 格式 public static 返回值类型 方法名(参数列表) { } 范例 12public static void show() &#123;&#125; 注意事项 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略 2.4接口中私有方法【应用】 私有方法产生原因 Java 9中新增了带方法体的私有方法，这其实在Java 8中就埋下了伏笔：Java 8允许在接口中定义带方法体的默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java 9增加私有方法的必然性 定义格式 格式1 private 返回值类型 方法名(参数列表) { } 范例1 12private void show() &#123; &#125; 格式2 private static 返回值类型 方法名(参数列表) { } 范例2 12private static void method() &#123; &#125; 注意事项 默认方法可以调用私有的静态方法和非静态方法 静态方法只能调用私有的静态方法 3.多态3.1多态的概述（记忆） 什么是多态 ​ 同一个对象，在不同时刻表现出来的不同形态 多态的前提 要有继承或实现关系 要有方法的重写 要有父类引用指向子类对象 代码演示 123456789101112131415161718192021222324252627282930class Animal &#123; public void eat()&#123; System.out.println(\"动物吃饭\"); &#125;&#125;class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125;public class Test1Polymorphic &#123; /* 多态的前提: 1. 要有(继承 \\ 实现)关系 2. 要有方法重写 3. 要有父类引用, 指向子类对象 */ public static void main(String[] args) &#123; // 当前事物, 是一只猫 Cat c = new Cat(); // 当前事物, 是一只动物 Animal a = new Cat(); a.eat(); &#125;&#125; 3.2多态中的成员访问特点（记忆） 成员访问特点 成员变量 ​ 编译看父类，运行看父类 成员方法 ​ 编译看父类，运行看子类 代码演示 123456789101112131415161718192021222324252627282930class Fu &#123; int num = 10; public void method()&#123; System.out.println(\"Fu.. method\"); &#125;&#125;class Zi extends Fu &#123; int num = 20; public void method()&#123; System.out.println(\"Zi.. method\"); &#125;&#125;public class Test2Polymorpic &#123; /* 多态的成员访问特点: 成员变量: 编译看左边 (父类), 运行看左边 (父类) 成员方法: 编译看左边 (父类), 运行看右边 (子类) */ public static void main(String[] args) &#123; Fu f = new Zi(); System.out.println(f.num); f.method(); &#125;&#125; 3.3多态的好处和弊端（记忆） 好处 ​ 提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作 弊端 ​ 不能使用子类的特有成员 3.4多态中的转型（应用） 向上转型 ​ 父类引用指向子类对象就是向上转型 向下转型 ​ 格式：子类型 对象名 = (子类型)父类引用; 代码演示 123456789101112131415161718192021222324252627282930313233class Fu &#123; public void show()&#123; System.out.println(\"Fu..show...\"); &#125;&#125;class Zi extends Fu &#123; @Override public void show() &#123; System.out.println(\"Zi..show...\"); &#125; public void method()&#123; System.out.println(\"我是子类特有的方法, method\"); &#125;&#125;public class Test3Polymorpic &#123; public static void main(String[] args) &#123; // 1. 向上转型 : 父类引用指向子类对象 Fu f = new Zi(); f.show(); // 多态的弊端: 不能调用子类特有的成员 // f.method(); // A: 直接创建子类对象 // B: 向下转型 // 2. 向下转型 : 从父类类型, 转换回子类类型 Zi z = (Zi) f; z.method(); &#125;&#125; 3.5多态中转型存在的风险和解决方案 (应用) 风险 如果被转的引用类型变量,对应的实际类型和目标类型不是同一种类型,那么在转换的时候就会出现ClassCastException 解决方案 关键字 instanceof 使用格式 变量名 instanceof 类型 通俗的理解：判断关键字左边的变量，是否是右边的类型，返回boolean类型结果 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142abstract class Animal &#123; public abstract void eat();&#125;class Dog extends Animal &#123; public void eat() &#123; System.out.println(\"狗吃肉\"); &#125; public void watchHome()&#123; System.out.println(\"看家\"); &#125;&#125;class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125;public class Test4Polymorpic &#123; public static void main(String[] args) &#123; useAnimal(new Dog()); useAnimal(new Cat()); &#125; public static void useAnimal(Animal a)&#123; // Animal a = new Dog(); // Animal a = new Cat(); a.eat(); //a.watchHome();// Dog dog = (Dog) a;// dog.watchHome(); // ClassCastException 类型转换异常 // 判断a变量记录的类型, 是否是Dog if(a instanceof Dog)&#123; Dog dog = (Dog) a; dog.watchHome(); &#125; &#125;&#125; 3.6黑马信息管理系统多态改进 (应用) 实现步骤 StudentDaoFactory类中方法的返回值定义成父类类型BaseStudentDao StudentService中接收方法返回值的类型定义成父类类型BaseStudentDao 代码实现 StudentDaoFactory类 12345public class StudentDaoFactory &#123; public static BaseStudentDao getStudentDao()&#123; return new OtherStudentDao(); &#125;&#125; StudentService类 1234567public class StudentService &#123; // 创建StudentDao (库管) // private OtherStudentDao studentDao = new OtherStudentDao(); // 通过学生库管工厂类, 获取库管对象 private BaseStudentDao studentDao = StudentDaoFactory.getStudentDao();&#125;","categories":[],"tags":[]},{"title":"12_继承","slug":"12_继承","date":"2020-11-06T15:46:27.000Z","updated":"2020-11-06T16:15:58.292Z","comments":true,"path":"2020/11/06/12_继承/","link":"","permalink":"http://xiaojujing.com/2020/11/06/12_%E7%BB%A7%E6%89%BF/","excerpt":"1. 继承1.1 继承的实现（掌握） 继承的概念 继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法","text":"1. 继承1.1 继承的实现（掌握） 继承的概念 继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法 实现继承的格式 继承通过extends实现 格式：class 子类 extends 父类 { } 举例：class Dog extends Animal { } 继承带来的好处 继承可以让类与类之间产生关系，子父类关系，产生子父类后，子类则可以使用父类中非私有的成员。 示例代码 123456789101112131415161718192021public class Fu &#123; public void show() &#123; System.out.println(\"show方法被调用\"); &#125;&#125;public class Zi extends Fu &#123; public void method() &#123; System.out.println(\"method方法被调用\"); &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; //创建对象，调用方法 Fu f = new Fu(); f.show(); Zi z = new Zi(); z.method(); z.show(); &#125;&#125; 1.2 继承的好处和弊端（理解） 继承好处 提高了代码的复用性(多个类相同的成员可以放到同一个类中) 提高了代码的维护性(如果方法的代码需要修改，修改一处即可) 继承弊端 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性 继承的应用场景： 使用继承，需要考虑类与类之间是否存在is..a的关系，不能盲目使用继承 is..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类 1.3. Java中继承的特点（掌握） Java中继承的特点 Java中类只支持单继承，不支持多继承 错误范例：class A extends B, C { } Java中类支持多层继承 多层继承示例代码： 1234567891011121314151617181920212223242526public class Granddad &#123; public void drink() &#123; System.out.println(\"爷爷爱喝酒\"); &#125;&#125;public class Father extends Granddad &#123; public void smoke() &#123; System.out.println(\"爸爸爱抽烟\"); &#125;&#125;public class Mother &#123; public void dance() &#123; System.out.println(\"妈妈爱跳舞\"); &#125;&#125;public class Son extends Father &#123; // 此时，Son类中就同时拥有drink方法以及smoke方法&#125; 2. 继承中的成员访问特点2.1 继承中变量的访问特点（掌握）在子类方法中访问一个变量，采用的是就近原则。 子类局部范围找 子类成员范围找 父类成员范围找 如果都没有就报错(不考虑父亲的父亲…) 示例代码 12345678910111213141516class Fu &#123; int num = 10;&#125;class Zi &#123; int num = 20; public void show()&#123; int num = 30; System.out.println(num); &#125;&#125;public class Demo1 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); // 输出show方法中的局部变量30 &#125;&#125; 2.2 super（掌握） this&amp;super关键字： this：代表本类对象的引用 super：代表父类存储空间的标识(可以理解为父类对象引用) this和super的使用分别 成员变量： this.成员变量 - 访问本类成员变量 super.成员变量 - 访问父类成员变量 成员方法： this.成员方法 - 访问本类成员方法 super.成员方法 - 访问父类成员方法 构造方法： this(…) - 访问本类构造方法 super(…) - 访问父类构造方法 2.3 继承中构造方法的访问特点（理解）注意：子类中所有的构造方法默认都会访问父类中无参的构造方法 ​ 子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：super() 问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？ 12341. 通过使用super关键字去显示的调用父类的带参构造方法2. 子类通过this去调用本类的其他构造方法,本类其他构造方法再通过super去手动调用父类的带参的构造方法注意: this(…)super(…) 必须放在构造方法的第一行有效语句，并且二者不能共存 2.4 继承中成员方法的访问特点（掌握）通过子类对象访问一个方法 子类成员范围找 父类成员范围找 如果都没有就报错(不考虑父亲的父亲…) 2.5 super内存图（理解） 对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 &lt;% asset_img 01_super内存图.png 01_super内存图.png %&gt; 2.6 方法重写（掌握） 1、方法重写概念 子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样） 2、方法重写的应用场景 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容 3、Override注解 用来检测当前的方法，是否是重写的方法，起到【校验】的作用 2.7 方法重写的注意事项（掌握） 方法重写的注意事项 私有方法不能被重写(父类私有成员子类是不能继承的) 子类方法访问权限不能更低(public &gt; 默认 &gt; 私有) 静态方法不能被重写,如果子类也有相同的方法,并不是重写的父类的方法 示例代码 123456789101112131415161718192021222324252627282930public class Fu &#123; private void show() &#123; System.out.println(\"Fu中show()方法被调用\"); &#125; void method() &#123; System.out.println(\"Fu中method()方法被调用\"); &#125;&#125;public class Zi extends Fu &#123; /* 编译【出错】，子类不能重写父类私有的方法*/ @Override private void show() &#123; System.out.println(\"Zi中show()方法被调用\"); &#125; /* 编译【出错】，子类重写父类方法的时候，访问权限需要大于等于父类 */ @Override private void method() &#123; System.out.println(\"Zi中method()方法被调用\"); &#125; /* 编译【通过】，子类重写父类方法的时候，访问权限需要大于等于父类 */ @Override public void method() &#123; System.out.println(\"Zi中method()方法被调用\"); &#125;&#125; 2.8 权限修饰符 (理解)&lt;% asset_img 02_权限修饰符.png 02_权限修饰符.png %&gt; 2.9 黑马信息管理系统使用继承改进 (掌握) 需求 把学生类和老师类共性的内容向上抽取,抽取到出一个 Person 父类,让学生类和老师类继承 Person 类 实现步骤 抽取Person类 优化StudentController类中，inputStudentInfo方法，将setXxx赋值方式，改进为构造方法初始化 注意：直接修改这种操作方式，不符合我们开发中的一个原则 ​ 开闭原则 ( 对扩展开放对修改关闭 ) : 尽量在不更改原有代码的前提下以完成需求 解决：重新创建一个OtherStudentController类 编写新的inputStudentInfo方法 根据StudentController类、OtherStudentController类，向上抽取出BaseStudentController类再让StudentController类、OtherStudentController类，继承BaseStudentController类 代码实现 Person类及学生类和老师类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Person &#123; private String id; private String name; private String age; private String birthday; public Person() &#123; &#125; public Person(String id, String name, String age, String birthday) &#123; this.id = id; this.name = name; this.age = age; this.birthday = birthday; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125;&#125;// Student类public class Student extends Person &#123; public Student() &#123; &#125; public Student(String id, String name, String age, String birthday) &#123; super(id, name, age, birthday); &#125;&#125;// Teacher类public class Teacher extends Person &#123; public Teacher() &#123; &#125; public Teacher(String id, String name, String age, String birthday) &#123; super(id, name, age, birthday); &#125;&#125; BaseStudentController类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public abstract class BaseStudentController &#123; // 业务员对象 private StudentService studentService = new StudentService(); private Scanner sc = new Scanner(System.in); // 开启学生管理系统, 并展示学生管理系统菜单 public void start() &#123; //Scanner sc = new Scanner(System.in); studentLoop: while (true) &#123; System.out.println(\"--------欢迎来到 &lt;学生&gt; 管理系统--------\"); System.out.println(\"请输入您的选择: 1.添加学生 2.删除学生 3.修改学生 4.查看学生 5.退出\"); String choice = sc.next(); switch (choice) &#123; case \"1\": // System.out.println(\"添加\"); addStudent(); break; case \"2\": // System.out.println(\"删除\"); deleteStudentById(); break; case \"3\": // System.out.println(\"修改\"); updateStudent(); break; case \"4\": // System.out.println(\"查询\"); findAllStudent(); break; case \"5\": System.out.println(\"感谢您使用学生管理系统, 再见!\"); break studentLoop; default: System.out.println(\"您的输入有误, 请重新输入\"); break; &#125; &#125; &#125; // 修改学生方法 public void updateStudent() &#123; String updateId = inputStudentId(); Student newStu = inputStudentInfo(updateId); studentService.updateStudent(updateId, newStu); System.out.println(\"修改成功!\"); &#125; // 删除学生方法 public void deleteStudentById() &#123; String delId = inputStudentId(); // 3. 调用业务员中的deleteStudentById根据id, 删除学生 studentService.deleteStudentById(delId); // 4. 提示删除成功 System.out.println(\"删除成功!\"); &#125; // 查看学生方法 public void findAllStudent() &#123; // 1. 调用业务员中的获取方法, 得到学生的对象数组 Student[] stus = studentService.findAllStudent(); // 2. 判断数组的内存地址, 是否为null if (stus == null) &#123; System.out.println(\"查无信息, 请添加后重试\"); return; &#125; // 3. 遍历数组, 获取学生信息并打印在控制台 System.out.println(\"学号\\t\\t姓名\\t年龄\\t生日\"); for (int i = 0; i &lt; stus.length; i++) &#123; Student stu = stus[i]; if (stu != null) &#123; System.out.println(stu.getId() + \"\\t\" + stu.getName() + \"\\t\" + stu.getAge() + \"\\t\\t\" + stu.getBirthday()); &#125; &#125; &#125; // 添加学生方法 public void addStudent() &#123; // StudentService studentService = new StudentService(); // 1. 键盘接收学生信息 String id; while (true) &#123; System.out.println(\"请输入学生id:\"); id = sc.next(); boolean flag = studentService.isExists(id); if (flag) &#123; System.out.println(\"学号已被占用, 请重新输入\"); &#125; else &#123; break; &#125; &#125; Student stu = inputStudentInfo(id); // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法 boolean result = studentService.addStudent(stu); // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败 if (result) &#123; System.out.println(\"添加成功\"); &#125; else &#123; System.out.println(\"添加失败\"); &#125; &#125; // 键盘录入学生id public String inputStudentId() &#123; String id; while (true) &#123; System.out.println(\"请输入学生id:\"); id = sc.next(); boolean exists = studentService.isExists(id); if (!exists) &#123; System.out.println(\"您输入的id不存在, 请重新输入:\"); &#125; else &#123; break; &#125; &#125; return id; &#125; // 键盘录入学生信息 // 开闭原则: 对扩展内容开放, 对修改内容关闭 public Student inputStudentInfo(String id)&#123; return null; &#125;&#125; StudentController类 12345678910111213141516171819202122public class StudentController extends BaseStudentController &#123; private Scanner sc = new Scanner(System.in); // 键盘录入学生信息 // 开闭原则: 对扩展内容开放, 对修改内容关闭 @Override public Student inputStudentInfo(String id) &#123; System.out.println(\"请输入学生姓名:\"); String name = sc.next(); System.out.println(\"请输入学生年龄:\"); String age = sc.next(); System.out.println(\"请输入学生生日:\"); String birthday = sc.next(); Student stu = new Student(); stu.setId(id); stu.setName(name); stu.setAge(age); stu.setBirthday(birthday); return stu; &#125;&#125; OtherStudentController类 123456789101112131415161718public class OtherStudentController extends BaseStudentController &#123; private Scanner sc = new Scanner(System.in); // 键盘录入学生信息 // 开闭原则: 对扩展内容开放, 对修改内容关闭 @Override public Student inputStudentInfo(String id) &#123; System.out.println(\"请输入学生姓名:\"); String name = sc.next(); System.out.println(\"请输入学生年龄:\"); String age = sc.next(); System.out.println(\"请输入学生生日:\"); String birthday = sc.next(); Student stu = new Student(id,name,age,birthday); return stu; &#125;&#125; 3.抽象类3.1抽象类的概述（理解）​ 当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！ ​ 在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！ 3.2抽象类的特点（记忆） 抽象类和抽象方法必须使用 abstract 关键字修饰 12345//抽象类的定义public abstract class 类名 &#123;&#125;//抽象方法的定义public abstract void eat(); 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类 抽象类不能实例化 抽象类可以有构造方法 抽象类的子类 ​ 要么重写抽象类中的所有抽象方法 ​ 要么是抽象类 3.3抽象类的案例（应用） 案例需求 ​ 定义猫类(Cat)和狗类(Dog) ​ 猫类成员方法：eat（猫吃鱼）drink（喝水…） ​ 狗类成员方法：eat（狗吃肉）drink（喝水…） 实现步骤 猫类和狗类中存在共性内容，应向上抽取出一个动物类（Animal） 父类Animal中，无法将 eat 方法具体实现描述清楚，所以定义为抽象方法 抽象方法需要存活在抽象类中，将Animal定义为抽象类 让 Cat 和 Dog 分别继承 Animal，重写eat方法 测试类中创建 Cat 和 Dog 对象，调用方法测试 代码实现 动物类 1234567891011public abstract class Animal &#123; public void drink()&#123; System.out.println(\"喝水\"); &#125; public Animal()&#123; &#125; public abstract void eat();&#125; 猫类 123456public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125; 狗类 123456public class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(\"狗吃肉\"); &#125;&#125; 测试类 123456789101112public static void main(String[] args) &#123; Dog d = new Dog(); d.eat(); d.drink(); Cat c = new Cat(); c.drink(); c.eat(); //Animal a = new Animal(); //a.eat(); &#125; 3.4模板设计模式 设计模式 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。 模板设计模式 把抽象类整体就可以看做成一个模板，模板中不能决定的东西定义成抽象方法让使用模板的类（继承抽象类的类）去重写抽象方法实现需求 模板设计模式的优势 模板已经定义了通用结构，使用者只需要关心自己需要实现的功能即可 示例代码 模板类 12345678910111213141516/* 作文模板类 */public abstract class CompositionTemplate &#123; public final void write()&#123; System.out.println(\"&lt;&lt;我的爸爸&gt;&gt;\"); body(); System.out.println(\"啊~ 这就是我的爸爸\"); &#125; public abstract void body();&#125; 实现类A 12345678public class Tom extends CompositionTemplate &#123; @Override public void body() &#123; System.out.println(\"那是一个秋天, 风儿那么缠绵,记忆中, \" + \"那天爸爸骑车接我放学回家,我的脚卡在了自行车链当中, 爸爸蹬不动,他就站起来蹬...\"); &#125;&#125; 实现类B 12345678910public class Tony extends CompositionTemplate &#123; @Override public void body() &#123; &#125; /*public void write()&#123; &#125;*/&#125; 测试类 123456public class Test &#123; public static void main(String[] args) &#123; Tom t = new Tom(); t.write(); &#125;&#125; 3.5final（应用） fianl关键字的作用 final代表最终的意思，可以修饰成员方法，成员变量，类 final修饰类、方法、变量的效果 fianl修饰类：该类不能被继承（不能有子类，但是可以有父类） final修饰方法：该方法不能被重写 final修饰变量：表明该变量是一个常量，不能再次赋值 变量是基本类型,不能改变的是值 变量是引用类型,不能改变的是地址值,但地址里面的内容是可以改变的 举例 12345public static void main(String[] args)&#123; final Student s = new Student(23); s = new Student(24); // 错误 s.setAge(24); // 正确&#125; 3.6黑马信息管理系统使用抽象类改进 (应用) 需求 使用抽象类的思想，将BaseStudentController 中的 inputStudentInfo 方法，定义为抽象方法 将不希望子类重写的方法，使用 final 进行修饰 代码实现 BaseStudentController类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public abstract class BaseStudentController &#123; // 业务员对象 private StudentService studentService = new StudentService(); private Scanner sc = new Scanner(System.in); // 开启学生管理系统, 并展示学生管理系统菜单 public final void start() &#123; //Scanner sc = new Scanner(System.in); studentLoop: while (true) &#123; System.out.println(\"--------欢迎来到 &lt;学生&gt; 管理系统--------\"); System.out.println(\"请输入您的选择: 1.添加学生 2.删除学生 3.修改学生 4.查看学生 5.退出\"); String choice = sc.next(); switch (choice) &#123; case \"1\": // System.out.println(\"添加\"); addStudent(); break; case \"2\": // System.out.println(\"删除\"); deleteStudentById(); break; case \"3\": // System.out.println(\"修改\"); updateStudent(); break; case \"4\": // System.out.println(\"查询\"); findAllStudent(); break; case \"5\": System.out.println(\"感谢您使用学生管理系统, 再见!\"); break studentLoop; default: System.out.println(\"您的输入有误, 请重新输入\"); break; &#125; &#125; &#125; // 修改学生方法 public final void updateStudent() &#123; String updateId = inputStudentId(); Student newStu = inputStudentInfo(updateId); studentService.updateStudent(updateId, newStu); System.out.println(\"修改成功!\"); &#125; // 删除学生方法 public final void deleteStudentById() &#123; String delId = inputStudentId(); // 3. 调用业务员中的deleteStudentById根据id, 删除学生 studentService.deleteStudentById(delId); // 4. 提示删除成功 System.out.println(\"删除成功!\"); &#125; // 查看学生方法 public final void findAllStudent() &#123; // 1. 调用业务员中的获取方法, 得到学生的对象数组 Student[] stus = studentService.findAllStudent(); // 2. 判断数组的内存地址, 是否为null if (stus == null) &#123; System.out.println(\"查无信息, 请添加后重试\"); return; &#125; // 3. 遍历数组, 获取学生信息并打印在控制台 System.out.println(\"学号\\t\\t姓名\\t年龄\\t生日\"); for (int i = 0; i &lt; stus.length; i++) &#123; Student stu = stus[i]; if (stu != null) &#123; System.out.println(stu.getId() + \"\\t\" + stu.getName() + \"\\t\" + stu.getAge() + \"\\t\\t\" + stu.getBirthday()); &#125; &#125; &#125; // 添加学生方法 public final void addStudent() &#123; // StudentService studentService = new StudentService(); // 1. 键盘接收学生信息 String id; while (true) &#123; System.out.println(\"请输入学生id:\"); id = sc.next(); boolean flag = studentService.isExists(id); if (flag) &#123; System.out.println(\"学号已被占用, 请重新输入\"); &#125; else &#123; break; &#125; &#125; Student stu = inputStudentInfo(id); // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法 boolean result = studentService.addStudent(stu); // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败 if (result) &#123; System.out.println(\"添加成功\"); &#125; else &#123; System.out.println(\"添加失败\"); &#125; &#125; // 键盘录入学生id public String inputStudentId() &#123; String id; while (true) &#123; System.out.println(\"请输入学生id:\"); id = sc.next(); boolean exists = studentService.isExists(id); if (!exists) &#123; System.out.println(\"您输入的id不存在, 请重新输入:\"); &#125; else &#123; break; &#125; &#125; return id; &#125; // 键盘录入学生信息 // 开闭原则: 对扩展内容开放, 对修改内容关闭 public abstract Student inputStudentInfo(String id);&#125; 4.代码块4.1代码块概述 (理解)在Java中，使用 { } 括起来的代码被称为代码块 4.2代码块分类 (理解) 局部代码块 位置: 方法中定义 作用: 限定变量的生命周期，及早释放，提高内存利用率 示例代码 123456789101112131415public class Test &#123; /* 局部代码块 位置：方法中定义 作用：限定变量的生命周期，及早释放，提高内存利用率 */ public static void main(String[] args) &#123; &#123; int a = 10; System.out.println(a); &#125; // System.out.println(a); &#125;&#125; 构造代码块 位置: 类中方法外定义 特点: 每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行 作用: 将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性 示例代码 123456789101112131415161718192021222324252627public class Test &#123; /* 构造代码块: 位置：类中方法外定义 特点：每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行 作用：将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性 */ public static void main(String[] args) &#123; Student stu1 = new Student(); Student stu2 = new Student(10); &#125;&#125;class Student &#123; &#123; System.out.println(\"好好学习\"); &#125; public Student()&#123; System.out.println(\"空参数构造方法\"); &#125; public Student(int a)&#123; System.out.println(\"带参数构造方法...........\"); &#125;&#125; 静态代码块 位置: 类中方法外定义 特点: 需要通过static关键字修饰，随着类的加载而加载，并且只执行一次 作用: 在类加载的时候做一些数据初始化的操作 示例代码 1234567891011121314151617181920212223242526public class Test &#123; /* 静态代码块: 位置：类中方法外定义 特点：需要通过static关键字修饰，随着类的加载而加载，并且只执行一次 作用：在类加载的时候做一些数据初始化的操作 */ public static void main(String[] args) &#123; Person p1 = new Person(); Person p2 = new Person(10); &#125;&#125;class Person &#123; static &#123; System.out.println(\"我是静态代码块, 我执行了\"); &#125; public Person()&#123; System.out.println(\"我是Person类的空参数构造方法\"); &#125; public Person(int a)&#123; System.out.println(\"我是Person类的带...........参数构造方法\"); &#125;&#125; 4.3黑马信息管理系统使用代码块改进 (应用) 需求 使用静态代码块，初始化一些学生数据 实现步骤 在StudentDao类中定义一个静态代码块，用来初始化一些学生数据 将初始化好的学生数据存储到学生数组中 示例代码 StudentDao类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class StudentDao &#123; // 创建学生对象数组 private static Student[] stus = new Student[5]; static &#123; Student stu1 = new Student(\"heima001\",\"张三\",\"23\",\"1999-11-11\"); Student stu2 = new Student(\"heima002\",\"李四\",\"24\",\"2000-11-11\"); stus[0] = stu1; stus[1] = stu2; &#125; // 添加学生方法 public boolean addStudent(Student stu) &#123; // 2. 添加学生到数组 //2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素 int index = -1; //2.2 遍历数组取出每一个元素，判断是否是null for (int i = 0; i &lt; stus.length; i++) &#123; Student student = stus[i]; if(student == null)&#123; index = i; //2.3 如果为null，让index变量记录当前索引位置，并使用break结束循环遍历 break; &#125; &#125; // 3. 返回是否添加成功的boolean类型状态 if(index == -1)&#123; // 装满了 return false; &#125;else&#123; // 没有装满, 正常添加, 返回true stus[index] = stu; return true; &#125; &#125; // 查看学生方法 public Student[] findAllStudent() &#123; return stus; &#125; public void deleteStudentById(String delId) &#123; // 1. 查找id在容器中所在的索引位置 int index = getIndex(delId); // 2. 将该索引位置,使用null元素进行覆盖 stus[index] = null; &#125; public int getIndex(String id)&#123; int index = -1; for (int i = 0; i &lt; stus.length; i++) &#123; Student stu = stus[i]; if(stu != null &amp;&amp; stu.getId().equals(id))&#123; index = i; break; &#125; &#125; return index; &#125; public void updateStudent(String updateId, Student newStu) &#123; // 1. 查找updateId, 在容器中的索引位置 int index = getIndex(updateId); // 2. 将该索引位置, 使用新的学生对象替换 stus[index] = newStu; &#125;&#125; ​","categories":[],"tags":[]},{"title":"11_分类和static","slug":"11_分类和static","date":"2020-11-06T15:45:54.846Z","updated":"2020-11-11T06:43:05.594Z","comments":true,"path":"2020/11/06/11_分类和static/","link":"","permalink":"http://xiaojujing.com/2020/11/06/11_%E5%88%86%E7%B1%BB%E5%92%8Cstatic/","excerpt":"","text":"1.案例驱动模式1.1案例驱动模式概述 (理解)通过我们已掌握的知识点,先实现一个案例,然后找出这个案例中,存在的一些问题,在通过新知识点解决问题 1.2案例驱动模式的好处 (理解) 解决重复代码过多的冗余,提高代码的复用性 解决业务逻辑聚集紧密导致的可读性差,提高代码的可读性 解决代码可维护性差,提高代码的维护性 2.分类思想2.1分类思想概述 (理解)分工协作,专人干专事 2.2黑马信息管理系统 (理解) Student类 标准学生类,封装键盘录入的学生信息(id , name , age , birthday) StudentDao类 Dao : (Data Access Object 缩写) 用于访问存储数据的数组或集合 StudentService类 用来进行业务逻辑的处理(例如: 判断录入的id是否存在) StudentController类 和用户打交道(接收用户需求,采集用户信息,打印数据到控制台) 3.分包思想3.1分包思想概述 (理解)如果将所有的类文件都放在同一个包下,不利于管理和后期维护,所以,对于不同功能的类文件,可以放在不同的包下进行管理 3.2包的概述 (记忆) 包 本质上就是文件夹 创建包 多级包之间使用 “ . “ 进行分割多级包的定义规范：公司的网站地址翻转(去掉www)比如：黑马程序员的网站址为www.itheima.com后期我们所定义的包的结构就是：com.itheima.其他的包名 包的命名规则 字母都是小写 3.3包的注意事项 (理解) package语句必须是程序的第一条可执行的代码 package语句在一个java文件中只能有一个 如果没有package,默认表示无包名 3.4类与类之间的访问 (理解) 同一个包下的访问 不需要导包，直接使用即可 不同包下的访问 1.import 导包后访问 2.通过全类名（包名 + 类名）访问 注意：import 、package 、class 三个关键字的摆放位置存在顺序关系 package 必须是程序的第一条可执行的代码 import 需要写在 package 下面 class 需要在 import 下面 4.黑马信息管理系统4.1系统介绍 (理解) 4.2学生管理系统 (应用)4.2.1需求说明 添加学生: 键盘录入学生信息(id，name，age，birthday) 使用数组存储学生信息,要求学生的id不能重复 删除学生: 键盘录入要删除学生的id值,将该学生从数组中移除,如果录入的id在数组中不存在,需要重新录入 修改学生: 键盘录入要修改学生的id值和修改后的学生信息 将数组中该学生的信息修改,如果录入的id在数组中不存在,需要重新录入 查询学生: 将数组中存储的所有学生的信息输出到控制台 4.2.2实现步骤 环境搭建实现步骤 包 存储的类 作用 com.itheima.edu.info.manager.domain Student.java 封装学生信息 com.itheima.edu.info.manager.dao StudentDao.java 访问存储数据的数组，进行赠删改查（库管） com.itheima.edu.info.manager.service StudentService.java 业务的逻辑处理（业务员） com.itheima.edu.info.manager.controller StudentController.java 和用户打交道（客服接待） com.itheima.edu.info.manager.entry InfoManagerEntry.java 程序的入口类，提供一个main方法 菜单搭建实现步骤 需求 黑马管理系统菜单搭建 学生管理系统菜单搭建 实现步骤 展示欢迎页面,用输出语句完成主界面的编写 获取用户的选择,用Scanner实现键盘录入数据 根据用户的选择执行对应的操作,用switch语句完成操作的选择 添加功能实现步骤 添加功能优化:判断id是否存在 查询功能实现步骤 删除功能实现步骤 修改功能实现步骤 系统优化 把updateStudent和deleteStudentById中录入学生id代码抽取到一个方法(inputStudentId)中该方法的主要作用就是录入学生的id，方法的返回值为String类型 把addStudent和updateStudent中录入学生信息的代码抽取到一个方法(inputStudentInfo)中该方法的主要作用就是录入学生的信息，并封装为学生对象，方法的返回值为Student类型 4.2.3代码实现学生类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Student &#123; private String id; private String name; private String age; private String birthday; String address; public Student() &#123; &#125; public Student(String id, String name, String age, String birthday) &#123; this.id = id; this.name = name; this.age = age; this.birthday = birthday; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125;&#125; 程序入口InfoManagerEntry类 1234567891011121314151617181920212223242526272829303132public class InfoManagerEntry &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (true) &#123; // 主菜单搭建 System.out.println(\"--------欢迎来到黑马信息管理系统--------\"); System.out.println(\"请输入您的选择: 1.学生管理 2.老师管理 3.退出\"); String choice = sc.next(); switch (choice) &#123; case \"1\": // System.out.println(\"学生管理\"); // 开启学生管理系统 StudentController studentController = new StudentController(); studentController.start(); break; case \"2\": System.out.println(\"老师管理\"); TeacherController teacherController = new TeacherController(); teacherController.start(); break; case \"3\": System.out.println(\"感谢您的使用\"); // 退出当前正在运行的JVM虚拟机 System.exit(0); break; default: System.out.println(\"您的输入有误, 请重新输入\"); break; &#125; &#125; &#125;&#125; StudentController类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public class StudentController &#123; // 业务员对象 private StudentService studentService = new StudentService(); private Scanner sc = new Scanner(System.in); // 开启学生管理系统, 并展示学生管理系统菜单 public void start() &#123; //Scanner sc = new Scanner(System.in); studentLoop: while (true) &#123; System.out.println(\"--------欢迎来到 &lt;学生&gt; 管理系统--------\"); System.out.println(\"请输入您的选择: 1.添加学生 2.删除学生 3.修改学生 4.查看学生 5.退出\"); String choice = sc.next(); switch (choice) &#123; case \"1\": // System.out.println(\"添加\"); addStudent(); break; case \"2\": // System.out.println(\"删除\"); deleteStudentById(); break; case \"3\": // System.out.println(\"修改\"); updateStudent(); break; case \"4\": // System.out.println(\"查询\"); findAllStudent(); break; case \"5\": System.out.println(\"感谢您使用学生管理系统, 再见!\"); break studentLoop; default: System.out.println(\"您的输入有误, 请重新输入\"); break; &#125; &#125; &#125; // 修改学生方法 public void updateStudent() &#123; String updateId = inputStudentId(); Student newStu = inputStudentInfo(updateId); studentService.updateStudent(updateId, newStu); System.out.println(\"修改成功!\"); &#125; // 删除学生方法 public void deleteStudentById() &#123; String delId = inputStudentId(); // 3. 调用业务员中的deleteStudentById根据id, 删除学生 studentService.deleteStudentById(delId); // 4. 提示删除成功 System.out.println(\"删除成功!\"); &#125; // 查看学生方法 public void findAllStudent() &#123; // 1. 调用业务员中的获取方法, 得到学生的对象数组 Student[] stus = studentService.findAllStudent(); // 2. 判断数组的内存地址, 是否为null if (stus == null) &#123; System.out.println(\"查无信息, 请添加后重试\"); return; &#125; // 3. 遍历数组, 获取学生信息并打印在控制台 System.out.println(\"学号\\t\\t姓名\\t年龄\\t生日\"); for (int i = 0; i &lt; stus.length; i++) &#123; Student stu = stus[i]; if (stu != null) &#123; System.out.println(stu.getId() + \"\\t\" + stu.getName() + \"\\t\" + stu.getAge() + \"\\t\\t\" + stu.getBirthday()); &#125; &#125; &#125; // 添加学生方法 public void addStudent() &#123; // StudentService studentService = new StudentService(); // 1. 键盘接收学生信息 String id; while (true) &#123; System.out.println(\"请输入学生id:\"); id = sc.next(); boolean flag = studentService.isExists(id); if (flag) &#123; System.out.println(\"学号已被占用, 请重新输入\"); &#125; else &#123; break; &#125; &#125; Student stu = inputStudentInfo(id); // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法 boolean result = studentService.addStudent(stu); // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败 if (result) &#123; System.out.println(\"添加成功\"); &#125; else &#123; System.out.println(\"添加失败\"); &#125; &#125; // 键盘录入学生id public String inputStudentId() &#123; String id; while (true) &#123; System.out.println(\"请输入学生id:\"); id = sc.next(); boolean exists = studentService.isExists(id); if (!exists) &#123; System.out.println(\"您输入的id不存在, 请重新输入:\"); &#125; else &#123; break; &#125; &#125; return id; &#125; // 键盘录入学生信息 public Student inputStudentInfo(String id) &#123; System.out.println(\"请输入学生姓名:\"); String name = sc.next(); System.out.println(\"请输入学生年龄:\"); String age = sc.next(); System.out.println(\"请输入学生生日:\"); String birthday = sc.next(); Student stu = new Student(); stu.setId(id); stu.setName(name); stu.setAge(age); stu.setBirthday(birthday); return stu; &#125;&#125; StudentService类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class StudentService &#123; // 创建StudentDao (库管) private StudentDao studentDao = new StudentDao(); // 添加学生方法 public boolean addStudent(Student stu) &#123; // 2. 将学生对象, 传递给StudentDao 库管中的addStudent方法 // 3. 将返回的boolean类型结果, 返还给StudentController return studentDao.addStudent(stu); &#125; // 判断学号是否存在方法 public boolean isExists(String id) &#123; Student[] stus = studentDao.findAllStudent(); // 假设id在数组中不存在 boolean exists = false; // 遍历数组, 获取每一个学生对象, 准备进行判断 for (int i = 0; i &lt; stus.length; i++) &#123; Student student = stus[i]; if(student != null &amp;&amp; student.getId().equals(id))&#123; exists = true; break; &#125; &#125; return exists; &#125; // 查看学生方法 public Student[] findAllStudent() &#123; // 1. 调用库管对象的findAllStudent获取学生对象数组 Student[] allStudent = studentDao.findAllStudent(); // 2. 判断数组中是否有学生信息 (有: 返回地址, 没有: 返回null) // 思路: 数组中只要存在一个不是null的元素, 那就代表有学生信息 boolean flag = false; for (int i = 0; i &lt; allStudent.length; i++) &#123; Student stu = allStudent[i]; if(stu != null)&#123; flag = true; break; &#125; &#125; if(flag)&#123; // 有信息 return allStudent; &#125;else&#123; // 没有信息 return null; &#125; &#125; public void deleteStudentById(String delId) &#123; studentDao.deleteStudentById(delId); &#125; public void updateStudent(String updateId, Student newStu) &#123; studentDao.updateStudent(updateId, newStu); &#125;&#125; StudentDao类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class StudentDao &#123; // 创建学生对象数组 private static Student[] stus = new Student[5]; // 添加学生方法 public boolean addStudent(Student stu) &#123; // 2. 添加学生到数组 //2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素 int index = -1; //2.2 遍历数组取出每一个元素，判断是否是null for (int i = 0; i &lt; stus.length; i++) &#123; Student student = stus[i]; if(student == null)&#123; index = i; //2.3 如果为null，让index变量记录当前索引位置，并使用break结束循环遍历 break; &#125; &#125; // 3. 返回是否添加成功的boolean类型状态 if(index == -1)&#123; // 装满了 return false; &#125;else&#123; // 没有装满, 正常添加, 返回true stus[index] = stu; return true; &#125; &#125; // 查看学生方法 public Student[] findAllStudent() &#123; return stus; &#125; public void deleteStudentById(String delId) &#123; // 1. 查找id在容器中所在的索引位置 int index = getIndex(delId); // 2. 将该索引位置,使用null元素进行覆盖 stus[index] = null; &#125; public int getIndex(String id)&#123; int index = -1; for (int i = 0; i &lt; stus.length; i++) &#123; Student stu = stus[i]; if(stu != null &amp;&amp; stu.getId().equals(id))&#123; index = i; break; &#125; &#125; return index; &#125; public void updateStudent(String updateId, Student newStu) &#123; // 1. 查找updateId, 在容器中的索引位置 int index = getIndex(updateId); // 2. 将该索引位置, 使用新的学生对象替换 stus[index] = newStu; &#125;&#125; 4.3老师管理系统 (应用)4.3.1需求说明 添加老师: 通过键盘录入老师信息(id，name，age，birthday) 使用数组存储老师信息,要求老师的id不能重复 删除老师: 通过键盘录入要删除老师的id值,将该老师从数组中移除,如果录入的id在数组中不存在,需要重新录入 修改老师: 通过键盘录入要修改老师的id值和修改后的老师信息 将数组中该老师的信息修改,如果录入的id在数组中不存在,需要重新录入 查询老师: 将数组中存储的所有老师的信息输出到控制台 4.3.2实现步骤 环境搭建实现步骤 包 存储的类 作用 com.itheima.edu.info.manager.domain Student.java Teacher.java 封装学生信息 封装老师信息 com.itheima.edu.info.manager.dao StudentDao.java TeacherDao.java 访问存储数据的数组,进行赠删改查（库管） com.itheima.edu.info.manager.service StudentService.java TeacherService.java 业务的逻辑处理（业务员） com.itheima.edu.info.manager.controller StudentController.java TeacherController.java 和用户打交道（客服接待） com.itheima.edu.info.manager.entry InfoManagerEntry.java 程序的入口类,提供一个main方法 菜单搭建实现步骤 展示欢迎页面,用输出语句完成主界面的编写 获取用户的选择,用Scanner实现键盘录入数据 根据用户的选择执行对应的操作,用switch语句完成操作的选择 添加功能实现步骤 查询功能实现步骤 删除功能实现步骤 修改功能实现步骤 系统优化 把updateTeacher和deleteTeacherById中录入老师id代码抽取到一个方法(inputTeacherId)中该方法的主要作用就是录入老师的id,方法的返回值为String类型 把addTeacher和updateTeacher中录入老师信息的代码抽取到一个方法(inputTeacherInfo)中该方法的主要作用就是录入老师的信息,并封装为老师对象,方法的返回值为Teacher类型 4.3.3代码实现老师类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Teacher extends Person&#123; private String id; private String name; private String age; private String birthday; String address; public Teacher() &#123; &#125; public Teacher(String id, String name, String age, String birthday) &#123; this.id = id; this.name = name; this.age = age; this.birthday = birthday; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125;&#125; TeacherController类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class TeacherController &#123; private Scanner sc = new Scanner(System.in); private TeacherService teacherService = new TeacherService(); public void start() &#123; teacherLoop: while (true) &#123; System.out.println(\"--------欢迎来到 &lt;老师&gt; 管理系统--------\"); System.out.println(\"请输入您的选择: 1.添加老师 2.删除老师 3.修改老师 4.查看老师 5.退出\"); String choice = sc.next(); switch (choice) &#123; case \"1\": // System.out.println(\"添加老师\"); addTeacher(); break; case \"2\": // System.out.println(\"删除老师\"); deleteTeacherById(); break; case \"3\": // System.out.println(\"修改老师\"); updateTeacher(); break; case \"4\": // System.out.println(\"查看老师\"); findAllTeacher(); break; case \"5\": System.out.println(\"感谢您使用老师管理系统, 再见!\"); break teacherLoop; default: System.out.println(\"您的输入有误, 请重新输入\"); break; &#125; &#125; &#125; public void updateTeacher() &#123; String id = inputTeacherId(); Teacher newTeacher = inputTeacherInfo(id); // 调用业务员的修改方法 teacherService.updateTeacher(id,newTeacher); System.out.println(\"修改成功\"); &#125; public void deleteTeacherById() &#123; String id = inputTeacherId(); // 2. 调用业务员中的删除方法, 根据id, 删除老师 teacherService.deleteTeacherById(id); // 3. 提示删除成功 System.out.println(\"删除成功\"); &#125; public void findAllTeacher() &#123; // 1. 从业务员中, 获取老师对象数组 Teacher[] teachers = teacherService.findAllTeacher(); // 2. 判断数组中是否有元素 if (teachers == null) &#123; System.out.println(\"查无信息, 请添加后重试\"); return; &#125; // 3. 遍历数组, 取出元素, 并打印在控制台 System.out.println(\"学号\\t\\t姓名\\t年龄\\t生日\"); for (int i = 0; i &lt; teachers.length; i++) &#123; Teacher t = teachers[i]; if (t != null) &#123; System.out.println(t.getId() + \"\\t\" + t.getName() + \"\\t\" + t.getAge() + \"\\t\\t\" + t.getBirthday()); &#125; &#125; &#125; public void addTeacher() &#123; String id; while (true) &#123; // 1. 接收不存在的老师id System.out.println(\"请输入老师id:\"); id = sc.next(); // 2. 判断id是否存在 boolean exists = teacherService.isExists(id); if (exists) &#123; System.out.println(\"id已被占用, 请重新输入:\"); &#125; else &#123; break; &#125; &#125; Teacher t = inputTeacherInfo(id); // 5. 将封装好的老师对象, 传递给TeacherService继续完成添加操作 boolean result = teacherService.addTeacher(t); if (result) &#123; System.out.println(\"添加成功\"); &#125; else &#123; System.out.println(\"添加失败\"); &#125; &#125; // 录入老师id public String inputTeacherId()&#123; String id; while(true)&#123; System.out.println(\"请输入id\"); id = sc.next(); boolean exists = teacherService.isExists(id); if(!exists)&#123; System.out.println(\"您输入的id不存在, 请重新输入:\"); &#125;else&#123; break; &#125; &#125; return id; &#125; // 录入老师信息, 封装为老师对象 public Teacher inputTeacherInfo(String id)&#123; System.out.println(\"请输入老师姓名:\"); String name = sc.next(); System.out.println(\"请输入老师年龄:\"); String age = sc.next(); System.out.println(\"请输入老师生日:\"); String birthday = sc.next(); Teacher t = new Teacher(); t.setId(id); t.setName(name); t.setAge(age); t.setBirthday(birthday); return t; &#125;&#125; TeacherService类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class TeacherService &#123; private TeacherDao teacherDao = new TeacherDao(); public boolean addTeacher(Teacher t) &#123; return teacherDao.addTeacher(t); &#125; public boolean isExists(String id) &#123; // 1. 获取库管对象中的数组 Teacher[] teachers = teacherDao.findAllTeacher(); boolean exists = false; // 2. 遍历数组, 取出每一个元素, 进行判断 for (int i = 0; i &lt; teachers.length; i++) &#123; Teacher teacher = teachers[i]; if(teacher != null &amp;&amp; teacher.getId().equals(id))&#123; exists = true; break; &#125; &#125; return exists; &#125; public Teacher[] findAllTeacher() &#123; Teacher[] allTeacher = teacherDao.findAllTeacher(); boolean flag = false; for (int i = 0; i &lt; allTeacher.length; i++) &#123; Teacher t = allTeacher[i]; if(t != null)&#123; flag = true; break; &#125; &#125; if(flag)&#123; return allTeacher; &#125;else&#123; return null; &#125; &#125; public void deleteTeacherById(String id) &#123; teacherDao.deleteTeacherById(id); &#125; public void updateTeacher(String id, Teacher newTeacher) &#123; teacherDao.updateTeacher(id,newTeacher); &#125;&#125; TeacherDao类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TeacherDao &#123; private static Teacher[] teachers = new Teacher[5]; public boolean addTeacher(Teacher t) &#123; int index = -1; for (int i = 0; i &lt; teachers.length; i++) &#123; Teacher teacher = teachers[i]; if(teacher == null)&#123; index = i; break; &#125; &#125; if(index == -1)&#123; return false; &#125;else&#123; teachers[index] = t; return true; &#125; &#125; public Teacher[] findAllTeacher() &#123; return teachers; &#125; public void deleteTeacherById(String id) &#123; // 1. 查询id在数组中的索引位置 int index = getIndex(id); // 2. 将该索引位置的元素, 使用null进行替换 teachers[index] = null; &#125; public int getIndex(String id)&#123; int index = -1; for (int i = 0; i &lt; teachers.length; i++) &#123; Teacher t = teachers[i]; if(t != null &amp;&amp; t.getId().equals(id))&#123; index = i; break; &#125; &#125; return index; &#125; public void updateTeacher(String id, Teacher newTeacher) &#123; int index = getIndex(id); teachers[index] = newTeacher; &#125;&#125; 5.static关键字5.1static关键字概述 (理解)static 关键字是静态的意思,是Java中的一个修饰符,可以修饰成员方法,成员变量 5.2static修饰的特点 (记忆) 被类的所有对象共享 是我们判断是否使用静态关键字的条件 随着类的加载而加载，优先于对象存在 对象需要类被加载后，才能创建 可以通过类名调用 也可以通过对象名调用 5.3static关键字注意事项 (理解) 静态方法只能访问静态的成员 非静态方法可以访问静态的成员，也可以访问非静态的成员 静态方法中是没有this关键字","categories":[],"tags":[]},{"title":"10_Git介绍","slug":"10_Git介绍","date":"2020-11-05T07:13:27.339Z","updated":"2020-11-05T07:57:37.407Z","comments":true,"path":"2020/11/05/10_Git介绍/","link":"","permalink":"http://xiaojujing.com/2020/11/05/10_Git%E4%BB%8B%E7%BB%8D/","excerpt":"1.Git介绍1.1版本控制(理解)无论是代码编写，还是文档编写，我们都会遇到对文档内容反复修改的情况","text":"1.Git介绍1.1版本控制(理解)无论是代码编写，还是文档编写，我们都会遇到对文档内容反复修改的情况 1.2开发中存在的问题(理解) 程序员小明负责的模块就要完成了，就在即将提交发布之前的一瞬间，电脑突然蓝屏，硬盘光荣下岗！ 几个月来的努力付之东流 ​ 老王需要在项目中加入一个很复杂的功能，一边尝试，一边修改代码，就这样摸索了一个星期。可是这被改得面目全非的代码已经回不到从前了。 小明和老王先后从文件服务器上下载了同一个文件 因项目中Bug过多，导致项目进度拖延，项目经理老徐因此被骂，但不清楚Bug是手下哪一个程序员写的 开发中要解决的问题 代码备份 版本控制 协同工作 责任追溯 1.3SVN版本控制(理解)SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。 服务器单点故障 将会导致所有人员无法工作 而服务器硬盘损坏 这意味着，你可能失去了该项目的所有历史记录，这是毁灭性的。 1.4Git版本控制(理解)Git是在2005年，Linux系统的创建者Linus Torvalds,为了帮助全球的开发者，维护Linux系统内核的开发而开发了自己的开源分布式版本控制工具,分为两种类型的仓库：本地仓库和远程仓库。 每一个客户端都保存了完整的历史记录 服务器的故障，都可以通过客户端的记录得以恢复。 2.Git下载和安装2.1Git的下载(应用)官网下载地址：https://git-scm.com/downloads 2.2Git的安装(应用) 双击安装包，进入安装向导界面 指定安装目录 一路next下一步 等待安装 安装完成 安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看到如下两个菜单则说明Git安装成功。 运行Git命令客户端，使用git –version 命令，可以查看git版本 2.3TortoiseGit的安装(应用) 双击安装包，进入安装向导界面 一路next下一步 指定安装目录 安装 配置 安装TortoiseGit中文语言包,一路next即可 配置TortoiseGit中文语言 3.Git操作入门3.1Git基本工作流程(理解)本地仓库 3.2Git命令行操作(应用) git常用命令 命令 作用 git init 初始化，创建 git 仓库 git status 查看 git 状态 （文件是否进行了添加、提交操作） git add 文件名 添加，将指定文件添加到暂存区 git commit -m ‘提交信息’ 提交，将暂存区文件提交到历史仓库 git log 查看日志（ git 提交的历史日志） 操作步骤 创建工作目录、初始化本地 git 仓库 新建一个 test.txt 文件（暂不执行添加操作） 使用 status 命令，查看状态 使用 add 命令添加，并查看状态 使用 commit 命令，提交到本地历史仓库 使用 log 命令，查看日志 修改 test.txt 文件 添加并提交，查看日志 3.3Git图形化工具操作(理解) 创建工作目录、初始化本地 git 仓库 新建一个 test.txt 文件（暂不执行添加操作） 选中文件右键，选择TortoiseGit，之后选择添加 空白处右键,Git提交,提交到本地历史仓库 空白处右键,TortoiseGit,显示日志,可以产看日志信息 修改 test.txt 文件 添加并提交，查看日志 4.Git版本管理4.1历史版本切换(理解) 准备动作 查看 my_project 的 log 日志git reflog ：可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录的操作） 增加一次新的修改记录 需求: 将代码切换到第二次修改的版本 指令：git reset –hard 版本唯一索引值 4.2分支管理介绍(理解) 分支 由每次提交的代码，串成的一条时间线 使用分支意味着你可以把你的工作从开发主线上分离开来,以免影响开发主线 分支的使用场景 周期较长的模块开发假设你准备开发一个新功能，但是需要一个月才能完成第一周写了20%的代码，突然发现原来已经写好的功能出现了一个严重的Bug那现在就需要放下手中的新功能，去修复Bug但这20%的代码不能舍弃，并且也担心丢失，这就需要开启一个新的版本控制。 尝试性的模块开发业务人员给我们提出了一个需求，经过我们的思考和分析该需求应该可以使用技术手段进行实现。但是我们还不敢确定，我们就可以去创建一个分支基于分支进行尝试性开发。 分支工作流程 Master: 指向提交的代码版本 Header: 指向当前所使用的的分支 4.3分支管理操作(应用) 创建和切换 创建命令：git branch 分支名切换命令：git checkout 分支名 新分支添加文件 查看文件命令：ls 总结：不同分支之间的关系是平行的关系，不会相互影响 合并分支 合并命令：git merge 分支名 删除分支 删除命令：git branch -d 分支名 查看分支列表 查看命令：git branch 5.远程仓库5.1远程仓库工作流程(理解) 5.2远程仓库平台介绍(理解) GitHub 域名：https://github.com介绍：GitHub是全球最大的开源项目托管平台，俗称大型程序员社区化交友网站 ​ 各类好玩有趣的开源项目，只有想不到，没有找不到。 码云 域名：https://gitee.com介绍：码云是全国最大的开源项目托管平台，良心平台，速度快，提供免费私有库 5.3码云的注册(应用) 5.4先有本地项目,远程为空(应用) 步骤 创建本地仓库 创建或修改文件，添加（add）文件到暂存区，提交（commit）到本地仓库 创建远程仓库 推送到远程仓库 创建远程仓库 生成SSH公钥 推送代码之前，需要先配置SSH公钥 生成SSH公钥步骤 设置Git账户 git config user.name（查看git账户） git config user.email（查看git邮箱） git config –global user.name “账户名”（设置全局账户名） git config –global user.email “邮箱”（设置全局邮箱） cd ~/.ssh（查看是否生成过SSH公钥） 生成SSH公钥 生成命令: ssh-keygen –t rsa –C “邮箱” ( 注意：这里需要敲3次回车) 查看命令: cat ~/.ssh/id-rsa.pub 设置账户公钥 公钥测试 命令: ssh -T git@gitee.com 推送到远程仓库 步骤 为远程仓库的URL（网址），自定义仓库名称 推送 命令 git remote add 远程名称 远程仓库URL git push -u 仓库名称 分支名 5.5先有远程仓库,本地为空(应用) 步骤 将远程仓库的代码，克隆到本地仓库 克隆命令：git clone 仓库地址 创建新文件，添加并提交到本地仓库 推送至远程仓库 项目拉取更新 拉取命令：git pull 远程仓库名 分支名 5.6代码冲突(应用) 产生原因: 两个程序员操作同一个文件,其中一个程序员在修改文件后,push到远程仓库,另一个程序员应该先pull将最新的代码更新到本地仓库后,在修改代码,之后push到远程仓库,结果他没有先pull将最新的代码更新到本地仓库,而是直接将自己的代码push到远程仓库,这样就可能会导致代码冲突 如何解决冲突 &lt;&lt;&lt;&lt;&lt;&lt;&lt;和&gt;&gt;&gt;&gt;&gt;&gt;&gt;中间的内容,就是冲突部分 修改冲突行，保存，即可解决冲突。 重新add冲突文件并commit到本地仓库，重新push到远程 6.IDEA集成Git6.1IDEA中配置Git(应用) File -&gt; Settings Version Control -&gt; Git -&gt; 指定git.exe存放目录 点击Test测试 6.2创建本地仓库(应用) VCS-&gt;Import into Version Control-&gt;Create Git Repository 选择工程所在的目录,这样就创建好本地仓库了 点击git后边的对勾,将当前项目代码提交到本地仓库 注意: 项目中的配置文件不需要提交到本地仓库中,提交时,忽略掉即可 6.3版本切换(应用) 方式一: 控制台Version Control-&gt;Log-&gt;Reset Current Branch…-&gt;Reset 这种切换的特点是会抛弃原来的提交记录 方式二:控制台Version Control-&gt;Log-&gt;Revert Commit-&gt;Merge-&gt;处理代码-&gt;commit 这种切换的特点是会当成一个新的提交记录,之前的提交记录也都保留 ​ 6.4分支管理(应用) 创建分支 VCS-&gt;Git-&gt;Branches-&gt;New Branch-&gt;给分支起名字-&gt;ok 切换分支 idea右下角Git-&gt;选择要切换的分支-&gt;checkout 合并分支 VCS-&gt;Git-&gt;Merge changes-&gt;选择要合并的分支-&gt;merge 处理分支中的代码 删除分支 idea右下角-&gt;选中要删除的分支-&gt;Delete 6.5本地仓库推送到远程仓库(应用) VCS-&gt;Git-&gt;Push-&gt;点击master Define remote 将远程仓库的路径复制过来-&gt;Push 6.6远程仓库克隆到本地仓库(应用)File-&gt;Close Project-&gt;Checkout from Version Control-&gt;Git-&gt;指定远程仓库的路径-&gt;指定本地存放的路径-&gt;clone","categories":[],"tags":[]},{"title":"9_ArrayList","slug":"9_ArrayList","date":"2020-11-05T07:12:37.394Z","updated":"2020-11-05T07:57:27.303Z","comments":true,"path":"2020/11/05/9_ArrayList/","link":"","permalink":"http://xiaojujing.com/2020/11/05/9_ArrayList/","excerpt":"1.ArrayList集合和数组的区别 : ​ 共同点：都是存储数据的容器 ​ 不同点：数组的容量是固定的，集合的容量是可变的","text":"1.ArrayList集合和数组的区别 : ​ 共同点：都是存储数据的容器 ​ 不同点：数组的容量是固定的，集合的容量是可变的 1.1 -ArrayList的构造方法和添加方法 public ArrayList() 创建一个空的集合对象 public boolean add(E e) 将指定的元素追加到此集合的末尾 public void add(int index,E element) 在此集合中的指定位置插入指定的元素 ArrayList ： ​ 可调整大小的数组实现 ​ : 是一种特殊的数据类型，泛型。 怎么用呢 ? ​ 在出现E的地方我们使用引用数据类型替换即可 ​ 举例：ArrayList, ArrayList 1.2ArrayList类常用方法【应用】*成员方法 : * public boolean remove(Object o) 删除指定的元素，返回删除是否成功 public E remove(int index) 删除指定索引处的元素，返回被删除的元素 public E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 public E get(int index) 返回指定索引处的元素 public int size() 返回集合中的元素的个数 示例代码 : 123456789101112131415161718192021222324252627282930313233343536373839public class ArrayListDemo02 &#123; public static void main(String[] args) &#123; //创建集合 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //添加元素 array.add(\"hello\"); array.add(\"world\"); array.add(\"java\"); //public boolean remove(Object o)：删除指定的元素，返回删除是否成功// System.out.println(array.remove(\"world\"));// System.out.println(array.remove(\"javaee\")); //public E remove(int index)：删除指定索引处的元素，返回被删除的元素// System.out.println(array.remove(1)); //IndexOutOfBoundsException// System.out.println(array.remove(3)); //public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素// System.out.println(array.set(1,\"javaee\")); //IndexOutOfBoundsException// System.out.println(array.set(3,\"javaee\")); //public E get(int index)：返回指定索引处的元素// System.out.println(array.get(0));// System.out.println(array.get(1));// System.out.println(array.get(2)); //System.out.println(array.get(3)); //？？？？？？ 自己测试 //public int size()：返回集合中的元素的个数 System.out.println(array.size()); //输出集合 System.out.println(\"array:\" + array); &#125;&#125; 1.3 ArrayList存储字符串并遍历案例需求 : ​ 创建一个存储字符串的集合，存储3个字符串元素，使用程序实现在控制台遍历该集合 实现步骤 : 1:创建集合对象12342:往集合中添加字符串对象3:遍历集合，首先要能够获取到集合中的每一个元素，这个通过get(int index)方法实现4:遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现5:遍历集合的通用格式 代码实现 : 12345678910111213141516171819202122232425262728/* 思路： 1:创建集合对象 2:往集合中添加字符串对象 3:遍历集合，首先要能够获取到集合中的每一个元素，这个通过get(int index)方法实现 4:遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现 5:遍历集合的通用格式 */public class ArrayListTest01 &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //往集合中添加字符串对象 array.add(\"刘正风\"); array.add(\"左冷禅\"); array.add(\"风清扬\"); //遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现// System.out.println(array.size()); //遍历集合的通用格式 for(int i=0; i&lt;array.size(); i++) &#123; String s = array.get(i); System.out.println(s); &#125; &#125;&#125; 1.4 ArrayList存储学生对象并遍历案例需求 : ​ 创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合 *实现步骤 : * ​ 1:定义学生类 ​ 2:创建集合对象 ​ 3:创建学生对象 ​ 4:添加学生对象到集合中 ​ 5:遍历集合，采用通用遍历格式实现 代码实现 : 123456789101112131415161718192021222324252627282930/* 思路： 1:定义学生类 2:创建集合对象 3:创建学生对象 4:添加学生对象到集合中 5:遍历集合，采用通用遍历格式实现 */public class ArrayListTest02 &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"风清扬\", 33); Student s3 = new Student(\"张曼玉\", 18); //添加学生对象到集合中 array.add(s1); array.add(s2); array.add(s3); //遍历集合，采用通用遍历格式实现 for (int i = 0; i &lt; array.size(); i++) &#123; Student s = array.get(i); System.out.println(s.getName() + \",\" + s.getAge()); &#125; &#125;&#125; 1.5 键盘录入学生信息到集合案例需求 : ​ 创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合 ​ 学生的姓名和年龄来自于键盘录入 实现步骤 : ​ 1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型 ​ 2:创建集合对象 ​ 3:键盘录入学生对象所需要的数据 ​ 4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量 ​ 5:往集合中添加学生对象 ​ 6:遍历集合，采用通用遍历格式实现 代码实现 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 思路： 1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型 2:创建集合对象 3:键盘录入学生对象所需要的数据 4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量 5:往集合中添加学生对象 6:遍历集合，采用通用遍历格式实现 */public class ArrayListTest &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList&lt;Student&gt; array = new ArrayList&lt;Student&gt;(); //为了提高代码的复用性，我们用方法来改进程序 addStudent(array); addStudent(array); addStudent(array); //遍历集合，采用通用遍历格式实现 for (int i = 0; i &lt; array.size(); i++) &#123; Student s = array.get(i); System.out.println(s.getName() + \",\" + s.getAge()); &#125; &#125; /* 两个明确： 返回值类型：void 参数：ArrayList&lt;Student&gt; array */ public static void addStudent(ArrayList&lt;Student&gt; array) &#123; //键盘录入学生对象所需要的数据 Scanner sc = new Scanner(System.in); System.out.println(\"请输入学生姓名:\"); String name = sc.nextLine(); System.out.println(\"请输入学生年龄:\"); String age = sc.nextLine(); //创建学生对象，把键盘录入的数据赋值给学生对象的成员变量 Student s = new Student(); s.setName(name); s.setAge(age); //往集合中添加学生对象 array.add(s); &#125;&#125; 2. 学生管理系统2.1 学生管理系统实现步骤 案例需求 ​ 针对目前我们的所学内容，完成一个综合案例：学生管理系统！该系统主要功能如下： ​ 添加学生：通过键盘录入学生信息，添加到集合中 ​ 删除学生：通过键盘录入要删除学生的学号，将该学生对象从集合中删除 ​ 修改学生：通过键盘录入要修改学生的学号，将该学生对象其他信息进行修改 ​ 查看学生：将集合中的学生对象信息进行展示 ​ 退出系统：结束程序 实现步骤 定义学生类，包含以下成员变量 学生类： Student成员变量： ​ 学号：sid ​ 姓名：name ​ 年龄：age ​ 生日：birthday ​ 构造方法： ​ 无参构造 ​ 带四个参数的构造成员方法： ​ 每个成员变量对应给出get/set方法 学生管理系统主界面的搭建步骤 2.1 用输出语句完成主界面的编写 2.2 用Scanner实现键盘录入数据 2.3 用switch语句完成操作的选择 2.4 用循环完成再次回到主界面 学生管理系统的添加学生功能实现步骤 3.1 用键盘录入选择添加学生 3.2 定义一个方法，用于添加学生 ​ 显示提示信息，提示要输入何种信息 ​ 键盘录入学生对象所需要的数据 ​ 创建学生对象，把键盘录入的数据赋值给学生对象的成员变量 ​ 将学生对象添加到集合中（保存） ​ 给出添加成功提示 3.3 调用方法 学生管理系统的查看学生功能实现步骤 4.1 用键盘录入选择查看所有学生信息 4.2 定义一个方法，用于查看学生信息 ​ 显示表头信息 ​ 将集合中数据取出按照对应格式显示学生信息，年龄显示补充“岁” 4.3 调用方法 学生管理系统的删除学生功能实现步骤 5.1 用键盘录入选择删除学生信息 5.2 定义一个方法，用于删除学生信息 ​ 显示提示信息 ​ 键盘录入要删除的学生学号 ​ 调用getIndex方法，查找该学号在集合的索引 ​ 如果索引为-1，提示信息不存在 ​ 如果索引不是-1，调用remove方法删除并提示删除成功 5.3 调用方法 学生管理系统的修改学生功能实现步骤 6.1 用键盘录入选择修改学生信息 6.2 定义一个方法，用于修改学生信息 ​ 显示提示信息 ​ 键盘录入要修改的学生学号 ​ 调用getIndex方法，查找该学号在集合的索引 ​ 如果索引为-1，提示信息不存在 ​ 如果索引不是-1，键盘录入要修改的学生信息 ​ 集合修改对应的学生信息 ​ 给出修改成功提示 6.3 调用方法 退出系统 使用System.exit(0);退出JVM 2.2 学生类的定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.itheima.domain;public class Student &#123; private String sid; // 学号 private String name; // 姓名 private int age; // 年龄 private String birthday; // 生日 public Student() &#123; &#125; public Student(String sid, String name, int age, String birthday) &#123; this.sid = sid; this.name = name; this.age = age; this.birthday = birthday; &#125; public String getSid() &#123; return sid; &#125; public void setSid(String sid) &#123; this.sid = sid; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125;&#125; 2.3 测试类的定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.itheima.test;import com.itheima.domain.Student;import java.util.ArrayList;import java.util.Scanner;public class StudentManager &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); // 创建集合容器对象 ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); lo: while (true) &#123; // 1. 搭建主界面菜单 System.out.println(\"--------欢迎来到学生管理系统--------\"); System.out.println(\"1 添加学生\"); System.out.println(\"2 删除学生\"); System.out.println(\"3 修改学生\"); System.out.println(\"4 查看学生\"); System.out.println(\"5 退出\"); System.out.println(\"请输入您的选择:\"); String choice = sc.next(); switch (choice) &#123; case \"1\": //System.out.println(\"添加学生\"); addStudent(list); break; case \"2\": //System.out.println(\"删除学生\"); deleteStudent(list); break; case \"3\": //System.out.println(\"修改学生\"); updateStudent(list); break; case \"4\": // System.out.println(\"查看学生\"); queryStudents(list); break; case \"5\": System.out.println(\"感谢您的使用\"); break lo; default: System.out.println(\"您的输入有误\"); break; &#125; &#125; &#125; // 修改学生的方法 public static void updateStudent(ArrayList&lt;Student&gt; list) &#123; System.out.println(\"请输入您要修改的学生学号:\"); Scanner sc = new Scanner(System.in); String updateSid = sc.next(); // 3. 调用getIndex方法, 查找该学号在集合中出现的索引位置 int index = getIndex(list,updateSid); // 4. 根据索引判断, 学号在集合中是否存在 if(index == -1)&#123; // 不存在: 给出提示 System.out.println(\"查无信息, 请重新输入\"); &#125;else&#123; // 存在: 接收新的学生信息 System.out.println(\"请输入新的学生姓名:\"); String name = sc.next(); System.out.println(\"请输入新的学生年龄:\"); int age = sc.nextInt(); System.out.println(\"请输入新的学生生日:\"); String birthday = sc.next(); // 封装为新的学生对象 Student stu = new Student(updateSid, name, age, birthday); // 调用集合的set方法, 完成修改 list.set(index, stu); System.out.println(\"修改成功!\"); &#125; &#125; // 删除学生的方法 public static void deleteStudent(ArrayList&lt;Student&gt; list) &#123; // 1. 给出提示信息 (请输入您要删除的学号) System.out.println(\"请输入您要删除的学生学号:\"); // 2. 键盘接收要删除的学号 Scanner sc = new Scanner(System.in); String deleteSid = sc.next(); // 3. 调用getIndex方法, 查找该学号在集合中出现的索引位置 int index = getIndex(list,deleteSid); // 4. 根据索引判断, 学号在集合中是否存在 if(index == -1)&#123; // 不存在: 给出提示 System.out.println(\"查无信息, 请重新输入\"); &#125;else&#123; // 存在:删除 list.remove(index); System.out.println(\"删除成功!\"); &#125; &#125; // 查看学生的方法 public static void queryStudents(ArrayList&lt;Student&gt; list) &#123; // 1. 判断集合中是否存在数据, 如果不存在直接给出提示 if(list.size() == 0)&#123; System.out.println(\"无信息, 请添加后重新查询\"); return; &#125; // 2. 存在: 展示表头数据 System.out.println(\"学号\\t\\t姓名\\t年龄\\t生日\"); // 3. 遍历集合, 获取每一个学生对象的信息, 打印在控制台 for (int i = 0; i &lt; list.size(); i++) &#123; Student stu = list.get(i); System.out.println(stu.getSid() + \"\\t\" + stu.getName() + \"\\t\" + stu.getAge() + \"\\t\\t\" + stu.getBirthday()); &#125; &#125; // 添加学生的方法 public static void addStudent(ArrayList&lt;Student&gt; list) &#123; Scanner sc = new Scanner(System.in); // 1. 给出录入的提示信息 String sid; while(true)&#123; System.out.println(\"请输入学号:\"); sid = sc.next(); int index = getIndex(list, sid); if(index == -1)&#123; // sid不存在, 学号可以使用 break; &#125; &#125; System.out.println(\"请输入姓名:\"); String name = sc.next(); System.out.println(\"请输入年龄:\"); int age = sc.nextInt(); System.out.println(\"请输入生日:\"); String birthday = sc.next(); // 2. 将键盘录入的信息封装为学生对象 Student stu = new Student(sid,name,age,birthday); // 3. 将封装好的学生对象, 添加到集合容器当中 list.add(stu); // 4. 给出添加成功的提示信息 System.out.println(\"添加成功!\"); &#125; /* getIndex : 接收一个集合对象, 接收一个学生学号 查找这个学号, 在集合中出现的索引位置 */ public static int getIndex(ArrayList&lt;Student&gt; list, String sid)&#123; // 1. 假设传入的学号, 在集合中不存在 int index = -1; // 2. 遍历集合, 获取每一个学生对象, 准备进行查找 for (int i = 0; i &lt; list.size(); i++) &#123; Student stu = list.get(i); // 3. 获取每一个学生对象的学号 String id = stu.getSid(); // 4. 使用获取出的学生学号, 和传入的学号(查找的学号)进行比对 if(id.equals(sid))&#123; // 存在: 让index变量记录正确的索引位置 index = i; &#125; &#125; return index; &#125;&#125;","categories":[],"tags":[]},{"title":"8_API","slug":"8_API","date":"2020-11-04T14:41:55.500Z","updated":"2020-11-04T14:42:15.237Z","comments":true,"path":"2020/11/04/8_API/","link":"","permalink":"http://xiaojujing.com/2020/11/04/8_API/","excerpt":"1.API1.1 API概述-帮助文档的使用 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API","text":"1.API1.1 API概述-帮助文档的使用 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API ​ 指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。 如何使用API帮助文档 : 打开帮助文档 找到索引选项卡中的输入框 在输入框中输入Random 看类在哪个包下 看类的描述 看构造方法 看成员方法 1.2 键盘录入字符串Scanner类 : ​ next() : 遇到了空格, 就不再录入数据了 , 结束标记: 空格, tab键 ​ nextLine() : 可以将数据完整的接收过来 , 结束标记: 回车换行符 代码实现 : 12345678910111213141516171819202122232425package com.itheima.api;import java.util.Scanner;public class Demo1Scanner &#123; /* next() : 遇到了空格, 就不再录入数据了 结束标记: 空格, tab键 nextLine() : 可以将数据完整的接收过来 结束标记: 回车换行符 */ public static void main(String[] args) &#123; // 1. 创建Scanner对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); // 2. 调用nextLine方法接收字符串 // ctrl + alt + v : 快速生成方法的返回值 String s = sc.nextLine(); System.out.println(s); &#125;&#125; 12345678910111213141516171819202122package com.itheima.api;import java.util.Scanner;public class Demo2Scanner &#123; /* nextInt和nextLine方法配合使用的时候, nextLine方法就没有键盘录入的机会了 建议: 今后键盘录入数据的时候, 如果是字符串和整数一起接受, 建议使用next方法接受字符串. */ public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入整数:\"); int num = sc.nextInt(); // 10 + 回车换行 System.out.println(\"请输入字符串:\"); String s = sc.nextLine(); System.out.println(num); System.out.println(s); &#125;&#125; 2. String类2.1 String概述​ 1 String 类在 java.lang 包下，所以使用的时候不需要导包 ​ 2 String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象 ​ 3 字符串不可变，它们的值在创建后不能被更改 2.2 String类的构造方法常用的构造方法 示例代码 1234567891011121314151617181920212223242526272829303132package com.itheima.string;public class Demo2StringConstructor &#123; /* String类常见构造方法: public String() : 创建一个空白字符串对象，不含有任何内容 public String(char[] chs) : 根据字符数组的内容，来创建字符串对象 public String(String original) : 根据传入的字符串内容，来创建字符串对象 String s = “abc”; 直接赋值的方式创建字符串对象，内容就是abc 注意: String这个类比较特殊, 打印其对象名的时候, 不会出现内存地址 而是该对象所记录的真实内容. 面向对象-继承, Object类 */ public static void main(String[] args) &#123; // public String() : 创建一个空白字符串对象，不含有任何内容 String s1 = new String(); System.out.println(s1); // public String(char[] chs) : 根据字符数组的内容，来创建字符串对象 char[] chs = &#123;'a','b','c'&#125;; String s2 = new String(chs); System.out.println(s2); // public String(String original) : 根据传入的字符串内容，来创建字符串对象 String s3 = new String(\"123\"); System.out.println(s3); &#125;&#125; 2.4 创建字符串对象的区别对比 通过构造方法创建 ​ 通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同 直接赋值方式创建 ​ 以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护 2.5 字符串的比较2.5.1 字符串的比较 == 比较基本数据类型：比较的是具体的值 == 比较引用数据类型：比较的是对象地址值 String类 : public boolean equals(String s) 比较两个字符串内容是否相同、区分大小写 代码 : 12345678910111213141516package com.itheima.stringmethod;public class Demo1Equals &#123; public static void main(String[] args) &#123; String s1 = \"abc\"; String s2 = \"ABC\"; String s3 = \"abc\"; // equals : 比较字符串内容, 区分大小写 System.out.println(s1.equals(s2)); System.out.println(s1.equals(s3)); // equalsIgnoreCase : 比较字符串内容, 忽略大小写 System.out.println(s1.equalsIgnoreCase(s2)); &#125;&#125; 2.6 用户登录案例【应用】案例需求 : ​ 已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示 *实现步骤 : * 已知用户名和密码，定义两个字符串表示即可 键盘录入要登录的用户名和密码，用 Scanner 实现 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。 字符串的内容比较，用equals() 方法实现 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循 代码实现 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.itheima.test;import java.util.Scanner;public class Test1 &#123; /* 需求：已知用户名和密码，请用程序实现模拟用户登录。 总共给三次机会，登录之后，给出相应的提示 思路： 1. 已知用户名和密码，定义两个字符串表示即可 2. 键盘录入要登录的用户名和密码，用 Scanner 实现 3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。 字符串的内容比较，用equals() 方法实现 4. 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环 */ public static void main(String[] args) &#123; // 1. 已知用户名和密码，定义两个字符串表示即可 String username = \"admin\"; String password = \"123456\"; // 2. 键盘录入要登录的用户名和密码，用 Scanner 实现 Scanner sc = new Scanner(System.in); // 4. 用循环实现多次机会，这里的次数明确，采用for循环实现 for(int i = 1; i &lt;= 3; i++)&#123; System.out.println(\"请输入用户名:\"); String scUsername = sc.nextLine(); System.out.println(\"请输入密码:\"); String scPassword = sc.nextLine(); // 3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。 if(username.equals(scUsername) &amp;&amp; password.equals(scPassword))&#123; System.out.println(\"登录成功\"); break; &#125;else&#123; if(i == 3)&#123; System.out.println(\"您的登录次数已达到今日上限, 请明天再来\"); &#125;else&#123; System.out.println(\"登录失败,您还剩余\" + (3-i) +\"次机会\"); &#125; &#125; &#125; &#125;&#125; 2.7 遍历字符串案例【应用】案例需求 : ​ 键盘录入一个字符串，使用程序实现在控制台遍历该字符串 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 遍历字符串，首先要能够获取到字符串中的每一个字符, public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的 遍历字符串，其次要能够获取到字符串的长度, public int length()：返回此字符串的长度 遍历打印 代码实现 : 123456789101112131415161718192021222324252627282930package com.itheima.test;import java.util.Scanner;public class Test2 &#123; /* 需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 遍历字符串，首先要能够获取到字符串中的每一个字符 public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的 3. 遍历字符串，其次要能够获取到字符串的长度 public int length()：返回此字符串的长度 4. 遍历打印9 */ public static void main(String[] args) &#123; // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 遍历字符串，首先要能够获取到字符串中的每一个字符 for(int i = 0; i &lt; s.length(); i++)&#123; // i : 字符串的每一个索引 char c = s.charAt(i); System.out.println(c); &#125; &#125;&#125; 2.8 统计字符次数案例【应用】案例需求 : ​ 键盘录入一个字符串，使用程序实现在控制台遍历该字符串 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 将字符串拆分为字符数组 , public char[] toCharArray( )：将当前字符串拆分为字符数组并返回 遍历字符数 代码实现 : 12345678910111213141516171819202122232425262728package com.itheima.test;import java.util.Scanner;public class Test3 &#123; /* 需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 将字符串拆分为字符数组 public char[] toCharArray( )：将当前字符串拆分为字符数组并返回 3. 遍历字符数组 */ public static void main(String[] args) &#123; // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 将字符串拆分为字符数组 char[] chars = s.toCharArray(); // 3. 遍历字符数组 for (int i = 0; i &lt; chars.length; i++) &#123; System.out.println(chars[i]); &#125; &#125;&#125; 2.9 手机号屏蔽-字符串截取案例需求 : ​ 以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽 1最终效果为：156****1234 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 截取字符串前三位 截取字符串后四位 将截取后的两个字符串，中间加上****进行拼接，输出结果 代码实现 : 1234567891011121314151617181920212223242526272829package com.itheima.test;import java.util.Scanner;public class Test5 &#123; /* 需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽 最终效果为：156****1234 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 截取字符串前三位 3. 截取字符串后四位 4. 将截取后的两个字符串，中间加上****进行拼接，输出结果 */ public static void main(String[] args) &#123; // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入手机号:\"); String telString = sc.nextLine(); // 2. 截取字符串前三位 String start = telString.substring(0,3); // 3. 截取字符串后四位 String end = telString.substring(7); // 4. 将截取后的两个字符串，中间加上****进行拼接，输出结果 System.out.println(start + \"****\" + end); &#125;&#125; 2.10 敏感词替换-字符串替换案例需求 : ​ 键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 替换敏感词 12String replace(CharSequence target, CharSequence replacement)将当前字符串中的target内容，使用replacement进行替换，返回新的字符串 输出结果 代码实现 : 123456789101112131415161718192021222324252627package com.itheima.test;import java.util.Scanner;public class Test6 &#123; /* 需求：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 替换敏感词 String replace(CharSequence target, CharSequence replacement) 将当前字符串中的target内容，使用replacement进行替换，返回新的字符串 3. 输出结果 */ public static void main(String[] args) &#123; // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 替换敏感词 String result = s.replace(\"TMD\",\"***\"); // 3. 输出结果 System.out.println(result); &#125;&#125; 2.11 切割字符串案例需求 : ​ 以字符串的形式从键盘录入学生信息，例如：“张三 , 23” ​ 从该字符串中切割出有效数据,封装为Student学生对象 实现步骤 : 编写Student类，用于封装数据 键盘录入一个字符串，用 Scanner 实现 根据逗号切割字符串，得到（张三）（23） String[] split(String regex) ：根据传入的字符串作为规则进行切割将切割后的内容存入字符串数组中，并将字符串数组返回 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 调用对象getXxx方法，取出数据并打印。 代码实现 : 123456789101112131415161718192021222324252627282930313233343536373839package com.itheima.test;import com.itheima.domain.Student;import java.util.Scanner;public class Test7 &#123; /* 需求：以字符串的形式从键盘录入学生信息，例如：“张三 , 23” 从该字符串中切割出有效数据,封装为Student学生对象 思路： 1. 编写Student类，用于封装数据 2. 键盘录入一个字符串，用 Scanner 实现 3. 根据逗号切割字符串，得到（张三）（23） String[] split(String regex) ：根据传入的字符串作为规则进行切割 将切割后的内容存入字符串数组中，并将字符串数组返回 4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 5. 调用对象getXxx方法，取出数据并打印。 */ public static void main(String[] args) &#123; // 2. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入学生信息:\"); String stuInfo = sc.nextLine(); // stuInfo = \"张三,23\"; // 3. 根据逗号切割字符串，得到（张三）（23） String[] sArr = stuInfo.split(\",\");// System.out.println(sArr[0]);// System.out.println(sArr[1]); // 4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 Student stu = new Student(sArr[0],sArr[1]); // 5. 调用对象getXxx方法，取出数据并打印。 System.out.println(stu.getName() + \"...\" + stu.getAge()); &#125;&#125; 2.12 String方法小结String类的常用方法 : ​ public boolean equals(Object anObject) 比较字符串的内容，严格区分大小写 ​ public boolean equalsIgnoreCase(String anotherString) 比较字符串的内容，忽略大小写 ​ public int length() 返回此字符串的长度 ​ public char charAt(int index) 返回指定索引处的 char 值 ​ public char[] toCharArray() 将字符串拆分为字符数组后返回 ​ public String substring(int beginIndex, int endIndex) 根据开始和结束索引进行截取，得到新的字符串（包含头，不包含尾） ​ public String substring(int beginIndex) 从传入的索引处截取，截取到末尾，得到新的字符串 ​ public String replace(CharSequence target, CharSequence replacement) 使用新值，将字符串中的旧值替换，得到新的字符串 ​ public String[] split(String regex) 根据传入的规则切割字符串，得到字符串数组 3 StringBuilder类3.1 StringBuilder类概述​ 概述 : StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的 3.2 StringBuilder类和String类的区别 String类：内容是不可变的 StringBuilder类：内容是可变的 3.3StringBuilder类的构造方法常用的构造方法 方法名 说明 public StringBuilder() 创建一个空白可变字符串对象，不含有任何内容 public StringBuilder(String str) 根据字符串的内容，来创建可变字符串对象 示例代码 12345678910111213public class StringBuilderDemo01 &#123; public static void main(String[] args) &#123; //public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容 StringBuilder sb = new StringBuilder(); System.out.println(\"sb:\" + sb); System.out.println(\"sb.length():\" + sb.length()); //public StringBuilder(String str)：根据字符串的内容，来创建可变字符串对象 StringBuilder sb2 = new StringBuilder(\"hello\"); System.out.println(\"sb2:\" + sb2); System.out.println(\"sb2.length():\" + sb2.length()); &#125;&#125; 3.4 StringBuilder常用的成员方法 添加和反转方法 方法名 说明 public StringBuilder append(任意类型) 添加数据，并返回对象本身 public StringBuilder reverse() 返回相反的字符序列 示例代码 123456789101112131415161718192021222324252627public class StringBuilderDemo01 &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder sb = new StringBuilder(); //public StringBuilder append(任意类型)：添加数据，并返回对象本身// StringBuilder sb2 = sb.append(\"hello\");//// System.out.println(\"sb:\" + sb);// System.out.println(\"sb2:\" + sb2);// System.out.println(sb == sb2);// sb.append(\"hello\");// sb.append(\"world\");// sb.append(\"java\");// sb.append(100); //链式编程 sb.append(\"hello\").append(\"world\").append(\"java\").append(100); System.out.println(\"sb:\" + sb); //public StringBuilder reverse()：返回相反的字符序列 sb.reverse(); System.out.println(\"sb:\" + sb); &#125;&#125; 3.5StringBuilder和String相互转换【应用】 StringBuilder转换为String ​ public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String String转换为StringBuilder ​ public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder 示例代码 12345678910111213141516171819202122232425public class StringBuilderDemo02 &#123; public static void main(String[] args) &#123; /* //StringBuilder 转换为 String StringBuilder sb = new StringBuilder(); sb.append(\"hello\"); //String s = sb; //这个是错误的做法 //public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String String s = sb.toString(); System.out.println(s); */ //String 转换为 StringBuilder String s = \"hello\"; //StringBuilder sb = s; //这个是错误的做法 //public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder StringBuilder sb = new StringBuilder(s); System.out.println(sb); &#125;&#125; 3.6 StringBuilder拼接字符串案例案例需求 : ​ 定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法， ​ 并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3] 实现步骤 : 定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。 1返回值类型 String，参数列表 int[] arr 在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 调用方法，用一个变量接收结果 输出结果 代码实现 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 思路： 1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。 返回值类型 String，参数列表 int[] arr 3:在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 4:调用方法，用一个变量接收结果 5:输出结果 */public class StringBuilderTest01 &#123; public static void main(String[] args) &#123; //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 int[] arr = &#123;1, 2, 3&#125;; //调用方法，用一个变量接收结果 String s = arrayToString(arr); //输出结果 System.out.println(\"s:\" + s); &#125; //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回 /* 两个明确： 返回值类型：String 参数：int[] arr */ public static String arrayToString(int[] arr) &#123; //在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for(int i=0; i&lt;arr.length; i++) &#123; if(i == arr.length-1) &#123; sb.append(arr[i]); &#125; else &#123; sb.append(arr[i]).append(\", \"); &#125; &#125; sb.append(\"]\"); String s = sb.toString(); return s; &#125;&#125;键盘录入一个字符串,将其中的大写转成小写,小写转大写,数字不变,其他字符变成*;","categories":[],"tags":[]},{"title":"7_类和对象","slug":"7_类和对象","date":"2020-11-04T14:41:16.824Z","updated":"2020-11-04T14:42:25.063Z","comments":true,"path":"2020/11/04/7_类和对象/","link":"","permalink":"http://xiaojujing.com/2020/11/04/7_%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"1. 类和对象*面向对象和面向过程的思想对比 : * ​ 面向过程 ：是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的 ​ 面向对象 ：是一种以对象为中心的编程思想，通过指挥对象实现具体的功能","text":"1. 类和对象*面向对象和面向过程的思想对比 : * ​ 面向过程 ：是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的 ​ 面向对象 ：是一种以对象为中心的编程思想，通过指挥对象实现具体的功能 1.1 类和对象的关系客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。 类 类的理解 类是对现实生活中一类具有共同属性和行为的事物的抽象 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合 简单理解：类就是对现实事物的一种描述 类的组成 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸） 行为：指事物能执行的操作，例如：手机事物（打电话，发短信） 类和对象的关系 类：类是对现实生活中一类具有共同属性和行为的事物的抽象 对象：是能够看得到摸的着的真实存在的实体 简单理解：类是对事物的一种描述，对象则为具体存在的事物 1.2 类的定义【应用】类的组成是由属性和行为两部分组成 属性：在类中通过成员变量来体现（类中方法外的变量） 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可） 类的定义步骤： ​ ① 定义类 ​ ② 编写类的成员变量 ​ ③ 编写类的成员方法 123456789101112public class Student &#123; // 属性 : 姓名, 年龄 // 成员变量: 跟之前定义变量的格式一样, 只不过位置发生了改变, 类中方法外 String name; int age; // 行为 : 学习 // 成员方法: 跟之前定义方法的格式一样, 只不过去掉了static关键字. public void study()&#123; System.out.println(\"学习\"); &#125;&#125; 1.3 对象的创建和使用 创建对象的格式： 类名 对象名 = new 类名(); 调用成员的格式： 对象名.成员变量 对象名.成员方法(); *示例代码 : * 1234567891011121314151617181920212223242526272829303132package com.itheima.object1;public class TestStudent &#123; /* 创建对象的格式: 类名 对象名 = new 类名(); 调用成员变量的格式: 对象名.变量名 调用成员方法的格式: 对象名.方法名(); */ public static void main(String[] args) &#123; // 类名 对象名 = new 类名(); Student stu = new Student(); // 对象名.变量名 // 默认初始化值 System.out.println(stu.name); // null System.out.println(stu.age); // 0 stu.name = \"张三\"; stu.age = 23; System.out.println(stu.name); // 张三 System.out.println(stu.age); // 23 // 对象名.方法名(); stu.study(); // com.itheima.object1.Student@b4c966a // 全类名(包名 + 类名) System.out.println(stu); &#125;&#125; 1.4 案例-手机类的创建和使用需求 ：首先定义一个手机类，然后定义一个手机测试类，在手机测试类中通过对象完成成员变量和成员方法的使用 分析 ： 成员变量：品牌, 价格 成员方法：打电话, 发短信 示例代码： 12345678910111213141516package com.itheima.test1;public class Phone &#123; // 品牌, 价格 String brand; int price; // 打电话, 发短信 public void call(String name)&#123; System.out.println(\"给\"+name+\"打电话\"); &#125; public void sendMessage()&#123; System.out.println(\"群发短信\"); &#125;&#125; 12345678910111213141516package com.itheima.test1;public class TestPhone &#123; public static void main(String[] args) &#123; // 1. 创建对象 Phone p = new Phone(); // 2. 给成员变量进行赋值 p.brand = \"大米\"; p.price = 2999; // 3. 打印赋值后的成员变量 System.out.println(p.brand + \"...\" + p.price); // 4. 调用成员方法 p.call(\"阿强\"); p.sendMessage(); &#125;&#125; 2. 对象内存图2.1 单个对象内存图【理解】 2.2 多个对象内存图【理解】 总结： 多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份 2.3 多个对象指向相同内存图【理解】 总结 : 当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的） 只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。 3. 成员变量和局部变量3.1 成员变量和局部变量的区别 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上） 内存中位置不同：成员变量（堆内存）局部变量（栈内存） 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失） 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用） 4. 封装4.1 private关键字​ 概述 : private是一个修饰符，可以用来修饰成员（成员变量，成员方法） ​ 特点 : 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用， 提供相应的操作 ​ 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰 ​ 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰 ​ 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940/* 学生类 */class Student &#123; //成员变量 String name; private int age; //提供get/set方法 public void setAge(int a) &#123; if(a&lt;0 || a&gt;120) &#123; System.out.println(\"你给的年龄有误\"); &#125; else &#123; age = a; &#125; &#125; public int getAge() &#123; return age; &#125; //成员方法 public void show() &#123; System.out.println(name + \",\" + age); &#125;&#125;/* 学生测试类 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); //给成员变量赋值 s.name = \"林青霞\"; s.setAge(30); //调用show方法 s.show(); &#125;&#125; 4.2 private关键字的使用 需求： 定义标准的学生类，要求name和age使用private修饰 并提供set和get方法以及便于显示数据的show方法 测试类中创建对象并使用，最终控制台输出 林青霞，30 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 学生类 */class Student &#123; //成员变量 private String name; private int age; //get/set方法 public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125; public void show() &#123; System.out.println(name + \",\" + age); &#125;&#125;/* 学生测试类 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); //使用set方法给成员变量赋值 s.setName(\"林青霞\"); s.setAge(30); s.show(); //使用get方法获取成员变量的值 System.out.println(s.getName() + \"---\" + s.getAge()); System.out.println(s.getName() + \",\" + s.getAge()); &#125;&#125; 4.3 this关键字【应用】概述 : this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题） 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量 代码实现 : 123456789101112131415161718192021222324public class Student &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void show() &#123; System.out.println(name + \",\" + age); &#125;&#125; 4.4 this内存原理【理解】 注意 : this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象 图解 ： 4.5 封装思想 封装概述 是面向对象三大特征之一（封装，继承，多态） 是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的 封装原则 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法 封装好处 通过方法来控制成员变量的操作，提高了代码的安全性 把代码用方法进行封装，提高了代码的复用性 5. 构造方法5.1 构造方法的格式和执行时机 格式注意 : 方法名与类名相同，大小写也要一致 没有返回值类型，连void都没有 没有具体的返回值（不能由retrun带回结果数据） 执行时机 ： 创建对象的时候调用，每创建一次对象，就会执行一次构造方法 不能手动调用构造方法 示例代码： 1234567891011121314151617181920212223class Student &#123; private String name; private int age; //构造方法 public Student() &#123; System.out.println(\"无参构造方法\"); &#125; public void show() &#123; System.out.println(name + \",\" + age); &#125;&#125;/* 测试类 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); s.show(); &#125;&#125; 5.2 构造方法的作用 用于给对象的数据（属性）进行初始化 12345678910111213141516171819202122232425262728package com.itheima.constructor;public class Student &#123; /* 格式: 1. 方法名需要跟类名相同, 大小写也要一致 2. 没有返回值类型, 连void都没有 3. 没有具体的返回值(不能由return带回具体的结果) */ private String name; private int age; // 1. 如果一个类中没有编写任何构造方法, 系统将会提供一个默认的无参数构造方法 public Student()&#123;&#125; // 2. 如果手动编写了构造方法, 系统就不会再提供默认的无参数构造方法了 public Student(String name, int age)&#123; this.name = name; this.age = age; System.out.println(\"我是Student类的构造方法\"); &#125; public void show()&#123; System.out.println(name + \"...\" + age); &#125;&#125; 12345678910package com.itheima.constructor;public class TestStudent &#123; public static void main(String[] args) &#123; Student stu1 = new Student(\"张三\",23); stu1.show(); Student stu2 = new Student(); &#125;&#125; 5.3 构造方法的注意事项构造方法的创建 : ​ 如果没有定义构造方法，系统将给出一个默认的无参数构造方法 ​ 如果定义了构造方法，系统将不再提供默认的构造方法 构造方法的创建 : ​ 如果没有定义构造方法，系统将给出一个默认的无参数构造方法如果定义了构造方法，系统将不再提供默认的构造方法 推荐的使用方式 : ​ 无论是否使用，都手动书写无参数构造方法，和带参数构造方法 5.4 标准类的代码编写和使用代码 : 12345678910111213141516171819202122232425262728293031323334353637package com.itheima.test3;/* JavaBean类: 封装数据 */public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void show()&#123; System.out.println(name + \"...\" + age); &#125;&#125; 123456789101112131415package com.itheima.test3;public class TestStudent &#123; public static void main(String[] args) &#123; // 1. 无参数构造方法创建对象, 通过setXxx方法给成员变量进行赋值 Student stu1 = new Student(); stu1.setName(\"张三\"); stu1.setAge(23); stu1.show(); // 2. 通过带参数构造方法, 直接给属性进行赋值 Student stu2 = new Student(\"李四\",24); stu2.show(); &#125;&#125;","categories":[],"tags":[]},{"title":"6_Debug模式","slug":"6_Debug模式","date":"2020-11-03T15:15:30.312Z","updated":"2020-11-05T07:57:09.189Z","comments":true,"path":"2020/11/03/6_Debug模式/","link":"","permalink":"http://xiaojujing.com/2020/11/03/6_Debug%E6%A8%A1%E5%BC%8F/","excerpt":"1.Debug模式1.1 什么是Debug模式是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。","text":"1.Debug模式1.1 什么是Debug模式是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。 1.2 Debug介绍与操作流程 如何加断点 选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可 如何运行加了断点的程序 在代码区域右键Debug执行 看哪里 看Debugger窗口 看Console窗口 点哪里 点Step Into (F7)这个箭头，也可以直接按F7 如何删除断点 选择要删除的断点，单击鼠标左键即可 如果是多个断点，可以每一个再点击一次。也可以一次性全部删除 2. 进制的介绍与书写格式2.1 进制的介绍与书写格式几进制,就是逢几进1,借1当几 二进制:组成 0 , 1 八进制:组成: 0 - 7 十六进制 组成: 0-9 a-f 代码 : 12345678910111213141516public class Demo1 &#123; /* 十进制：Java中，数值默认都是10进制，不需要加任何修饰。 二进制：数值前面以0b开头，b大小写都可以。 八进制：数值前面以0开头。 十六进制：数值前面以0x开头，x大小写都可以。 注意: 书写的时候, 虽然加入了进制的标识, 但打印在控制台展示的都是十进制数据. */ public static void main(String[] args) &#123; System.out.println(10); System.out.println(\"二进制数据0b10的十进制表示为:\" + 0b10); System.out.println(\"八进制数据010的十进制表示为:\" + 010); System.out.println(\"十六进制数据0x10的十进制表示为:\" + 0x10); &#125;&#125; 2.2 任意进制到十进制的转换 2.3 进制转换-十进制到任意进制转换​ 2.3.1 : 十进制到二进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到 0 ，再将余数倒着拼起来即可。 ​ 需求：将十进制数字11，转换为2进制。 ​ 实现方式：源数据为11，使用11不断的除以基数，也就是2，直到商为0。 ​ 2.3.2 : 十进制到十六进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。 ​ 需求：将十进制数字60，转换为16进制。 ​ 实现方式：源数据为60，使用60不断的除以基数，也就是16，直到商为0。 ​ 结论：十进制到任意进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着 拼起来即可 2.4 快速进制转换法​ 8421码： ​ 8421码又称BCD码，是BCD代码中最常用的一种BCD： (Binary-Coded Decimal‎) 二进制码十进制数在这种编码方式中，每一位二进制值的1都是代表一个固定数值，把每一位的1代表的十进制数加起来得到的结果就是它所代表的十进制数。 ​ 2.5 原码反码补码前言 : 计算机中的数据，都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的 *原码 *:（可直观看出数据大小） 原码是看数据大小的,反码就是一个原码和补码的一个桥梁,补码是运算的时候存在的. 正数的原,反,补都一样. 负数的反码是符号位不变,其他位取反.从左到右第一个数符号位,0表示正数,1表示负数. 补码就是反码+1; 就是二进制定点表示法，即最高位为符号位，【0】表示正，【1】表示负，其余位表示数值的大小。 通过一个字节表示+7和-7，代码：byte b1 = 7; byte b2 = -7;一个字节等于8个比特位，也就是8个二进制位 0(符号位) 0000111 1(符号位) 0000111 反码 : 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码 : （数据以该状态进行运算）正数的补码与其原码相同；负数的补码是在其反码的末位加1。 2.6 位运算-基本位运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima.demo;public class Demo2 &#123; /* 位运算: 位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。 在二进制位运算中，1表示true，0表示false。 &amp; 位与 : 遇false则false, 遇0则0 00000000 00000000 00000000 00000110 // 6的二进制 &amp; 00000000 00000000 00000000 00000010 // 2的二进制 ----------------------------------------- 00000000 00000000 00000000 00000010 // 结果: 2 | 位或 : 遇true则true, 遇1则1 ^ 位异或 : 相同为false, 不同为true ~ 取反 : 全部取反, 0变1, 1变0 (也包括符号位) 00000000 00000000 00000000 00000110 // 6的二进制补码 ~ 11111111 11111111 11111111 11111001 - 1 // -1求反码 ------------------------------------ 11111111 11111111 11111111 11111000 // 反码推原码 10000000 00000000 00000000 00000111 // -7 */ public static void main(String[] args) &#123; System.out.println(6 &amp; 2); System.out.println(~6); &#125;&#125;一个数和另一个数异或两次 得到的是这个数本身因为一个数异或两次之后 每个二进制位都相同 所以都是false 是0一个数和0异或得到的是这个数本身 0和1异的到的1 0和0异或 0 正数的原反补都一样,原码是看数据大小的,反码就是转换,补码是计算机运算的时候用原码 反码补码 +1原码---&gt;反码(符号位不变,其余为全部取反)---&gt;补码 -1补码---&gt;反码---&gt;原码(符号位不变,其余位全部取反) 2.7 位运算-位移运算符位运算概述 : 位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。在二进制位运算中，1表示true，0表示false。 位运算符介绍 : 代码 : 1234567891011121314151617181920212223242526272829303132package com.itheima.demo;public class Demo3 &#123; /* 位移运算符: &lt;&lt; 有符号左移运算，二进制位向左移动, 左边符号位丢弃, 右边补齐0 运算规律: 向左移动几位, 就是乘以2的几次幂 12 &lt;&lt; 2 (0)0000000 00000000 00000000 000011000 // 12的二进制 ----------------------------------------------------------------------------- &gt;&gt; 有符号右移运算，二进制位向右移动, 使用符号位进行补位 运算规律: 向右移动几位, 就是除以2的几次幂 000000000 00000000 00000000 0000001(1) // 3的二进制 ----------------------------------------------------------------------------- &gt;&gt;&gt; 无符号右移运算符, 无论符号位是0还是1，都补0 010000000 00000000 00000000 00000110 // -6的二进制 */ public static void main(String[] args) &#123; System.out.println(12 &lt;&lt; 1); // 24 System.out.println(12 &lt;&lt; 2); // 48 &#125;&#125; 123456789101112package com.itheima.demo;public class Demo4 &#123; /* ^ 运算符的特点 一个数, 被另外一个数, 异或两次, 该数本身不变 */ public static void main(String[] args) &#123; System.out.println(10 ^ 5 ^ 10); &#125;&#125; 3.基础练习3.1 数据交换案例需求 ​ 已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换 1最终输出a &#x3D; 20，b &#x3D; 10; 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.itheima.test;public class Test1 &#123; /* 需求：已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换 最终输出a = 20，b = 10; 思路： 1. 定义一个三方变量temp，将a原本记录的值，交给temp记录 （a的值，不会丢了） 2. 使用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了） 3. 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕） 4. 输出 a 和 b 变量即可 */ /* 动态初始化格式： 数据类型[][] 变量名 = new 数据类型[m][n]; m表示这个二维数组，可以存放多少个一维数组 n表示每一个一维数组，可以存放多少个元素 */ public static void main(String[] args) &#123; int a = 10; int b = 20; // 将a原本记录的值，交给temp记录 （a的值，不会丢了） int temp = a; // 用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了） a = b; // 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕） b = temp; // 输出 a 和 b 变量即可 System.out.println(\"a=\" + a); System.out.println(\"b=\" + b); &#125;&#125;public class Demo1 &#123; public static void main(String[] args) &#123; /*int a = 10; int b = 20; int temp = b; b = a; a = temp;*/ int a = 10; int b = 20; a = a^b; //我们不用计算 b= a^b; //b = a^b^b b=a a = a^b; //a = a^b^a a=b System.out.println(a); System.out.println(b); &#125;&#125; 3.2 数组反转【应用】案例需求 : ​ 已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换， ​ 交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素 实现步骤 : 定义两个变量, start和end来表示开始和结束的指针. 确定交换条件, start &lt; end 允许交换 循环中编写交换逻辑代码 每一次交换完成, 改变两个指针所指向的索引 start++, end– 循环结束后, 遍历数组并打印, 查看反转后的数组 代码实现 : 12345678910111213141516171819202122232425262728293031323334package com.itheima.test;public class Test2 &#123; /* 需求：已知一个数组 arr = &#123;19, 28, 37, 46, 50&#125;; 用程序实现把数组中的元素值交换， 交换后的数组 arr = &#123;50, 46, 37, 28, 19&#125;; 并在控制台输出交换后的数组元素。 步骤: 1. 定义两个变量, start和end来表示开始和结束的指针. 2. 确定交换条件, start &lt; end 允许交换 3. 循环中编写交换逻辑代码 4. 每一次交换完成, 改变两个指针所指向的索引 start++, end-- 5. 循环结束后, 遍历数组并打印, 查看反转后的数组 */ public static void main(String[] args) &#123; int[] arr = &#123;19, 28, 37, 46, 50&#125;; // 1. 定义两个变量, start和end来表示开始和结束的指针. int start = 0; int end = arr.length -1; // 2. 确定交换条件, start &lt; end 允许交换 // 4. 每一次交换完成, 改变两个指针所指向的索引 start++, end-- // for(int start = 0, end = arr.length -1; start &lt; end; start++, end--) for( ; start &lt; end; start++, end--)&#123; // 3. 循环中编写交换逻辑代码 int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 3.3 二维数组概述​ 概述 : 二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器 3.4 二维数组动态初始化12345动态初始化格式：数据类型[][] 变量名 = new 数据类型[m][n];m表示这个二维数组，可以存放多少个一维数组,一维数组的个数n表示每一个一维数组，可以存放多少个元素,一个数组存储元素的个数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.demo;public class Demo1Array &#123; /* 动态初始化格式： 数据类型[][] 变量名 = new 数据类型[m][n]; m表示这个二维数组，可以存放多少个一维数组 n表示每一个一维数组，可以存放多少个元素 */ public static void main(String[] args) &#123; // 数据类型[][] 变量名 = new 数据类型[m][n]; int[][] arr = new int[3][3]; /* [[I@10f87f48 @ : 分隔符 10f87f48 : 十六进制内存地址 I : 数组中存储的数据类型 [[ : 几个中括号就代表的是几维数组 */ System.out.println(arr); /* 二维数组存储一维数组的时候, 存储的是一维数组的内存地址 */ System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[0][0]); System.out.println(arr[1][1]); System.out.println(arr[2][2]); // 向二维数组中存储元素 arr[0][0] = 11; arr[0][1] = 22; arr[0][2] = 33; arr[1][0] = 11; arr[1][1] = 22; arr[1][2] = 33; arr[2][0] = 11; arr[2][1] = 22; arr[2][2] = 33; // 从二维数组中取出元素并打印 System.out.println(arr[0][0]); System.out.println(arr[0][1]); System.out.println(arr[0][2]); System.out.println(arr[1][0]); System.out.println(arr[1][1]); System.out.println(arr[1][2]); System.out.println(arr[2][0]); System.out.println(arr[2][1]); System.out.println(arr[2][2]); &#125;&#125; 3.5 二维数组访问元素的细节问题问题 : 二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ? 答 : 可以的 代码实现123456789101112131415161718192021222324package com.itheima.demo;public class Demo2Array &#123; /* 问题: 二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ? 答 : 可以的 */ public static void main(String[] args) &#123; int[] arr1 = &#123;11,22,33&#125;; int[] arr2 = &#123;44,55,66&#125;; int[] arr3 = &#123;77,88,99,100&#125;; int[][] arr = new int[3][3]; arr[2][3] = 100; arr[0] = arr1; arr[1] = arr2; arr[2] = arr3; System.out.println(arr[1][2]); System.out.println(arr[2][3]); &#125;&#125; 3.6 二维数组静态初始化**完整格式 :** 数据类型[][] 变量名 = new 数据类型[][]{ {元素1, 元素2...} , {元素1, 元素2...} **简化格式 :** 数据类型[][] 变量名 = { {元素1, 元素2...} , {元素1, 元素2...} ...};*代码实现 : * 12345678910111213141516171819package com.itheima.demo;public class Demo3Array &#123; /* 完整格式：数据类型[][] 变量名 = new 数据类型[][]&#123; &#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125; ...&#125;; 简化格式: 数据类型[][] 变量名 = &#123; &#123;元素1, 元素2...&#125; , &#123;元素1, 元素2...&#125; ...&#125;; */ public static void main(String[] args) &#123; int[] arr1 = &#123;11,22,33&#125;; int[] arr2 = &#123;44,55,66&#125;; int[][] arr = &#123; &#123;11,22,33&#125;, &#123;44,55,66&#125; &#125;; System.out.println(arr[0][2]); int[][] array = &#123;arr1,arr2&#125;; System.out.println(array[0][2]); &#125;&#125; 3.7 二维数组遍历需求 : ​ 已知一个二维数组 arr = { {11, 22, 33}, {33, 44, 55} }; ​ 遍历该数组，取出所有元素并打印 步骤 : 遍历二维数组，取出里面每一个一维数组 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素 代码实现 : 123456789101112131415161718192021222324252627package com.itheima.test;public class Test1 &#123; /* 需求: 已知一个二维数组 arr = &#123; &#123;11, 22, 33&#125;, &#123;33, 44, 55&#125; &#125;; 遍历该数组，取出所有元素并打印 步骤: 1. 遍历二维数组，取出里面每一个一维数组 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素 */ public static void main(String[] args) &#123; int[][] arr = &#123; &#123;11, 22, 33&#125;, &#123;33, 44, 55&#125; &#125;; // 1. 遍历二维数组，取出里面每一个一维数组 for (int i = 0; i &lt; arr.length; i++) &#123; //System.out.println(arr[i]); // 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素 //int[] temp = arr[i]; for (int j = 0; j &lt; arr[i].length; j++) &#123; System.out.println(arr[i][j]); &#125; &#125; &#125;&#125; 3.8 二维数组求和需求 : 某公司季度和月份统计的数据如下：单位(万元)1234第一季度：22,66,44第二季度：77,33,88第三季度：25,45,65第四季度：11,66,99 步骤 : 定义求和变量，准备记录最终累加结果 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 遍历二维数组，获取所有元素，累加求和 输出最终结果 代码实现 : 1234567891011121314151617181920212223242526272829303132package com.itheima.test;public class Test2 &#123; /* 需求: 某公司季度和月份统计的数据如下：单位(万元) 第一季度：22,66,44 第二季度：77,33,88 第三季度：25,45,65 第四季度：11,66,99 步骤: 1. 定义求和变量，准备记录最终累加结果 2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 3. 遍历二维数组，获取所有元素，累加求和 4. 输出最终结果 */ public static void main(String[] args) &#123; // 1. 定义求和变量，准备记录最终累加结果 int sum = 0; // 2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 int[][] arr = &#123; &#123;22,66,44&#125; , &#123;77,33,88&#125; , &#123;25,45,65&#125; , &#123;11,66,99&#125; &#125;; // 3. 遍历二维数组，获取所有元素，累加求和 for (int i = 0; i &lt; arr.length; i++) &#123; for(int j = 0; j &lt; arr[i].length; j++)&#123; sum += arr[i][j]; &#125; &#125; // 4. 输出最终结果 System.out.println(sum); &#125;&#125;","categories":[],"tags":[]},{"title":"5_方法概述","slug":"5_方法概述","date":"2020-11-03T15:14:41.628Z","updated":"2020-11-03T16:23:02.838Z","comments":true,"path":"2020/11/03/5_方法概述/","link":"","permalink":"http://xiaojujing.com/2020/11/03/5_%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0/","excerpt":"1. 方法概述1.1 方法的概念​ 方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集 封装 注意： 方法必须先创建才可以使用，该过程成为方法定义 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用","text":"1. 方法概述1.1 方法的概念​ 方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集 封装 注意： 方法必须先创建才可以使用，该过程成为方法定义 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用 2. 方法的定义和调用2.1 无参数方法定义和调用 定义格式： 123public static void 方法名 ( ) &#123; // 方法体;&#125; 范例： 123public static void method ( ) &#123; // 方法体;&#125; 调用格式： 1方法名(); 范例： 1method(); 注意： ​ 方法必须先定义，后调用，否则程序将报错 2.2 方法的调用过程 总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。 2.3 方法练习-奇偶数判断 需求：判断一个数是奇数还是偶数 代码： 123456789101112131415161718192021222324252627public class Demo1Method &#123; /* 带参数方法的定义格式: public static void 方法名 ( 参数 ) &#123; … … &#125; public static void 方法名 ( 数据类型 变量名 ) &#123; … … &#125; 带参数方法的调用格式: 方法名 ( 参数 ) ; 方法名 ( 变量名/常量值 ) ; tips: 参数可以是一个, 也可以是多个. 需求: 判断一个数是奇数还是偶数 */ public static void main(String[] args) &#123; isEvenNumber(10); &#125; public static void isEvenNumber(int num)&#123; if(num % 2 == 0)&#123; System.out.println(\"偶数\"); &#125;else&#123; System.out.println(\"奇数\"); &#125; &#125;&#125; 3. 带参数方法的定义和调用3.1 带参数方法定义和调用 定义格式： 参数：由数据类型和变量名组成 - 数据类型 变量名 参数范例：int a 1234567public static void 方法名 (参数1) &#123; 方法体;&#125;public static void 方法名 (参数1, 参数2, 参数3...) &#123; 方法体;&#125; 范例： 123456public static void isEvenNumber(int number)&#123; ...&#125;public static void getMax(int num1, int num2)&#123; ...&#125; 注意： 1方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错 1方法定义时，多个参数之间使用逗号( ，)分隔 调用格式： 123方法名(参数)；方法名(参数1,参数2); 范例： 123isEvenNumber(10);getMax(10,20); 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 3.2 形参和实参 形参：方法定义中的参数 ​ 等同于变量定义格式，例如：int number 实参：方法调用中的参数 ​ 等同于使用变量或常量，例如： 10 number 3.3 带参数方法的练习-打印n-m之间所有的奇数 需求：设计一个方法（print） 用于打印 n 到 m 之间所有的奇数 思路： ​ 1：定义方法，名称为print 12342：为方法添加两个int类型的形参，准备接受调用者传递过来的实参3：方法中设计for循环，循环从n开始，到m结束4：循环中加入if判断，是奇数，则打印5：main方法中调用print方法，传入两个实际参数 代码： 12345678910111213141516171819202122package com.itheima.method2;public class Demo2Method &#123; public static void main(String[] args) &#123; // 5：main方法中调用print方法，传入两个实际参数 print(20,10); &#125; //1：定义方法，名称为print // 2：为方法添加两个int类型的形参，准备接受调用者传递过来的实参 public static void print(int n, int m)&#123; System.out.println(n + \"到\" + m + \"之间的奇数为:\"); // 3：方法中设计for循环，循环从n开始，到m结束 for(int i = 20; i &lt;= 10; i++)&#123; // 4：循环中加入if判断，是奇数，则打印 if(i % 2 == 1)&#123; System.out.println(i); &#125; &#125; &#125;&#125; 4. 带返回值方法的定义和调用4.1 带返回值方法定义和调用（掌握） 定义格式 123public static 数据类型 方法名 ( 参数 ) &#123; return 数据 ;&#125; 范例 123456public static boolean isEvenNumber( int number ) &#123; return true ;&#125;public static int getMax( int a, int b ) &#123; return 100 ;&#125; 注意： 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错 调用格式 12方法名 ( 参数 ) ;数据类型 变量名 = 方法名 ( 参数 ) ; 范例 12isEvenNumber ( 5 ) ;boolean flag = isEvenNumber ( 5 ); 注意： 方法的返回值通常会使用变量接收，否则该返回值将无意义 4.2 带返回值方法的练习-求两个数的最大值(应用) 需求：设计一个方法可以获取两个数的较大值，数据来自于参数 思路： 定义一个方法，声明两个形参接收计算的数值，求出结果并返回 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果 在main()方法中调用定义好的方法并使用 【 变量保存 】 代码： 123456789101112131415161718192021222324252627282930 /* 需求：设计一个方法可以获取两个数的较大值，数据来自于参数 1. 定义一个方法，声明两个形参接收计算的数值，求出结果并返回 2. 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果 3. 在main()方法中调用定义好的方法并使用 【 变量保存 】 */ public static void main(String[] args) &#123; // 3. 在main()方法中调用定义好的方法并使用 【 变量保存 】 System.out.println(getMax(10,20)); // 输出调用 int result = getMax(10,20); System.out.println(result); for(int i = 1; i &lt;= result; i++)&#123; System.out.println(\"HelloWorld\"); &#125; &#125; // 方法可以获取两个数的较大值 public static int getMax(int a, int b)&#123; if(a &gt; b)&#123; return a; &#125;else&#123; return b; &#125; &#125;&#125; 5. 方法的注意事项5.1 方法的通用格式（掌握） 格式： 1234public static 返回值类型 方法名(参数) &#123; 方法体; return 数据 ;&#125; 解释： public static 修饰符，目前先记住这个格式 返回值类型 方法操作完毕之后返回的数据的数据类型 ​ 如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return 方法名 调用方法时候使用的标识 参数 由数据类型和变量名组成，多个参数之间用逗号隔开 方法体 完成功能的代码块 return 如果方法操作完毕，有数据返回，用于把数据返回给调用者 定义方法时，要做到两个明确 明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型 明确参数：主要是明确参数的类型和数量 调用方法时的注意： void类型的方法，直接调用即可 非void类型的方法，推荐用变量接收调用 5.2 方法的注意事项 方法不能嵌套定义 示例代码： 1234567891011public class MethodDemo &#123; public static void main(String[] args) &#123; &#125; public static void methodOne() &#123; public static void methodTwo() &#123; // 这里会引发编译错误!!! &#125; &#125;&#125; void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据 示例代码： 12345678910public class MethodDemo &#123; public static void main(String[] args) &#123; &#125; public static void methodTwo() &#123; //return 100; 编译错误，因为没有具体返回值类型 return; //System.out.println(100); return语句后面不能跟数据或代码 &#125;&#125; 6. 方法重载6.1 方法重载 方法重载概念 方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载 多个方法在同一个类中 多个方法具有相同的方法名 多个方法的参数顺序不相同，类型不同或者数量不同 注意： 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载 正确范例： 1234567891011121314151617public class MethodDemo &#123; public static void fn(int a) &#123; //方法体 &#125; public static int fn(double a) &#123; //方法体 &#125;&#125;public class MethodDemo &#123; public static float fn(int a) &#123; //方法体 &#125; public static int fn(int a , int b) &#123; //方法体 &#125;&#125; 错误范例： 12345678910111213141516171819public class MethodDemo &#123; public static void fn(int a) &#123; //方法体 &#125; public static int fn(int a) &#123; /*错误原因：重载与返回值无关*/ //方法体 &#125;&#125;public class MethodDemo01 &#123; public static void fn(int a) &#123; //方法体 &#125;&#125; public class MethodDemo02 &#123; public static int fn(double a) &#123; /*错误原因：这是两个类的两个fn方法*/ //方法体 &#125;&#125; 6.2 方法重载练习 需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） 思路： ​ ①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数 ​ ②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数 ​ ③定义所有的重载方法，两个byte类型与两个short类型参数 ​ ④完成方法的调用，测试运行结果 代码： 12345678910111213141516171819202122232425262728293031323334public class MethodTest &#123; public static void main(String[] args) &#123; //调用方法 System.out.println(compare(10, 20)); System.out.println(compare((byte) 10, (byte) 20)); System.out.println(compare((short) 10, (short) 20)); System.out.println(compare(10L, 20L)); &#125; //int public static boolean compare(int a, int b) &#123; System.out.println(\"int\"); return a == b; &#125; //byte public static boolean compare(byte a, byte b) &#123; System.out.println(\"byte\"); return a == b; &#125; //short public static boolean compare(short a, short b) &#123; System.out.println(\"short\"); return a == b; &#125; //long public static boolean compare(long a, long b) &#123; System.out.println(\"long\"); return a == b; &#125;&#125; 7. 方法的参数传递7.1 方法参数传递基本类型（理解） 测试代码： 12345678910111213141516171819package com.itheima.param;public class Test1 &#123; /* 方法参数传递为基本数据类型 : 传入方法中的, 是具体的数值. */ public static void main(String[] args) &#123; int number = 100; System.out.println(\"调用change方法前:\" + number); change(number); System.out.println(\"调用change方法后:\" + number); &#125; public static void change(int number) &#123; number = 200; &#125;&#125; 结论： 基本数据类型的参数，形式参数的改变，不影响实际参数 结论依据： 每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失 7.2 方法参数传递引用类型 测试代码： 12345678910111213141516171819package com.itheima.param;public class Test2 &#123; /* 方法参数传递为引用数据类型 : 传入方法中的, 是内存地址. */ public static void main(String[] args) &#123; int[] arr = &#123;10, 20, 30&#125;; System.out.println(\"调用change方法前:\" + arr[1]); change(arr); System.out.println(\"调用change方法后:\" + arr[1]); &#125; public static void change(int[] arr) &#123; arr[1] = 200; &#125;&#125; 结论： 对于引用类型的参数，形式参数的改变，影响实际参数的值 (字符串除外) 结论依据： 引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果 7.3 数组遍历 需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] 思路： 因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”); System.out.println(“内容”); 输出内容并换行 System.out.print(“内容”); 输出内容不换行 System.out.println(); 起到换行的作用 定义一个数组，用静态初始化完成数组元素初始化 定义一个方法，用数组遍历通用格式对数组进行遍历 用新的输出语句修改遍历操作 调用遍历方法 代码： 123456789101112131415161718192021222324252627282930313233343536373839package com.itheima.test;public class Test1 &#123; /* 需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] 思路： 1.定义一个数组，用静态初始化完成数组元素初始化 2.定义一个方法，对数组进行遍历 3.遍历打印的时候，数据不换行 4.调用遍历方法 */ public static void main(String[] args) &#123; // 1.定义一个数组，用静态初始化完成数组元素初始化 int[] arr = &#123;11, 22, 33, 44, 55&#125;; // 4.调用遍历方法 printArray(arr); System.out.println(\"另外一段代码逻辑 \"); &#125; /* 2.定义一个方法，对数组进行遍历 1, 参数 int[] arr 2, 返回值类型 void */ public static void printArray(int[] arr)&#123; System.out.print(\"[\"); for (int i = 0; i &lt; arr.length; i++) &#123; if(i == arr.length -1)&#123; // 如果满足条件, 说明是最后一个元素, 最后一个元素, 特殊处理 System.out.println(arr[i] + \"]\"); &#125;else&#123; // 3.遍历打印的时候，数据不换行 System.out.print(arr[i] + \", \"); &#125; 12 &#125;&#125; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051### 7.4 数组最大值* 需求：设计一个方法用于获取数组中元素的最大值 * 思路： * ①定义一个数组，用静态初始化完成数组元素初始化 * ②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了 * ③调用获取最大值方法，用变量接收返回结果 * ④把结果输出在控制台* 代码： &#96;&#96;&#96;java package com.itheima.test; public class Test2 &#123; &#x2F;* 需求：设计一个方法用于获取数组中元素的最大值 思路： 1.定义一个数组，用静态初始化完成数组元素初始化 2.定义一个方法，用来获取数组中的最大值 3.调用获取最大值方法，用变量接收返回结果 4.把结果输出在控制台 *&#x2F; public static void main(String[] args) &#123; &#x2F;&#x2F; 1.定义一个数组，用静态初始化完成数组元素初始化 int[] arr &#x3D; &#123;11, 55, 22, 44, 33&#125;; &#x2F;&#x2F; 3.调用获取最大值方法，用变量接收返回结果 int max &#x3D; getMax(arr); &#x2F;&#x2F; 4.把结果输出在控制台 System.out.println(max); &#125; &#x2F;* 2.定义一个方法，用来获取数组中的最大值 1, 参数 int[] arr 2, 返回值类型 int *&#x2F; public static int getMax(int[] arr)&#123; int max &#x3D; arr[0]; for (int i &#x3D; 1; i &lt; arr.length; i++) &#123; if(max &lt; arr[i])&#123; max &#x3D; arr[i]; &#125; &#125; return max; &#125; &#125; 7.5 方法同时获取数组最大值和最小值 需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值 注意: return语句, 只能带回一个结果. 代码： 12345678910111213141516171819202122232425262728293031323334353637public class Test3 &#123; /* 需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值 注意: return语句, 只能带回一个结果. */ public static void main(String[] args) &#123; int[] arr = &#123;11,55,33,22,44&#125;; int[] maxAndMin = getMaxAndMin(arr); System.out.println(maxAndMin[0]); System.out.println(maxAndMin[1]); &#125; public static int[] getMaxAndMin(int[] arr)&#123; int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if(max &lt; arr[i])&#123; max = arr[i]; &#125; &#125; int min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if(min &gt; arr[i])&#123; min = arr[i]; &#125; &#125; int[] maxAndMin = &#123;min, max&#125;; return maxAndMin; &#125;&#125;","categories":[],"tags":[]},{"title":"4_IDEA和数组","slug":"4_IDEA和数组","date":"2020-11-02T15:43:12.066Z","updated":"2020-11-03T16:25:02.386Z","comments":true,"path":"2020/11/02/4_IDEA和数组/","link":"","permalink":"http://xiaojujing.com/2020/11/02/4_IDEA%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"第一部分 : IDEA开发工具参见 ：IEDA的安装请参考文件夹PPT中的 04_IDEA.ppt 1.数组1.1 数组介绍​ 数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。","text":"第一部分 : IDEA开发工具参见 ：IEDA的安装请参考文件夹PPT中的 04_IDEA.ppt 1.数组1.1 数组介绍​ 数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。 1.2 数组的定义格式1.2.1 第一种格式​ 数据类型[] 数组名 ​ 示例： 123int[] arr; double[] arr; char[] arr; 1.2.2 第二种格式​ 数据类型 数组名[] ​ 示例： 123int arr[];double arr[];char arr[]; 1.3 数组的动态初始化1.3.1 什么是动态初始化​ 数组动态初始化就是只给定数组的长度，由系统给出默认初始化值 1.3.2 动态初始化格式1数据类型[] 数组名 = new 数据类型[数组长度]; 1int[] arr = new int[3]; 1.3.3 动态初始化格式详解 等号左边： int:数组的数据类型 []:代表这是一个数组 arr:代表数组的名称 等号右边： new:为数组开辟内存空间 int:数组的数据类型 []:代表这是一个数组 3:代表数组的长度 代码 : 1234567891011121314151617181920212223242526272829303132333435package com.itheima.array;public class Demo2Array &#123; /* 数组的动态初始化: 在初始化的时候, 需要手动指定数组的长度, 系统会为数组容器分配初始值. 动态初始化格式: 数据类型[] 数组名 = new 数据类型[数组的长度]; 注意: 打印数组变量的时候, 会打印出数组的内存地址 [I@10f87f48 : @ : 分隔符 [ : 当前的空间是一个数组类型 I : 当前数组容器中所存储的数据类型 10f87f48 : 十六进制内存地址 0 1 2 3 4 5 6 7 8 9 a b c d e f */ public static void main(String[] args) &#123; // 数据类型[] 数组名 = new 数据类型[数组的长度]; // 通过new关键字创建了一个int类型的数组容器, 该容器可以存储5个int类型的整数, 该容器被arr数组变量所记录 int[] arr = new int[5]; // [I@10f87f48 System.out.println(arr); byte[] bArr = new byte[3]; // [B@b4c966a System.out.println(bArr); &#125;&#125; 1.4 数组元素访问1.4.1 什么是索引​ 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始,是连续的,不间断的,每次加1。 ​ 这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 1.4.2访问数组元素格式1数组名[索引]; 1.4.3示例代码1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.array;public class Demo3ArrayIndex &#123; /* 数组动态初始化: 初始化的时候, 手动指定数组长度, 系统会为数组容器分配初始值. 数组的元素访问格式: 数组名[索引] 索引: 数组中数据的编号方式, 编号从0开始 作用: 访问数组容器中的空间位置 注意: 数组在创建完毕后, 即使没有赋值, 也可以取出, 但取出的元素都是默认初始化值. */ public static void main(String[] args) &#123; int[] arr = new int[3]; // 0 1 2 System.out.println(arr); // 数组的内存地址 [I@10f87f48 // 数组名[索引] 访问数组容器中的空间位置 System.out.println(arr[0]); // 0 系统自动分配的默认初始化值 System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(\"--------------\"); // 数组名[索引] arr[0] = 11; arr[1] = 22; arr[2] = 33; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); &#125;&#125; 1.5 内存分配1.5.1 内存概述​ 内存是计算机中的重要原件，临时存储区域，作用是运行程序。 ​ 我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。 ​ 必须放进内存中才能运行，运行完毕后会清空内存。 ​ Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 1.5.2 java中的内存分配 目前我们只需要记住两个内存，分别是：栈内存和堆内存 区域名称 作用 寄存器 给CPU使用，和我们开发无关。 本地方法栈 JVM在使用操作系统功能的时候使用，和我们开发无关。 方法区 存储可以运行的class文件。 堆内存 存储对象或者数组，new来创建的，都存储在堆内存。 方法栈 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 1.6 Java内存分配-一个数组内存图 1.7 两个数组内存图 1.8 多个数组指向相同内存图 1.9 数组的静态初始化1.9.1 什么是静态初始化​ 在创建数组时，直接将元素确定 1.9.2 静态初始化格式 完整版格式 1数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,...&#125;; 简化版格式 1数据类型[] 数组名 = &#123;元素1,元素2,...&#125;; 1.9.3示例代码123456789101112131415161718192021222324252627package com.itheima.array2;public class Demo1Array &#123; /* 数组静态初始化 : 初始化时指定每个数组元素的初始值，由系统决定数组长度 完整格式: 数据类型[] 数组名 = new 数据类型[]&#123;数据1,数据2,数据3...&#125;; 简化格式: 数据类型[] 数组名 = &#123;数据1,数据2,数据3...&#125;; */ public static void main(String[] args) &#123; // 数据类型[] 数组名 = new 数据类型[]&#123;数据1,数据2,数据3...&#125;; int[] arr = new int[]&#123;11,22,33&#125;; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); // 数据类型[] 数组名 = &#123;数据1,数据2,数据3...&#125;; int[] arr2 = &#123;44,55,66&#125;; System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); &#125;&#125; 1.10 数组操作的两个常见问题1.10.1 索引越界异常 出现原因 123456public class ArrayDemo &#123; public static void main(String[] args) &#123; int[] arr = new int[3]; System.out.println(arr[3]); &#125;&#125; 数组长度为3，索引范围是0~2，但是我们却访问了一个3的索引。 程序运行后，将会抛出ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 解决方案 将错误的索引修改为正确的索引范围即可！ 1.10.2 空指针异常 出现原因 123456789public class ArrayDemo &#123; public static void main(String[] args) &#123; int[] arr = new int[3]; //把null赋值给数组 arr = null; System.out.println(arr[0]); &#125;&#125; arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的空指针是不能出现的，一旦出现了，就必须要修改我们编写的代码。 解决方案 给数组一个真正的堆内存空间引用即可！ 1.11 数组遍历 数组遍历：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。 12345678910public class ArrayTest01 &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[3]); System.out.println(arr[4]); &#125;&#125; 以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现。 1234567891011public class ArrayTest01 &#123; public static void main(String[] args) &#123; //定义数组 int[] arr = &#123;11, 22, 33, 44, 55&#125;; //使用通用的遍历格式 for(int x=0; x&lt;arr.length; x++) &#123; System.out.println(arr[x]); &#125; &#125;&#125; 1.12 数组获取最大值 最大值获取：从数组的所有元素中找出最大值。 实现思路： 定义变量，保存数组0索引上的元素 遍历数组，获取出数组中的每个元素 将遍历到的元素和保存数组0索引上值的变量进行比较 如果数组元素的值大于了变量的值，变量记录住新的值 数组循环遍历结束，变量保存的就是数组中的最大值 代码实现： 12345678910111213141516171819202122232425262728293031package com.itheima.test;import java.util.Scanner;public class Test2Array &#123; /* 需求: 从数组中查找最大值 int[] arr = &#123;12,45,98,73,60&#125;; 实现步骤: 1. 假设数组中的第一个元素为最大值 2. 遍历数组, 获取每一个元素, 准备进行比较 3. 如果比较的过程中, 出现了比max更大的, 让max记录更大的值 4. 循环结束后, 打印最大值. */ public static void main(String[] args) &#123; int[] arr = &#123;12,45,98,73,60&#125;; // 1. 假设数组中的第一个元素为最大值 int max = arr[0]; // 2. 遍历数组, 获取每一个元素, 准备进行比较 for(int i = 1; i &lt; arr.length; i++)&#123; // 3. 如果比较的过程中, 出现了比max更大的, 让max记录更大的值 if(arr[i] &gt; max)&#123; max = arr[i]; &#125; &#125; // 4. 循环结束后, 打印最大值. System.out.println(\"max:\" + max); &#125;&#125; 1.13 数组元素求和 需求：键盘录入5个整数，存储到数组中，并对数组求和 思路： 1234561.创建键盘录入对象，准备键盘录入2.定义一个求和变量，准备记录累加后的结果3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值4.将键盘录入的数值存储到数组中5.遍历数组，取出每一个元素，并求和6.输出总和 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940package com.itheima.test;import java.util.Scanner;public class Test3Array &#123; /* 需求：键盘录入5个整数，存储到数组中，并对数组求和 思路： 1.创建键盘录入对象，准备键盘录入 2.定义一个求和变量，准备记录累加后的结果 3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值 4.将键盘录入的数值存储到数组中 5.遍历数组，取出每一个元素，并求和 6.输出总和 */ public static void main(String[] args) &#123; // 1.创建键盘录入对象，准备键盘录入 Scanner sc = new Scanner(System.in); // 2.定义一个求和变量，准备记录累加后的结果 int sum = 0; // 3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值 int[] arr = new int[5]; // 4.将键盘录入的数值存储到数组中 for(int i = 0; i &lt; arr.length; i++)&#123; System.out.println(\"请输入第\" + (i+1) + \"个整数:\"); //arr[i] = 10; arr[i] = sc.nextInt(); &#125; // 5.遍历数组，取出每一个元素，并求和 for (int i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; // 6.输出总和 System.out.println(\"sum:\" + sum); &#125;&#125; 1.14 数组基本查找【应用】 需求： 12已知一个数组 arr &#x3D; &#123;19, 28, 37, 46, 50&#125;; 键盘录入一个数据，查找该数据在数组中的索引，并在控制台输出找到的索引值。 思路： 1234561.定义一个数组，用静态初始化完成数组元素的初始化2.键盘录入要查找的数据，用一个变量接收3.定义一个索引变量，初始值为-14.遍历数组，获取到数组中的每一个元素5.拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环6.输出索引变量 代码实现： 1234567891011121314151617181920212223public static void main(String[] args) &#123; // 1.定义一个数组，用静态初始化完成数组元素的初始化 int[] arr = &#123;19, 28, 37, 46, 50&#125;; // 2.键盘录入要查找的数据，用一个变量接收 Scanner sc = new Scanner(System.in); System.out.println(\"请输入您要查找的元素:\"); int num = sc.nextInt(); // 3.定义一个索引变量，初始值为-1 // 假设要查找的数据, 在数组中就是不存在的 int index = -1; // 4.遍历数组，获取到数组中的每一个元素 for (int i = 0; i &lt; arr.length; i++) &#123; // 5.拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环 if(num == arr[i])&#123; // 如果值相同，就把该值对应的索引赋值给索引变量，并结束循环 index = i; break; &#125; &#125; // 6.输出索引变量 System.out.println(index); &#125;&#125; 1.15 评委打分【应用】 需求：在编程竞赛中，有6个评委为参赛的选手打分，分数为0-100的整数分。 1选手的最后得分为：去掉一个最高分和一个最低分后 的4个评委平均值 (不考虑小数部分)。 思路： 123456781.定义一个数组，用动态初始化完成数组元素的初始化，长度为62.键盘录入评委分数3.由于是6个评委打分，所以，接收评委分数的操作，用循环4.求出数组最大值5.求出数组最小值6.求出数组总和7.按照计算规则进行计算得到平均分8.输出平均分 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 public static void main(String[] args) &#123; // 1.定义一个数组，用动态初始化完成数组元素的初始化，长度为6 int[] arr = new int[6]; // 2.键盘录入评委分数 Scanner sc = new Scanner(System.in); // 3.由于是6个评委打分，所以，接收评委分数的操作，用循环 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(\"请输入第\" + (i+1) + \"个评委的打分:\"); int score = sc.nextInt(); if(score &gt;= 0 &amp;&amp; score &lt;= 100)&#123; // 合法的分值 arr[i] = score; &#125;else&#123; // 非法的分值 System.out.println(\"您的打分输入有误, 请检查是否是0-100之间的\"); i--; &#125; &#125; // 4.求出数组最大值 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if(max &lt; arr[i])&#123; max = arr[i]; &#125; &#125; // 5.求出数组最小值 int min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if(min &gt; arr[i])&#123; min = arr[i]; &#125; &#125; // 6.求出数组总和 int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; // 7.按照计算规则进行计算得到平均分 int avg = (sum - max - min ) / (arr.length-2); // 8.输出平均分 System.out.println(avg); &#125;&#125; 总结数组 第一种：动态初始化格式 建议:数据类型 [] 数组名 = new 数据类型 [数组的长度]; 数据类型 数组名 [] = new 数据类型 [数组的长度]; 第二种：静态初始化格式 数据类型 数组名 [] = new 数据类型 [] {元素1，元素2，元素3…..};—-&gt;简化 用的比较多的:数据类型 数组名 [] = {元素1，元素2，元素3…..}; 数组的好处： 1.可以一次开辟多个空间 2.可以对这多个空间进行统一管理 3.数组定义好之后，每个数组空间都有一个唯一编号（索引，下标，角标），我们在操作数组的时候，都是对统一的数组名和对应的索引来操作数组的每一个空间。赋值:数组名[索引]=值; 拿值:数组名[索引] 4.数组的索引是从0开始，到长度-1结束. 5.我们可以通过数组名.length这个属性来获取数组的长度。 6.获取数组对应索引空间上的数据：数组名[当前的索引]","categories":[],"tags":[]},{"title":"3_switch语句","slug":"3_switch语句","date":"2020-11-02T15:42:34.078Z","updated":"2020-11-05T07:56:53.720Z","comments":true,"path":"2020/11/02/3_switch语句/","link":"","permalink":"http://xiaojujing.com/2020/11/02/3_switch%E8%AF%AD%E5%8F%A5/","excerpt":"1. switch语句1.1 分支语句switch语句 格式 123456789101112switch (表达式) &#123; case 1: 语句体1; break; case 2: 语句体2; break; ... default: 语句体n+1; break;&#125; 执行流程：","text":"1. switch语句1.1 分支语句switch语句 格式 123456789101112switch (表达式) &#123; case 1: 语句体1; break; case 2: 语句体2; break; ... default: 语句体n+1; break;&#125; 执行流程： 首先计算出表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 1.2 switch案例-减肥计划 需求：键盘录入星期数，显示今天的减肥活动 1234567周一：跑步 周二：游泳 周三：慢走 周四：动感单车周五：拳击 周六：爬山 周日：好好吃一顿 示例代码： 1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args)&#123; // 1. 键盘录入星期数据，使用变量接收 Scanner sc = new Scanner(System.in); System.out.println(\"请输入\"); int week = sc.nextInt(); // 2. 多情况判断，采用switch语句实现 switch(week)&#123; // 3. 在不同的case中，输出对应的减肥计划 case 1: System.out.println(\"跑步\"); break; case 2: System.out.println(\"游泳\"); break; case 3: System.out.println(\"慢走\"); break; case 4: System.out.println(\"动感单车\"); break; case 5: System.out.println(\"拳击\"); break; case 6: System.out.println(\"爬山\"); break; case 7: System.out.println(\"好好吃一顿\"); break; default: System.out.println(\"您的输入有误\"); break; &#125; &#125;&#125; 1.3 switch语句case穿透 概述 : 如果switch语句中,case省略了break语句, 就会开始case穿透 需求 : 键盘录入星期数，输出工作日、休息日 (1-5)工作日，(6-7)休息日 示例代码： 1234567891011121314151617181920212223242526272829303132/*case穿透是如何产生的? 如果switch语句中,case省略了break语句, 就会开始case穿透. 现象： 当开始case穿透，后续的case就不会具有匹配效果，内部的语句都会执行 直到看见break，或者将整体switch语句执行完毕，才会结束。*/public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入星期数:\"); int week = sc.nextInt(); switch(week)&#123; case 1: case 2: case 3: case 4: case 5: System.out.println(\"工作日\"); break; case 6: case 7: System.out.println(\"休息日\"); break; default: System.out.println(\"您的输入有误\"); break; &#125; &#125; &#125; 2. for循环2.1 循环语句-for循环 循环： 循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 for循环格式： 123for (初始化语句;条件判断语句;条件控制语句) &#123; 循环体语句;&#125; 格式解释： 初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去 循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去 执行流程： ①执行初始化语句 ②执行条件判断语句，看其结果是true还是false ​ 如果是false，循环结束 ​ 如果是true，继续执行 ③执行循环体语句 ④执行条件控制语句 ⑤回到②继续 2.2 for循环案例-输出数据1-5和5-1 需求：在控制台输出1-5和5-1的数据 示例代码： 12345678910111213public class ForTest01 &#123; public static void main(String[] args) &#123; //需求：输出数据1-5 for(int i=1; i&lt;=5; i++) &#123; System.out.println(i); &#125; System.out.println(\"--------\"); //需求：输出数据5-1 for(int i=5; i&gt;=1; i--) &#123; System.out.println(i); &#125; &#125;&#125; 2.3 for循环案例-求1-5数据和 需求：求1-5之间的数据和，并把求和结果在控制台输出 示例代码： 12345678910111213141516171819202122public class ForTest02 &#123; public static void main(String[] args) &#123; //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0 int sum = 0; //从1开始到5结束的数据，使用循环结构完成 for(int i=1; i&lt;=5; i++) &#123; //将反复进行的事情写入循环结构内部 // 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中 sum += i; /* sum += i; sum = sum + i; 第一次：sum = sum + i = 0 + 1 = 1; 第二次：sum = sum + i = 1 + 2 = 3; 第三次：sum = sum + i = 3 + 3 = 6; 第四次：sum = sum + i = 6 + 4 = 10; 第五次：sum = sum + i = 10 + 5 = 15; */ &#125; //当循环执行完毕时，将最终数据打印出来 System.out.println(\"1-5之间的数据和是：\" + sum); &#125;&#125; 本题要点： 今后遇到的需求中，如果带有求和二字，请立即联想到求和变量 求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的 2.4 for循环案例-求1-100偶数和 需求：求1-100之间的偶数和，并把求和结果在控制台输出 } 示例代码： 123456789101112131415public class ForTest03 &#123; public static void main(String[] args) &#123; //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0 int sum = 0; //对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同 for(int i=1; i&lt;=100; i++) &#123; //对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数 if(i%2 == 0) &#123; sum += i; &#125; &#125; //当循环执行完毕时，将最终数据打印出来 System.out.println(\"1-100之间的偶数和是：\" + sum); &#125;&#125; 2.5 for循环案例-水仙花数 需求：在控制台输出所有的“水仙花数” 解释：什么是水仙花数？ 水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数 例如153 3*3*3 + 5*5*5 + 1*1*1 = 153 思路： 获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取 获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数 示例代码 1234567891011121314151617public class ForTest04 &#123; public static void main(String[] args) &#123; //输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束 for(int i=100; i&lt;1000; i++) &#123; //在计算之前获取三位数中每个位上的值 int ge = i%10; int shi = i/10%10; int bai = i/10/10%10; //判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等 if(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) &#123; //输出满足条件的数字就是水仙花数 System.out.println(i); &#125; &#125; &#125;&#125; 2.6 for循环案例-每行打印2个水仙花数(统计) 需求：在控制台输出所有的“水仙花数”，要求每行打印2个 示例代码： 12345678910111213141516171819202122232425262728293031323334public class Demo6For &#123; /* 需求：在控制台输出所有的“水仙花数”，要求每行打印2个 System.out.print (打印内容); 打印后不换行 System.out.println(打印内容); 打印后换行 分析: 1. 定义变量count，用于保存“打印过”的数量，初始值为0 2. 在判定和打印水仙花数的过程中，拼接空格, 但不换行，并在打印后让count变量+1，记录打印过的数量 3. 在每一次count变量+1后，判断是否到达了2的倍数，是的话，换行。 */ public static void main(String[] args)&#123; // 1. 定义变量count，用于保存“打印过”的数量，初始值为0 int count = 0; for(int i = 100; i &lt;= 999; i++)&#123; int ge = i % 10; int shi = i / 10 % 10; int bai = i / 10 / 10 % 10; if( (ge*ge*ge + shi*shi*shi + bai*bai*bai) == i)&#123; // 2. 在判定和打印水仙花数的过程中，拼接空格, 但不换行，并在打印后让count变量+1，记录打印过的数量 System.out.print(i + \" \"); count++; // 3. 在每一次count变量+1后，判断是否到达了2的倍数，是的话，换行 if(count % 2 == 0)&#123; System.out.println(); &#125; &#125; &#125; &#125;&#125; 本题要点： 今后如果需求带有统计xxx，请先想到计数器变量 计数器变量定义的位置，必须在循环外部 3. while循环3.1 循环语句-while循环 while循环完整格式： 12345初始化语句;while (条件判断语句) &#123; 循环体语句; 条件控制语句;&#125; while循环执行流程： ①执行初始化语句 ②执行条件判断语句，看其结果是true还是false ​ 如果是false，循环结束 ​ 如果是true，继续执行 ③执行循环体语句 ④执行条件控制语句 ⑤回到②继续 示例代码： 12345678910111213141516public class WhileDemo &#123; public static void main(String[] args) &#123; //需求：在控制台输出5次\"HelloWorld\" //for循环实现 for(int i=1; i&lt;=5; i++) &#123; System.out.println(\"HelloWorld\"); &#125; System.out.println(\"--------\"); //while循环实现 int j = 1; while(j&lt;=5) &#123; System.out.println(\"HelloWorld\"); j++; &#125; &#125;&#125; 3.2 while循环案例-珠穆朗玛峰 需求：世界最高山峰是珠穆朗玛峰(8844.43米=8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度? 示例代码： 1234567891011121314151617181920public class WhileTest &#123; public static void main(String[] args) &#123; //定义一个计数器，初始值为0 int count = 0; //定义纸张厚度 double paper = 0.1; //定义珠穆朗玛峰的高度 int zf = 8844430; //因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环 //折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度 while(paper &lt;= zf) &#123; //循环的执行过程中每次纸张折叠，纸张的厚度要加倍 paper *= 2; //在循环中执行累加，对应折叠了多少次 count++; &#125; //打印计数器的值 System.out.println(\"需要折叠：\" + count + \"次\"); &#125;&#125; 4. 循环细节4.1 循环语句-dowhile循环 完整格式： 12345初始化语句;do &#123; 循环体语句; 条件控制语句;&#125;while(条件判断语句); 执行流程： ① 执行初始化语句 ② 执行循环体语句 ③ 执行条件控制语句 ④ 执行条件判断语句，看其结果是true还是false 如果是false，循环结束 如果是true，继续执行 ⑤ 回到②继续 示例代码： 12345678910111213141516public class DoWhileDemo &#123; public static void main(String[] args) &#123; //需求：在控制台输出5次\"HelloWorld\" //for循环实现 for(int i=1; i&lt;=5; i++) &#123; System.out.println(\"HelloWorld\"); &#125; System.out.println(\"--------\"); //do...while循环实现 int j = 1; do &#123; System.out.println(\"HelloWorld\"); j++; &#125;while(j&lt;=5); &#125;&#125; 4.2 三种循环的区别 三种循环的区别 for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行） do…while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断） for循环和while的区别 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用 死循环（无限循环）的三种格式 for(;;){} while(true){} do {} while(true); 4.3 死循环 死循环格式 12345678910111213141516for死循环格式 :for(;;)&#123;&#125;while死循环格式 :while(true)&#123;&#125;do..while死循环格式 :do&#123;&#125;while(true); 死循环案例 12345678910111213141516171819202122232425262728/* 问题: 死循环有应用场景吗? 例如: 键盘录入一个1-100之间的整数 顾虑: 键盘录入是用户操作的, 用户就可能会出现一些误操作的现象 */public static void main(String[] args) &#123; /* for(;;)&#123; System.out.println(\"我停不下来了~\"); &#125; */ /* while(true)&#123; System.out.println(\"我停不下来了~\"); &#125; */ do&#123; System.out.println(\"我停不下来了~\"); &#125;while(true); System.out.println(\"看看我能被执行吗?~\"); // 无法访问的语句&#125;&#125; 4.4 跳转控制语句 跳转控制语句（break） 跳出循环，结束循环 跳转控制语句（continue） 跳过本次循环，继续下次循环 注意： continue只能在循环中进行使用！ 123456789101112131415161718public class Demo1Continue &#123; /* continue : 跳过某次循环体内容的执行 注意：使用是基于条件控制, 在循环内部使用. 需求: 模拟电梯上行的过程 1-24层, 4层不停. */ public static void main(String[] args)&#123; for(int i = 1; i &lt;= 24; i++)&#123; if(i == 4)&#123; continue; &#125; System.out.println(i + \"层到了~\"); &#125; &#125; &#125; 123456789101112131415161718public class Demo2Break &#123; /* break : 终止循环体内容的执行 注意：使用是基于条件控制的 break语句只能在循环和switch中进行使用. 需求: 模拟20岁工作到80岁, 60岁退休. */ public static void main(String[] args)&#123; for(int i = 20; i &lt;= 80; i++)&#123; if(i == 60)&#123; break; // 结束整个循环 &#125; System.out.println(i + \"岁正在上班\"); &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Scanner;public class Test &#123; /* 需求：程序运行后，用户可多次查询星期对应的减肥计划，直到输入0，程序结束 步骤: 1. 不明确用户操作几次, 使用死循环包裹业务逻辑 2. 匹配到0的时候，使用break结束循环死循环 */ public static void main (String[] args)&#123; lo:while(true)&#123; System.out.println(\"请输入您要查看的星期数:\"); System.out.println(\"(如无需继续查看,请输入0退出程序)\"); // 1. 键盘录入星期数据，使用变量接收 Scanner sc = new Scanner(System.in); int week = sc.nextInt(); // 2. 多情况判断，采用switch语句实现 switch(week)&#123; // 3. 在不同的case中，输出对应的减肥计划 case 0: System.out.println(\"感谢您的使用\"); break lo; case 1: System.out.println(\"跑步\"); break; case 2: System.out.println(\"游泳\"); break; case 3: System.out.println(\"慢走\"); break; case 4: System.out.println(\"动感单车\"); break; case 5: System.out.println(\"拳击\"); break; case 6: System.out.println(\"爬山\"); break; case 7: System.out.println(\"好好吃一顿\"); break; default: System.out.println(\"您的输入有误\"); break; &#125; &#125; &#125;&#125; 5. Random5.1 Random产生随机数（掌握） 概述： Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能 API后续课程详细讲解，现在可以简单理解为Java已经写好的代码 使用步骤： 导入包 import java.util.Random; 创建对象 Random r = new Random(); 产生随机数 int num = r.nextInt(10); 解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19 示例代码： 12345678910111213141516171819202122232425262728293031import java.util.Random;public class Demo1Random &#123; /* Random : 产生随机数 1. 导包 : import java.util.Random; 导包的动作必须出现在类定义的上面 2. 创建对象 : Random r = new Random(); 上面这个格式里面，r 是变量名，可以变，其他的都不允许变 3. 获取随机数 : int number = r.nextInt(10); //获取数据的范围：[0,10) 包括0,不包括10 上面这个格式里面，number是变量名，可以变，数字10可以变。其他的都不允许变 需求: 产生随机数1-10之间的 */ public static void main(String[] args)&#123; // 2. 创建对象 Random r = new Random(); for(int i = 1; i &lt;= 10; i++)&#123; // 3. 获取随机数 int num = r.nextInt(10) + 1; // 1-10 System.out.println(num); &#125; &#125;&#125; 5.3 Random练习-猜数字（应用） 需求： 程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？ 当猜错的时候根据不同情况给出相应的提示 A. 如果猜的数字比真实数字大，提示你猜的数据大了 B. 如果猜的数字比真实数字小，提示你猜的数据小了 C. 如果猜的数字与真实数字相等，提示恭喜你猜中了 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Scanner;import java.util.Random;public class Test &#123; /* 需求：程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？ 当猜错的时候根据不同情况给出相应的提示 如果猜的数字比真实数字大，提示你猜的数据大了 如果猜的数字比真实数字小，提示你猜的数据小了 如果猜的数字与真实数字相等，提示恭喜你猜中了 1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入 2. 使用Random产生一个1-100之间的数, 作为要猜的数 3. 键盘录入用户猜的的数据 4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示 5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹 6. 猜对之后, break结束. */ public static void main(String[] args)&#123; // 1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入 Random r = new Random(); Scanner sc = new Scanner(System.in); // 2. 使用Random产生一个1-100之间的数, 作为要猜的数 int randomNum = r.nextInt(100) + 1; // 5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹 while(true)&#123; // 3. 键盘录入用户猜的的数据 System.out.println(\"请输入您猜的数据:\"); int num = sc.nextInt(); // 4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示 if(num &gt; randomNum)&#123; System.out.println(\"猜大了\"); &#125;else if(num &lt; randomNum)&#123; System.out.println(\"猜小了\"); &#125;else&#123; // 6. 猜对之后, break结束. System.out.println(\"恭喜,猜中了\"); break; &#125; &#125; System.out.println(\"感谢您的使用\"); &#125;&#125;","categories":[],"tags":[]},{"title":"2_Java基础语法","slug":"2_Java基础语法","date":"2020-11-01T15:49:40.774Z","updated":"2020-11-05T07:56:15.399Z","comments":true,"path":"2020/11/01/2_Java基础语法/","link":"","permalink":"http://xiaojujing.com/2020/11/01/2_Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"day02 - Java基础语法1 类型转换在Java中，一些数据类型之间是可以相互转换的。分为两种情况：隐式类型转换和强制类型转换 1.1 隐式转换(理解)","text":"day02 - Java基础语法1 类型转换在Java中，一些数据类型之间是可以相互转换的。分为两种情况：隐式类型转换和强制类型转换 1.1 隐式转换(理解)​ 隐式类型转换:小的数据类型的数据赋值给大的数据类型. ​ 这种转换方式是自动的，直接书写即可。例如： 12double num = 10; // 将int类型的10直接赋值给double类型System.out.println(num); // 输出10.0 ​ 类型从小到大关系图： ​ 说明：如果涉及运算操作,两个不同的数据类型进行运算,他的结果会自动提升为较大的数据类型. ​ 12345678byte b1 = 10;byte b2 = 20;byte b3 = b1 + b2; // 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。// 修改为:int num = b1 + b2;// 或者：byte b3 = (byte) (b1 + b2); 2.不同的数据类型进行运算的时候,计算的结果会自动提升为较大的数据类型.数据类型转换规则如下: byte,short,char—&gt;int—&gt;long—&gt;float—&gt;double 1.2 强制转换(理解)​ 强制类型转换:将大的数据类型的数据赋值给较小的数据类型接收. int a = 13.4; //报错 ​ 强制类型转换格式：目标数据类型 变量名 = (目标数据类型) 数值; ​ 例如：int a = (int)13.4; 123double num1 = 5.5;int num2 = (int) num1; // 将double类型的num1强制转换为int类型System.out.println(num2); // 输出5（小数位直接舍弃） 强制有风险,转换需谨慎. 1.3 类型转换案例(理解)案例代码： 1234byte a = 3;byte b = 4;byte c = a + b; //错误。因为两个byte变量相加，会先提升为int类型byte d = 3 + 4; //正确。常量优化机制 常量优化机制： ​ 在编译时，整数常量的计算会直接算出结果，并且会自动判断该结果是否在byte取值范围内， ​ 在：编译通过 不在：编译失败2. 运算符2.1 算术运算符2.1.1 运算符和表达式（了解）运算符:连接java中变量和常量的特殊符号 表达式：用运算符连接变量和常量符合java语法的式子叫做表达式 ​ 不同运算符连接的表达式体现的是不同类型的表达式。 举例说明： 123int a = 10;int b = 20;int c = a + b; +：是运算符，并且是算术运算符。 a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。 2.1.2 算术运算符(应用) 符号 作用 说明 + 加 参看小学一年级 - 减 参看小学一年级 * 乘 参看小学二年级，与“×”相同 / 除 参看小学二年级，与“÷”相同 % 取余 获取的是两个数据做除法的余数 注意： /和%的区别：java当中的除非,取得是商,特点是,两个整数相除只能得到整数,如果想要精确,得到小数, 必须有小数参与运算. %得到的是余数. %符号的两个用处: a.一个数对2取模等于0,他是偶数.如果对二取余不等于0,他是奇数. b.小的数对大的数取模,得到的是小的数. c.取一个多位数对应位置上的数,是这个数先除以对应位置,在对10取模,就能得到这个位置上的数, 例如: 12345678910111213141516171819public class Demo&#123; public static void main(String [] args)&#123; //数据类型 变量名 = 初始化值; int a = 693; //取个位数 int ge = 693%10; //取十位数 //693/10 = 69; //69%10 = 9; int shi = 693/10%10; //取百位数 //693/100=6; //6%10=6; int bai = 693/100%10; System.out.println(ge);//3 System.out.println(shi);//9 System.out.println(bai);//6 &#125;&#125; 1234int a = 10;int b = 3;System.out.println(a / b); // 输出结果3System.out.println(a % b); // 输出结果1 2.1.3 字符的“+”操作（理解）char类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值： ‘a’ – 97 a-z是连续的，所以’b’对应的数值是98，’c’是99，依次递加 ‘A’ – 65 A-Z是连续的，所以’B’对应的数值是66，’C’是67，依次递加 ‘0’ – 48 0-9是连续的，所以’1’对应的数值是49，’2’是50，依次递加 123456789// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少char ch1 = 'a';System.out.println(ch1 + 1); // 输出98，97 + 1 = 98char ch2 = 'A';System.out.println(ch2 + 1); // 输出66，65 + 1 = 66char ch3 = '0';System.out.println(ch3 + 1); // 输出49，48 + 1 = 49 算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。 提升规则: ​ 等级顺序：byte,short,char –&gt; int –&gt; long –&gt; float –&gt; double 例如： 123456789byte b1 = 10;byte b2 = 20;// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度int i3 = b1 + b2; // 应该使用int接收byte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型System.out.println(\"-------------------------------\");int num1 = 10;double num2 = 20.0;double num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型 2.1.4 字符串的“+”操作（理解）当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。就是字符串遇到谁,就把谁拉过来,变成字符串,不管你之前是任何类型. 1System.out.println(\"itheima\"+ 666); // 输出：itheima666 在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右按照优先级的顺序挨个执行. 12345678910111213141516171819202122System.out.println(1 + 99 + \"年黑马\"); // 输出：100年黑马System.out.println(1 + 2 + \"itheima\" + 3 + 4); // 输出：3itheima34// 可以使用小括号改变运算的优先级 System.out.println(1 + 2 + \"itheima\" + (3 + 4)); // 输出：3itheima7public class Demo3&#123; /* 这是主方法,是程序的入口,jvm只认main */ public static void main(String [] args)&#123; //数据类型 变量 = 值; String s = \"12\"; System.out.println(s+13);//1213 System.out.println(1+2+s);//312 System.out.println(s+1*2);//122 System.out.println(s+1+2);//1212 System.out.println(s+(1+2));//123 System.out.println(\"12\"+13);//1213 System.out.println(1+2+\"12\");//312 &#125;&#125; 2.1.5 数值拆分（应用）需求： ​ 键盘录入一个三位数，将其拆分为个位，十位，百位，打印在控制台 示例代码： 12345678910111213141516171819202122232425262728import java.util.Scanner;public class Test &#123; public static void main(String[] args) &#123; // 1：使用Scanner键盘录入一个三位数 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个三位数\"); int num = sc.nextInt(); // 2：个位的计算：数值 % 10 int ge = num % 10; // 3：十位的计算：数值 / 10 % 10 int shi = num / 10 % 10; // 4：百位的计算：数值 / 100 int bai = num / 100; // 5：将个位, 十位, 百位拼接上正确的字符串, 打印即可 System.out.println(\"整数\"+num+\"个位为:\" + ge); System.out.println(\"整数\"+num+\"十位为:\" + shi); System.out.println(\"整数\"+num+\"百位为:\" + bai); &#125;&#125;补充://接收一个整数 //int num = sc.nextInt(); //接收一个小数 //double d = sc.nextDouble(); //输入一个字符串 //String s = sc.nextLine(); 2.2 自增自减运算符（理解） 符号 作用 说明 ++ 自增 变量的值加1 – 自减 变量的值减1 注意事项： ​ ++和– 既可以放在变量的后边，也可以放在变量的前边。 ​ 单独使用的时候，++和–在前面和后面,效果是一样的. ​ 参与操作的时候，如果放在变量的后边，变量的值先参与运算.运算完成之后在进行自增和自减操作 ​ 参与操作的时候，如果放在变量的前边，变量的值先自增或自减,再参与程序的运算. ​ 运算不仅仅是加减乘除的操作,包括打印,以及其他的只要不是单独使用,都可以看做是运算. ​ 速记:你先看到的是啥,你先看到++或–,就先自增或自减,,再参与运算,如果你先看到的是变量,就先参与运算再自增或自减. ​ 最常见的用法：单独使用。 123456789101112131415int i = 10;i++; // 单独使用System.out.println(\"i:\" + i); // i:11int j = 10;++j; // 单独使用System.out.println(\"j:\" + j); // j:11int x = 10;int y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1System.out.println(\"x:\" + x + \", y:\" + y); // x:11，y:10int m = 10;int n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1System.out.println(\"m:\" + m + \", m:\" + m); // m:11，m:11 练习： 123456789int x = 10;int y = x++ + x++ + x++;System.out.println(y); // y的值是多少？/*解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。所以整个式子应该是：int y = 10 + 11 + 12;输出结果为33。*/注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！ 2.3 赋值运算符（应用）赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。 符号 作用 说明 = 赋值 a=10，将10赋值给变量a += 加后赋值 a+=b，将a+b的值给a -= 减后赋值 a-=b，将a-b的值给a *= 乘后赋值 a*=b，将a×b的值给a /= 除后赋值 a/=b，将a÷b的商给a %= 取余后赋值 a%=b，将a÷b的余数给a 注意： 扩展的赋值运算符隐含了强制类型转换。 1234short s = 10;s = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度s += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10); 2.4 关系(比较)运算符（应用）关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。 符号 说明 == a==b，判断a和b的值是否相等，成立为true，不成立为false != a!=b，判断a和b的值是否不相等，成立为true，不成立为false &gt; a&gt;b，判断a是否大于b，成立为true，不成立为false &gt;= a&gt;=b，判断a是否大于等于b，成立为true，不成立为false &lt; a&lt;b，判断a是否小于b，成立为true，不成立为false &lt;= a&lt;=b，判断a是否小于等于b，成立为true，不成立为false 注意事项： ​ 关系运算符的结果都是boolean类型，要么是true，要么是false。 ​ 千万不要把“==”误写成“=”，”==”是判断是否相等的关系，”=”是赋值。 123456789101112int a = 10;int b = 20;System.out.println(a == b); // falseSystem.out.println(a != b); // trueSystem.out.println(a &gt; b); // falseSystem.out.println(a &gt;= b); // falseSystem.out.println(a &lt; b); // trueSystem.out.println(a &lt;= b); // true// 关系运算的结果肯定是boolean类型，所以也可以将运算结果赋值给boolean类型的变量boolean flag = a &gt; b;System.out.println(flag); // 输出false 2.5 逻辑运算符（应用）逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。 逻辑运算符就是整合多个关系表达式或者布尔常量最终的结果. 符号 作用 说明 &amp; 逻辑与 a&amp;b，a和b都是true，结果为true，否则为false,遇false则false | 逻辑或 a|b，a和b都是false，结果为false，否则为true,遇true则true ^ 逻辑异或 a^b，a和b结果不同为true，相同为false ! 逻辑非 !a，结果和a的结果正好相反 1234567891011121314151617181920212223242526272829//定义变量int i = 10;int j = 20;int k = 30;//&amp; “与”，并且的关系，只要表达式中有一个值为false，结果即为falseSystem.out.println((i &gt; j) &amp; (i &gt; k)); //false &amp; false,输出falseSystem.out.println((i &lt; j) &amp; (i &gt; k)); //true &amp; false,输出falseSystem.out.println((i &gt; j) &amp; (i &lt; k)); //false &amp; true,输出falseSystem.out.println((i &lt; j) &amp; (i &lt; k)); //true &amp; true,输出trueSystem.out.println(\"--------\");//| “或”，或者的关系，只要表达式中有一个值为true，结果即为trueSystem.out.println((i &gt; j) | (i &gt; k)); //false | false,输出falseSystem.out.println((i &lt; j) | (i &gt; k)); //true | false,输出trueSystem.out.println((i &gt; j) | (i &lt; k)); //false | true,输出trueSystem.out.println((i &lt; j) | (i &lt; k)); //true | true,输出trueSystem.out.println(\"--------\");//^ “异或”，相同为false，不同为trueSystem.out.println((i &gt; j) ^ (i &gt; k)); //false ^ false,输出falseSystem.out.println(true ^ (i &gt; k)); //true ^ false,输出trueSystem.out.println((i &gt; j) ^ (i &lt; k)); //false ^ true,输出trueSystem.out.println((i &lt; j) ^ (i &lt; k)); //true ^ true,输出falseSystem.out.println(\"--------\");//! “非”，取反System.out.println((i &gt; j)); //falseSystem.out.println(!(i &gt; j)); //!false，,输出true 2.6 短路逻辑运算符（理解） 符号 作用 说明 &amp;&amp; 短路与 作用和&amp;相同，但是有短路效果 || 短路或 作用和|相同，但是有短路效果 逻辑与&amp;,无论左边执行的结果真假,右边都需要执行 短路与&amp;&amp;，左边为真的时候,右边需要执行,左边为假的时候,右边就不需要执行. 逻辑或|，无论左边执行的结果真假,右边都需要执行 短路或||，左边为假的时候,右边需要执行,左边为真的时候,右边不需要执行. 123456789int x = 3;int y = 4;System.out.println((x++ &gt; 4) &amp; (y++ &gt; 5)); // 两个表达都会运算System.out.println(x); // 4System.out.println(y); // 5System.out.println((x++ &gt; 4) &amp;&amp; (y++ &gt; 5)); // 左边已经可以确定结果为false，右边不参与运算System.out.println(x); // 4System.out.println(y); // 4 2.7 三元运算符（理解）三元运算符语法格式： 1关系表达式(布尔常量)?表达式1:表达式2; 解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。 举例： 123int a = 10;int b = 20;int c = a &gt; b ? a : b; // 判断 a&gt;b 是否为真，如果为真取a的值，如果为假，取b的值 2.8 三元运算符案例(应用)需求： ​ 一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。 123456789101112131415161718192021222324252627282930313233public class OperatorTest02 &#123; public static void main(String[] args) &#123; //1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。 int height1 = 150; int height2 = 210; int height3 = 165; //2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。 int tempHeight = height1 &gt; height2 ? height1 : height2; //3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。 int maxHeight = tempHeight &gt; height3 ? tempHeight : height3; //4：输出结果 System.out.println(\"maxHeight:\" + maxHeight); &#125;&#125;//导包 import java.util.Scanner;public class Demo&#123; public static void main(String [] args)&#123; //关系表达式(布尔常量)?表达式1:表达式2; //创建对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入第一个和尚的身高:\"); int heigth1 = sc.nextInt(); System.out.println(\"请输入第二个数和尚的身高:\"); int heigth2 = sc.nextInt(); System.out.println(\"请输入第三个数和尚的身高:\"); int heigth3 = sc.nextInt(); int tempHeigth = heigth1&gt;heigth3?heigth1:heigth3; int max = tempHeigth&gt;heigth2?tempHeigth:heigth2; System.out.println(\"三个和尚的最大身高是\"+max+\"cm\"); &#125; &#125; 3. 流程控制语句在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。 我们写完代码,叫做源代码,需要经过编译,启动java编译器生成对应的.class(类文件).开始执行的时候,jvm找到main方法,因为mian方法是程序的入口,从上到下依次执行,但是代码不一定完成都是从上到下挨个执行,因为我们有些代码是需要满足一定条件才能执行的,有些代码是需要不停的循环的去执行.这些需要特殊执行的语句是通过关键字来实现的,jvm遇到这些关键字的时候,就知道他是干嘛的,就会做对应的处理. 3.1 流程控制语句分类(了解)​ 顺序结构:从上到下 依次执行 ​ 分支结构(if, switch) ​ 循环结构(for, while, do…while) 3.2 顺序结构(了解)顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。 3.3 分支结构之if语句3.3.1 if语句格式1（理解）123456格式： if(关系表达式/布尔常量)&#123; 语句体; &#125;注意事项:if语句体可能执行也可能不执行. 执行流程： ① 首先去判断关系表达式的结果 ② 如果为true,执行语句体,如果为false,不执行语句体 ③继续往下执行. 示例 123456789101112131415public class IfDemo &#123; public static void main(String[] args) &#123; System.out.println(\"开始\"); // 如果年龄大于18岁, 就可以上网吧 int age = 17; if(age &gt;= 18)&#123; // int a = 10; System.out.println(\"可以上网吧\"); &#125; System.out.println(\"结束\"); &#125;&#125; 3.3.2 if语句格式2（理解）1234567格式： if(关系表达式/布尔常量)&#123; 语句体1; &#125;else&#123; 语句体2; 三元运算: 关系表达式(布尔常量)?表达式1:表达式2; &#125; 注意:语句体1和语句体2有且只有一个肯定会执行. 执行流程： ①判断关系表达式的结果,是true还是false ②如果是true,执行语句体1,不执行语句体2 ③如果是false,执行语句体2,不执行语句体1. ④继续向下执行其他代码 示例：奇偶数 ​ 任意给出一个整数，请用程序实现判断该整数是奇数还是偶数，并在控制台输出该整数是奇数还是偶数。 123456789101112public class Demo2If &#123; public static void main(String[] args) &#123; // 程序判断一个数, 是奇数还是偶数 int num = 9; if(num % 2 == 0)&#123; System.out.println(\"偶数\"); &#125;else&#123; System.out.println(\"奇数\"); &#125; &#125;&#125; 3.3.3 if语句格式3（理解）12345678910111213格式： if(关系表达式1)&#123; 语句体1; &#125;else if(关系表达式2)&#123; 语句体2; &#125;else if(关系表达式3)&#123; 语句体3; &#125; .... &#125; else if(关系表达式n)&#123; 语句体n; &#125;else&#123; 语句体n+1; &#125; 执行流程： ①首先执行关系表达式1的值,如果为true,执行语句体1,执行完之后,整个if结束.继续向下执行 ②如果为false,执行关系表达式2的值,如果为true,执行语句体2,执行完之后,整个if结束.继续向下执行 ③关系表达式2的值如果为false,执行关系表达式3的值,如果为true,执行语句体3,执行完之后,整个if结束.继续向下执行 ⑤如果所有的关系表达式的值都为false,执行else里面的语句体n+1;执行完之后,整个if结束.继续向下执行 示例： ​ 定义一个在0100之间的变量a, 90100优秀，8089良好，7079中等，6069及格，059请努力加油！ 123456789101112131415161718public class Demo3If &#123; public static void main(String[] args)&#123; int score = 65; if(score &gt;= 90 &amp;&amp; score &lt;= 100)&#123; System.out.println(\"优秀\"); &#125;else if (score &gt;= 80 &amp;&amp; score &lt;= 89)&#123; System.out.println(\"良好\"); &#125;else if (score &gt;= 70 &amp;&amp; score &lt;= 79)&#123; System.out.println(\"中等\"); &#125;else if (score &gt;= 60 &amp;&amp; score &lt;= 69)&#123; System.out.println(\"及格\"); &#125;else if (score &gt;= 0 &amp;&amp; score &lt;= 59)&#123; System.out.println(\"请努力加油\"); &#125;else&#123; System.out.println(\"成绩有误!\"); &#125; &#125;&#125; 3.3.4 if语句格式3案例（应用）需求：小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。 分析： ​ ①小明的考试成绩未知，可以使用键盘录入的方式获取值 ​ ②由于奖励种类较多，属于多种判断，采用if…else…if格式实现 ​ ③为每种判断设置对应的条件 ​ ④为每种判断设置对应的奖励 1234567891011121314151617181920212223242526import java.util.Scanner;public class IfTest02 &#123; public static void main(String[] args)&#123; // 1. 使用Scanner录入考试成绩 Scanner sc = new Scanner(System.in); System.out.println(\"请输入您的成绩:\"); int score = sc.nextInt(); // 2. 判断成绩是否在合法范围内 0~100 if(score &gt;=0 &amp;&amp; score &lt;= 100)&#123; // 合法成绩 // 3. 在合法的语句块中判断成绩范围符合哪一个奖励 if(score &gt;= 95 &amp;&amp; score &lt;= 100)&#123; System.out.println(\"自行车一辆\"); &#125;else if(score &gt;= 90 &amp;&amp; score &lt;= 94)&#123; System.out.println(\"游乐场一次\"); &#125;else if(score &gt;= 80 &amp;&amp; score &lt;= 89)&#123; System.out.println(\"变形金刚一个\"); &#125;else &#123; System.out.println(\"挨顿揍, 这座城市又多了一个伤心的人~\"); &#125; &#125;else&#123; // 非法的话, 给出错误提示 System.out.println(\"您的成绩输入有误!\"); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"1_Java概述","slug":"1_Java概述","date":"2020-11-01T15:48:20.534Z","updated":"2020-11-06T16:02:08.321Z","comments":true,"path":"2020/11/01/1_Java概述/","link":"","permalink":"http://xiaojujing.com/2020/11/01/1_Java%E6%A6%82%E8%BF%B0/","excerpt":"1. Java概述1.1 Java语言背景介绍（了解）语言：人与人交流的一种方式 计算机语言：人与计算机进行交流的一种方式,java就是其中一种最优秀的方式之一. Java语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言","text":"1. Java概述1.1 Java语言背景介绍（了解）语言：人与人交流的一种方式 计算机语言：人与计算机进行交流的一种方式,java就是其中一种最优秀的方式之一. Java语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言 Java之父：高司令 2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：https://www.oracle.com java语言的三个版本： ​ JavaSE: Java 语言的（标准版），用于桌面应用的开发，是其他两个版本的基础 ​ JavaME: Java 语言的（小型版），用于嵌入式消费类电子设备 ​ JavaEE: Java 语言的（企业版），用于 Web 方向的网站开发 1.2 Java语言跨平台原理（理解）平台:操作系统 跨平台:同一套java代码可以不经任何修改在任意操作系统上运行. 操作系统:windows,mac,linux. java程序的跨平台是通过jvm(java虚拟机,当做一个假想的计算机)解决的,但jvm本身不垮平台,我们只需要在对应操作系统上安装对应jv即可. Java程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。 1.3 JRE和JDK（记忆）开发的三个步骤: 1.编写程序 2.编译程序 3.运行程序 JVM（Java Virtual Machine），java虚拟机,主要是解决跨平台. JRE（Java Runtime Environment），java运行环境,包含jvm+核心类库. JDK（Java Development Kit）,java开发工具包:jre+开发工具 总结：jdk(开发工具包) = jre(jvm+核心类库)+ 开发工具 1.4 JDK的下载和安装（应用）版本:我们的程序是需要根据社会的发展和需求进行不断的更新和迭代.进而更新我们写的程序,版本就依次叠加. java5里程碑 java8公司用的最多 我们学习12,11 1.4.1 下载通过官方网站获取JDK http://www.oracle.com 注意：不同的操作系统需要下载对应的jdk. 1.4.2 安装傻瓜式安装，下一步即可。但默认的安装路径是在C:\\Program Files下，为方便统一管理建议修改安装路径，将与开发相关的软件都安装到一个目录下，例如：E:\\develop。 注意：安装路径不要包含中文或者空格等特殊字符（使用纯英文目录）。 1.4.3 JDK的安装目录介绍 目录名称 说明 bin 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 conf 该路径下存放了JDK的相关配置文件。 include 该路径下存放了一些平台特定的头文件。 jmods 该路径下存放了JDK的各种模块。 legal 该路径下存放了JDK各模块的授权文档。 lib 该路径下存放了JDK工具的一些补充JAR包。 2. 第一个演示程序2.1 常用DOS命令（应用）在接触集成开发环境之前，我们需要使用命令行窗口对java程序进行编译和运行，所以需要知道一些常用DOS命令。 1、打开命令行窗口的方式：win + r打开运行窗口，输入cmd，回车。 2、常用命令及其作用 操作 说明 盘符名称: 盘符切换。E:回车，表示切换到E盘。 dir 查看当前路径下的内容。 cd 目录 进入单级目录。cd itheima cd .. 回退到上一级目录。 cd 目录1\\目录2... 进入多级目录。cd itheima\\JavaSE cd / 回退到盘符目录。 cls 清屏。 exit 退出命令提示符窗口。 2.2 Path环境变量的配置（应用）我们希望在任何情况下都能去运行我们jdk的bin目录下的开发工具。 1.如果我们想要去执行某个应用程序的时候，想在任何目录下去执行，那我们应该怎么办？ a.我们手动的点入到这个命令所在的文件夹,然后打开dos窗口,进行执行 b.我们讲此命令的地址配置到环境变量中,就可以在任意目录下去执行我们的命令. 原理:我们在执行命令的时候,首先系统回去当前文件夹下面去寻找有没有这个命令,如果有,就执行,如果没有就去环境变量中去寻找,有就执行,没有就报错, 2.3 HelloWorld案例（应用）HelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。 各种计算机语言都习惯使用该案例作为第一个演示案例。 2.3.1 Java程序开发运行流程开发Java程序，需要三个步骤: 编写程序: 新建一个记事本,将后缀名改成 文件名.java 编译程序:javac 文件名.java 执行程序: java 文件名 2.3.2 HelloWorld案例的编写1、新建文本文档文件，修改名称为HelloWorld.java。 2、用记事本打开HelloWorld.java文件，输写程序内容。 12345public class HelloWorld&#123; public static void main(String [] args)&#123; System.out.println(\"HelloWorld\"); &#125;&#125; 2.3.3 HelloWorld案例的编译和运行存文件，打开命令行窗口，将目录切换至java文件所在目录，编译java文件生成class文件，运行class文件。 编译：javac 文件名.java 范例：javac HelloWorld.java 执行：java 文件名 范例：java HelloWorld 2.4 HelloWorld案例详解（理解） java程序都是由一个个类组成的,类是java程序的基本组成单位.类是由方法和其他东西组成. 类的定义格式:class 类名{ } main方法是官方定义好的方法,他是程序的入口,一个类如果需要执行,必须有main(主方法)方法. jvm只认main方法. main方法的定义格式为: public static void main(String [] args){ } 2.5 HelloWorld案例常见问题（理解）2.5.1 BUG程序在运行过程中遇到的错误或没有达到预期效果的转态. 2.5.2 BUG的解决1、具备识别BUG的能力：多看 2、具备分析BUG的能力：多做 3、具备解决BUG的能力：多查 2.5.3 HelloWorld案例常见问题1、非法字符问题。Java中的符号都是英文格式的。 2、大小写问题。Java语言对大小写敏感（区分大小写）。 3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。 4、编译命令后的java文件名需要带文件后缀.java 5、运行命令后的class文件名（类名）不带文件后缀 2.6 Notepad++软件的安装和使用（应用）2.6.1 什么要使用Notepad++软件Notepad++功能比windows中的自带记事本功能强大，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。Notepad++有行号，能够快速定位问题位置，还有语法高亮度显示、代码折叠等功能。而且它是免费的。 2.6.2 Notepad++软件安装安装：傻瓜式安装，一直下一步即可。建议也安装到统一的开发软件目录下，比如E:\\develop。 2.6.3Notepad++软件配置安装完毕之后，为了使用方便，做一个简单的配置：修改默认语言和编码。 3. java基础语法3.1 注释（理解）注释是对代码的解释和说明文字，可以提高程序的可读性，因此在程序中添加必要的注释文字十分重要。Java中的注释分为三种： 单行注释。 1//从双斜线开始到本行尾结束,都不参与程序的编译和执行 多行注释。 1234/*这里面涉及到的多行信息都不参与程序的编译和执行*/注意：多行注释不能嵌套使用。 123456789101112131415161718192021/*java是由一个个类组成,类是java程序基本组成单位类的定义格式:public class 类名&#123; &#125;*/public class A&#123; /* 这是主方法 他是程序的入口,一个类需要执行,必须有主方法,他是由官方定义好的 他的定义格式 public static void main(String [] args)&#123; &#125; */ public static void main(String [] args)&#123; //这是一条输出语句,双引号里面写啥,控制台就打印什么 System.out.println(\"AD\"); &#125;&#125; 文档注释。文档注释以/**开始，以*/结束。（以后讲) 3.2 关键字（理解）关键字是被java官方赋予了特殊含义的单词. 关键字的特点： ​ 1.全部由字母组成,并且字母都是小写 ​ 2.常见的代码编辑器会对其进行高亮显示. ​ 例如:class public static void 3.3 常量（应用）常量：在程序的运行中,其值不可发生改变的量,叫做常量. Java中的常量分类： ​ 字符串常量 :被双引号引起来的内容叫做字符串,理解为生活中的一句话,包括0个或多个字符 ​ 整数常量 : 所有整数 ​ 小数常量 :所有小数 ​ 字符常量 :被单引号引起来的单个字符,就是一个字 ​ 布尔常量 :只有两个 true(真,正确的,对的) 和 false(假,错误的,不对的) ​ 空常量 : null 不能直接打印 除空常量外，其他常量均可使用输出语句直接输出。 123456789101112131415161718192021222324252627public class A&#123; /* 这是主方法 他是程序的入口,一个类需要执行,必须有主方法,他是由官方定义好的 他的定义格式 public static void main(String [] args)&#123; &#125; */ public static void main(String [] args)&#123; //这是一条输出语句,双引号里面写啥,控制台就打印什么 //被双引号引起来的内容叫做字符串,理解为生活中的一句话 System.out.println(\"你好,我好,大家好\"); //所有整数 System.out.println(10); // System.out.println(\"10\"); //小数 所有小数 System.out.println(10.0); //字符 System.out.println('我'); //布尔常量 true和false System.out.println(true); System.out.println(false); //空常量 null 不能被打印 // System.out.println(null); &#125;&#125; 3.4 变量的介绍(理解)变量其实就是内存中的一块存储空间,里面存在可能会经常发生改变的数值 变量也是在程序运行中,值可能会发生改变的量. 变量的定义格式： ​ 数据类型 变量名 = 初始化值; ​ 数据类型：马上讲解 ​ 变量名：自己起的名字 ​ 数据值： 一开始,你自己定,开始你想他是多少就是多少. 3.5 数据类型（应用）3.5.1 计算机存储单元我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”， 通常用大写字母”B”表示，字节是由连续的8个位组成。 除了字节外还有一些常用的存储单位，其换算单位如下： 1B = 8b 1kb = 1024B 1mb = 1024kb 1Gb = 1024mb 1Tb = 1024Gb 3.5.2 Java中的数据类型Java是一个强类型语言，Java中的数据必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。 Java中的基本数据类型：四类8种 数据类型 关键字 内存占用 取值范围 整数类型 byte 1 -128~127 short 2 -32768~32767 int(默认) 4 -2的31次方到2的31次方-1 long 8 -2的63次方到2的63次方-1 浮点类型 float 4 负数：-3.402823E+38到-1.401298E-45 正数： 1.401298E-45到3.402823E+38 double(默认) 8 负数：-1.797693E+308到-4.9000000E-324 正数：4.9000000E-324 到1.797693E+308 字符类型 char 2 0-65535 布尔类型 boolean 1 true，false 引用数据类型:类,数组,接口. 说明： ​ e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。 ​ 在java中整数默认是int类型，浮点数默认是double类型。 3.6 变量（应用）3.6.1 变量的定义变量：变量其实就是内存中的一块存储空间,里面存在可能会经常发生改变的数值 变量也是在程序运行中,值可能会发生改变的量. 从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化。 变量的定义格式： 123数据类型 变量名 = 初始化值; // 声明变量并赋值int age = 18;System.out.println(age); 或者(扩展) 123456// 先声明，后赋值（使用前赋值即可）数据类型 变量名;变量名 = 初始化值;double money;money = 55.5;System.out.println(money); 还可以(扩展) 在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。但不建议使用这种方式，降低程序的可读性。 123456789int a = 10, b = 20; // 定义int类型的变量a和b，中间使用逗号隔开System.out.println(a);System.out.println(b);int c,d; // 声明int类型的变量c和d，中间使用逗号隔开c = 30;d = 40;System.out.println(c);System.out.println(d); 3.6.2 变量的修改123int a = 10;a = 30; //修改变量的值System.out.println(a); 变量前面不加数据类型时，表示修改已存在的变量的值。 1234567891011121314151617181920212223242526272829303132333435363738public class Demo&#123; public static void main(String [] args)&#123; //变量的定义格式 数据类型 变量名 = 初始化值; 定义变量并赋值 /*int a = 10; double d = 3.14; char c = '我'; boolean b = true; //使用变量 直接使用变量名即可 //直接打印 System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); // 修改值 变量名 = 新值; a = 20; b= false; c='你'; d = 5.20; System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); //第二种定义格式 //定义一个变量不复制 数据类型 变量名; int aa ; // 变量名 = 初始化值; aa = 60; System.out.println(aa);*/ //定义变量的第三种格式 一次性定义多个相同类型的变量 //数据类型 变量名 = 初始化值,变量名 = 初始化值.... int a = 10,b=20,c=30; System.out.println(a); System.out.println(b); System.out.println(c); &#125;&#125; 3.7 变量的注意事项(理解) 在同一对花括号中，变量名不能重复。 变量在使用之前，必须初始化（赋值）。 定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。 定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的，类型不兼容。 3.8 键盘录入（理解）我们可以通过 Scanner 类来获取用户的输入。使用步骤如下： 1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。 1import java.util.Scanner; 2、创建Scanner对象。 1Scanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变 3、接收数据 1int i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。 示例： 1234567891011121314//导包 (告诉高司令我要用一下你写的类)import java.util.Scanner;public class Demo2&#123; public static void main(String [] args)&#123; // 数据类型 变量名 = 初始化值; //创建对象(使用规则) sc是变量名 除了他可以改 其他的都不要改 Scanner sc1 = new Scanner(System.in); //接收用户输入的值 System.out.println(\"请您输入一个数字\"); int a = sc1.nextInt(); System.out.println(a); &#125; &#125; 3.9 标识符（理解）标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。 Java中标识符的组成规则： 1.数字,字母,_(下划线),$组成. 2.不能以数字开头 3.区分大小写. 4.不能是关键字 Java中标识符的命名约定： ​ 小驼峰式命名：变量,方法 ​ 首字母小写,从第二个单词开始首字母大写 ​ 例如：username、studentNumber等。 ​ 大驼峰式命名：类名 ​ 所有组成单词首字母大写. ​ 例如:HelloWold​ ​","categories":[],"tags":[]},{"title":"PAT乙级1025","slug":"PAT乙级1025","date":"2020-02-15T15:48:25.000Z","updated":"2020-02-15T15:48:25.347Z","comments":true,"path":"2020/02/15/PAT乙级1025/","link":"","permalink":"http://xiaojujing.com/2020/02/15/PAT%E4%B9%99%E7%BA%A71025/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"广度优先搜索","slug":"广度优先搜索","date":"2020-02-12T14:40:52.000Z","updated":"2020-02-12T14:41:58.803Z","comments":true,"path":"2020/02/12/广度优先搜索/","link":"","permalink":"http://xiaojujing.com/2020/02/12/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std; /int N,K; //抓住这头牛const int MAXN=100000;int visited[MAXN+10];struct Step{ int x; int steps; Step(int xx,int s):x(xx),steps(s){ }};queue q;/ int main(){ /cin&gt;&gt;N&gt;&gt;K; memset(visited,0,sizeof(visited)); q.push(Step(N,0)); visited[N]=1; while(!q.empty()){ Step s=q.front(); if(s.x==K){ cout&lt;&lt;s.steps&lt;&lt;endl; return 0; }else{ if(s.x&gt;=0&amp;&amp;!visited[s.x-1]){ q.push(Step(s.x-1,s.steps+1)); visited[s.x-1]=1; } if(s.x+1&lt;=MAXN&amp;&amp;!visited[s.x+1]){ q.push(Step(s.x+1,s.steps+1)); visited[s.x+1]=1; } if(s.x2&lt;=MAXN&amp;&amp;!visited[s.x2]){ q.push(Step(s.x2,s.steps+1)); visited[s.x2]=1; } q.pop(); } }/ return 0;}","categories":[],"tags":[]},{"title":"贪心","slug":"贪心","date":"2020-02-11T07:34:19.000Z","updated":"2020-02-11T07:35:55.861Z","comments":true,"path":"2020/02/11/贪心/","link":"","permalink":"http://xiaojujing.com/2020/02/11/%E8%B4%AA%E5%BF%83/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std; /const double eps=1e-6; //圣诞老人的礼物struct Candy{ int v; int w; bool operator &lt; (const Candy &amp; c){ return double(v)/w-double(c.v)/c.w&gt;eps; }}candies[110];/ struct Cow{ //分配畜栏 int a,b; int No; bool operator &lt; (const Cow &amp;c) const{ return a&lt;c.a; };}cows[50100];int pos[50100];struct Stall{ int end; int No; bool operator&lt;(const Stall &amp;s) const{ return end&gt;s.end; } Stall(int e,int n):end(e),No(n){ }}; int main(){ /int n,w; scanf(“%d%d”,&amp;n,&amp;w); for(int i=0;i&lt;n;i++){ scanf(“%d%d”,&amp;candies[i].v,&amp;candies[i].w); } sort(candies,candies+n); int totalW=0; double totalV=0; for(int i=0;i&lt;n;i++){ if(totalW+candies[i].w&lt;=w){ totalW+=candies[i].w; totalV+=candies[i].v; }else{ totalV+=candies[i].v*double(w-totalW)/candies[i].w; break; } } printf(“%.1f”,totalV);/ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;++i){ scanf(&quot;%d%d&quot;,&amp;cows[i].a,&amp;cows[i].b); cows[i].No=i; } sort(cows,cows+n); int total=0; priority_queue&lt;Stall&gt; pq; for(int i=0;i&lt;n;++i){ if(pq.empty()){ ++total; pq.push(Stall(cows[i].b,total)); pos[cows[i].No]=total; }else{ Stall st=pq.top(); if(st.end&lt;cows[i].a){ pq.pop(); pos[cows[i].No]=st.No; pq.push(Stall(cows[i].b,st.No)); }else{ ++total; pq.push(Stall(cows[i].b,total)); pos[cows[i].No]=total; } } } printf(&quot;%d\\n&quot;,total); for(int i=0;i&lt;n;i++){ printf(&quot;%d\\n&quot;,pos[i]); } return 0;}","categories":[],"tags":[]},{"title":"动态规划","slug":"动态规划","date":"2020-02-10T11:54:26.000Z","updated":"2020-02-10T11:55:04.676Z","comments":true,"path":"2020/02/10/动态规划/","link":"","permalink":"http://xiaojujing.com/2020/02/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std; /const int MAXN=1010; //最长上升子序列int a[MAXN];int maxLen[MAXN];/ char sz1[1000]; //最长公共子序列char sz2[1000];int maxLen[1000][1000]; int main(){ /int N; cin&gt;&gt;N; for(int i=1;i&lt;=N;i++){ cin&gt;&gt;a[i]; maxLen[i]=1; } for(int i=2;i&lt;=N;i++){ for(int j=1;j&lt;i;j++){ if(a[i]&gt;a[j]) maxLen[i]=max(maxLen[i],maxLen[j]+1); } } cout&lt;&lt;*max_element(maxLen+1,maxLen+N+1);/ while(cin&gt;&gt;sz1&gt;&gt;sz2){ int length1=strlen(sz1); int length2=strlen(sz2); int nTmp; int i,j; for(i=0;i&lt;=length1;i++) maxLen[i][0]=0; for(j=0;j&lt;=length2;j++) maxLen[0][j]=0; for(i=1;i&lt;=length1;i++){ for(j=1;j&lt;=length2;j++){ if(sz1[i-1]==sz2[j-1]) maxLen[i][j]=maxLen[i-1][j-1]+1; else maxLen[i][j]=max(maxLen[i][j-1],maxLen[i-1][j]); } } cout&lt;&lt;maxLen[length1][length2]&lt;&lt;endl; } return 0;}","categories":[],"tags":[]},{"title":"深度优先搜索","slug":"深度优先搜索","date":"2020-02-09T14:07:52.000Z","updated":"2020-02-09T14:08:11.093Z","comments":true,"path":"2020/02/09/深度优先搜索/","link":"","permalink":"http://xiaojujing.com/2020/02/09/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std;/*int R,C; //城堡问题int rooms[60][60];int color[60][60];int maxRoomArea=0,roomNum=0;int roomArea;void Dfs(int i,int k){ if(color[i][k]) return; ++roomArea; color[i][k]=roomNum; if((rooms[i][k]&amp;1)==0) Dfs(i,k-1); if((rooms[i][k]&amp;2)==0) Dfs(i-1,k); if((rooms[i][k]&amp;4)==0) Dfs(i,k+1); if((rooms[i][k]&amp;8)==0) Dfs(i+1,k);} int visited[30][50]; //采方格int ways(int i,int j,int n){ if(n==0) return 1; visited[i][j]=1; int num=0; if(!visited[i][j-1]) num+=ways(i,j-1,n-1); if(!visited[i][j+1]) num+=ways(i,j+1,n-1); if(!visited[i+1][j]) num+=ways(i+1,j,n-1); visited[i][j]=0; return num;} int k,n,r; //寻路问题struct Road{ int d,L,t;};vector&lt; vector &gt; G(110);int minL[110][10010];int minLen;int totalLen;int totalCost;int visited[110]; void dfs(int s){ if(s==n){ minLen=min(minLen,totalLen); return; } for(int i=0;i&lt;G[s].size();++i){ Road r=G[s][i]; if(totalCost+r.t&gt;k) continue; if(!visited[r.d]){ if(totalLen+r.L&gt;=minLen) continue; if(totalLen+r.L&gt;=minL[r.d][totalCost+r.t]) continue; minL[r.d][totalCost+r.t]=totalLen+r.L; totalLen+=r.L; totalCost+=r.t; visited[r.d]=1; dfs(r.d); totalLen-=r.L; totalCost-=r.t; visited[r.d]=0; } }}*/ int N,M; //生日蛋糕int minArea=1&lt;&lt;30;int area=0; void Dfs(int v,int n,int r,int h){ if(n==0){ if(v) return ; else{ minArea=min(minArea,area); return; } } if(v&lt;=0) return; for(int rr=r;rr&gt;=n;–rr){ if(n==M) area=rrrr; for(int hh=h;hh&gt;=n;–hh){ area+=2rrhh; Dfs(v-rrrrhh,n-1,rr-1,hh-1); area-=2rr*hh; } }} int main(){ /cin&gt;&gt;R&gt;&gt;C; for(int i=1;i&lt;=R;i++){ for(int k=1;k&lt;=C;k++){ cin&gt;&gt;rooms[i][k]; } } memset(color,0,sizeof(color)); for(int i=1;i&lt;=R;i++){ for(int k=1;k&lt;=C;k++){ if(!color[i][k]){ ++roomNum; roomArea=0; Dfs(i,k); maxRoomArea=max(roomArea,maxRoomArea); } } } cout&lt;&lt;roomNum&lt;&lt;endl&lt;&lt;maxRoomArea&lt;&lt;endl;/ /*int n; cin&gt;&gt;n; memset(visited,0,sizeof(visited)); cout&lt;&lt;ways(0,25,n); cin&gt;&gt;k&gt;&gt;n&gt;&gt;r; for(int i=0;i&lt;r;i++){ int s; Road r; cin&gt;&gt;s&gt;&gt;r.d&gt;&gt;r.L&gt;&gt;r.t; if(s!=r.d){ G[s].push_back(r); } } memset(visited,0,sizeof(visited)); totalLen=0; minLen=1&lt;&lt;30; totalCost=0; visited[1]=1; for(int i=0;i&lt;110;i++){ for(int j=0;j&lt;10010;j++){ minL[i][j]=1&lt;&lt;30; } } dfs(1); if(minLen&lt;(1&lt;&lt;30)){ cout&lt;&lt;minLen&lt;&lt;endl; }else{ cout&lt;&lt;-1&lt;&lt;endl; }*/ int maxR=5,maxH=100; cin&gt;&gt;N&gt;&gt;M; Dfs(N,M,maxR,maxH); if(minArea==1&lt;&lt;30) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;minArea&lt;&lt;endl; return 0;}","categories":[],"tags":[]},{"title":"分治再探","slug":"分治再探","date":"2020-02-08T15:45:45.000Z","updated":"2020-02-08T15:54:00.706Z","comments":true,"path":"2020/02/08/分治再探/","link":"","permalink":"http://xiaojujing.com/2020/02/08/%E5%88%86%E6%B2%BB%E5%86%8D%E6%8E%A2/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std;#define MAX 101int D[MAX][MAX]={0};int n;int maxsum[MAX][MAX];int MaxSum(int i,int j){ if(maxsum[i][j]!=-1) return maxsum[i][j]; if(i==n) maxsum[i][j]=D[i][j]; else{ int x=MaxSum(i+1,j); int y=MaxSum(i+1,j+1); maxsum[i][j]=max(x,y)+D[i][j]; } return maxsum[i][j];}int main(){ int i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++){ for(j=1;j&lt;=i;j++){ cin&gt;&gt;D[i][j]; maxsum[i][j]=-1; } } cout&lt;&lt;MaxSum(1,1)&lt;&lt;endl; return 0;}","categories":[],"tags":[]},{"title":"递归和分治","slug":"递归和分治","date":"2020-02-07T15:10:35.000Z","updated":"2020-02-07T15:50:52.451Z","comments":true,"path":"2020/02/07/递归和分治/","link":"","permalink":"http://xiaojujing.com/2020/02/07/%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB/","excerpt":"","text":"#include&lt;bits/stdc++.h&gt;using namespace std;void Swap(int &amp;a,int &amp;b){ int temp=0; temp=a; a=b; b=temp;} void Hanoi(int n,char src,char mid,char dest){ //汉诺塔问题 if(n==1){ cout&lt;&lt;src&lt;&lt;”-&gt;”&lt;&lt;dest&lt;&lt;endl; return; } Hanoi(n-1,src,dest,mid); cout&lt;&lt;src&lt;&lt;”-&gt;”&lt;&lt;dest&lt;&lt;endl; Hanoi(n-1,mid,src,dest);} int N;int queenPos[100];void NQueen(int k){ //N皇后 if(k==N){ for(int i=0;i&lt;N;i++){ cout&lt;&lt;queenPos[i]+1&lt;&lt;’ ‘; } cout&lt;&lt;endl; return; } for(int i=0;i&lt;N;i++){ int j; for(j=0;j&lt;k;j++){ if(queenPos[j]==i||abs(queenPos[j]-i)==abs(k-j)){ break; } } if(j==k){ queenPos[k]=i; NQueen(k+1); } }} double exp(){ //逆波兰式 char s[20]; cin&gt;&gt;s; switch(s[0]){ case ‘+’: return exp()+exp(); case ‘-‘: return exp()-exp(); case ‘‘: return exp()exp(); case ‘/‘: return exp()/exp(); default: return atof(s); break; }} int expression_value(){ //表达式的值 int term_value(); int result=term_value(); bool more=true; while(more){ char op=cin.peek(); if(op==’+’||op==’-‘){ cin.get(); int value=term_value(); if(op==’+’) result+=value; else result-=value; } else more=false; } return result;}int term_value(){ int factor_value(); int result=factor_value(); while(true){ char op=cin.peek(); if(op==’‘||op==’/‘){ cin.get(); int value=factor_value(); if(op==’‘) result*=value; else result/=value; } else break; } return result; }int factor_value(){ int result=0; char c=cin.peek(); if(c==’(‘){ cin.get(); result=expression_value(); cin.get(); }else{ while(isdigit(c)){ result=10*result+c-‘0’; cin.get(); c=cin.peek(); } } return result;} bool HuiWen(string s){ //回文串判断,小写输入 int h=0,t=s.size()-1; while(h&lt;=t){ if(s[h]!=s[t]) return 0; h++;t–; } return 1;} void QuanPai(int a[],int k,int n){ //全排列 if(n==k){ for(int i=1;i&lt;=n;i++){ cout&lt;&lt;a[i]&lt;&lt;’ ‘; } cout&lt;&lt;endl; }else{ for(int i=k;i&lt;n+1;i++){ Swap(a[k],a[i]); QuanPai(a,k+1,n); Swap(a[k],a[i]); } } } int main(){ //递归 /*char a=&apos;A&apos;,b=&apos;B&apos;,c=&apos;C&apos;; int n=0; cin&gt;&gt;n; Hanoi(n,a,b,c);*/ /*cin&gt;&gt;N; NQueen(0);*/ //cout&lt;&lt;exp()&lt;&lt;endl; //cout&lt;&lt;expression_value()&lt;&lt;endl; //分治 /*string s; int flag=-1; cin&gt;&gt;s; flag=HuiWen(s); cout&lt;&lt;&quot;回文串:&quot;&lt;&lt;flag&lt;&lt;endl; */ /*int *a,len; cout&lt;&lt;&quot;len:&quot;&lt;&lt;endl; cin&gt;&gt;len; a=new int[len+1]; for(int i=1;i&lt;len+1;i++){ a[i]=i; } QuanPai(a,1,len);*/ return 0;}","categories":[],"tags":[]},{"title":"STL实践","slug":"STL实践","date":"2020-02-06T15:39:45.000Z","updated":"2020-02-06T17:54:54.461Z","comments":true,"path":"2020/02/06/STL实践/","link":"","permalink":"http://xiaojujing.com/2020/02/06/STL%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"#include #include#include#include#include#include#include#include#includeusing namespace std;struct Student{ int a,b; bool operator &lt; (const Student &amp;rs) const{ if(a==rs.a) return b&lt;rs.b; return a&lt;rs.a; }}; int main(){ priority_queue q; deque ::const_iterator i; set ::const_iterator j; map &lt;int,char&gt;::iterator k; vector v; deque d; map&lt;int,char&gt; m; set s; s.insert(5);s.insert(8);s.insert(1);s.insert(3);s.insert(3); m.insert(pair&lt;int,char&gt;(1,’a’)); m.insert(pair&lt;int,char&gt;(2,’a’)); m.insert(pair&lt;int,char&gt;(3,’c’)); m.insert(pair&lt;int,char&gt;(4,’d’)); /m.insert(map&lt;int,char&gt;::value_type(1,’a’)); m.insert(map&lt;int,char&gt;::value_type(1,’b’)); m.insert(map&lt;int,char&gt;::value_type(3,’c’)); m.insert(map&lt;int,char&gt;::value_type(4,’d’));/ for(k=m.begin();k!=m.end();k++){ cout&lt;&lt;1&lt;&lt;’ ‘; } cout &lt;&lt;endl; for(int i=0;i&lt;10;i++){ v.push_back(i); d.push_front(i); } for(i=d.begin();i&lt;d.end();i++){ cout&lt;&lt;i&lt;&lt;’ ‘; } cout &lt;&lt;endl; for(j=s.begin();j!=s.end();j++){ cout&lt;&lt;j&lt;&lt;’ ‘; } cout &lt;&lt;endl; for(int i=0;i&lt;10;i++){ q.push(i); } while(q.size()){ cout&lt;&lt;q.top()&lt;&lt;&apos; &apos;; q.pop(); } cout &lt;&lt;endl; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q_; for(int i=0;i&lt;10;i++){ q_.push(i); } while(q_.size()){ cout&lt;&lt;q_.top()&lt;&lt;&apos; &apos;; q_.pop(); } cout &lt;&lt;endl; Student student[5]={{5,5},{5,4},{3,1},{2,2},{2,1}}; sort(student,student+5); for(int i=0;i&lt;5;i++){ cout&lt;&lt;student[i].a&lt;&lt;&apos; &apos;&lt;&lt;student[i].b&lt;&lt;endl; } priority_queue &lt;Student&gt; qq; for(int i=0;i&lt;5;i++){ qq.push(student[i]); } while(qq.size()){ Student now=qq.top(); cout&lt;&lt;now.a&lt;&lt;&apos; &apos;&lt;&lt;now.b&lt;&lt;endl; qq.pop(); } cout &lt;&lt;endl; return 0;}","categories":[],"tags":[]},{"title":"图的遍历","slug":"图的遍历","date":"2020-02-05T14:42:29.000Z","updated":"2020-02-05T14:45:27.662Z","comments":true,"path":"2020/02/05/图的遍历/","link":"","permalink":"http://xiaojujing.com/2020/02/05/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"","text":"邻接表存储DFSvoid Visit(Vertex v){ printf(“%d\\n”,v);}void DFS(LGraph Graph,Vertex v,void (*Visit)(Vertex)){ ProToAdjVNode W; Visit(v); Visited[v]=true; for(W=Graph-&gt;G[v].FitstEdge;W;W=W-&gt;Next){ if(!Visited[W-&gt;Adjv]){ DFS(Graph,W-&gt;Adjv,Visit); } }} 邻接矩阵存储BFSvoid Visit(Vertex v){ printf(“正在访问的顶点%d\\n”,v);}bool IsEdge(MGraph Graph,Vertex v,Vertex w){ return Graph-&gt;G[v][w]&lt;INFNITY?true:false;}void BFS(MGraph Graph,Vertex S,void(*Visit)(Vertex)){ queue Q; Vertex V,W; Visit(S); Visited[S]=true; Q.push(S); while(!Q.empty()){ V=Q.front();Q.pop(); for(W=0;WNv;W++){ if(!Visited[W]&amp;&amp;IsEdge(Graph,V,W)){ Visit(W); Visited[W]=true; Q.push(W); } } }}","categories":[],"tags":[]},{"title":"图的两种表示法","slug":"图的两种表示法","date":"2020-02-04T14:38:09.000Z","updated":"2020-02-04T14:38:32.857Z","comments":true,"path":"2020/02/04/图的两种表示法/","link":"","permalink":"http://xiaojujing.com/2020/02/04/%E5%9B%BE%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%B3%95/","excerpt":"","text":"邻接矩阵表示:#include#include#define MaxVertexNum 100#define INFNITY 65535using namespace std;typedef int Vertex;typedef int WeightType;typedef char DataType; typedef struct ENode{ Vertex v1,v2; WeightType Weight;}*PtrToENode;typedef PtrToENode Edge; typedef struct GNode{ int Nv,Ne; WeightType G[MaxVertexNum][MaxVertexNum]; DataType Data[MaxVertexNum];}*PtrToMNode;typedef PtrToMNode MGraph; MGraph CreateGraph(int VertexNum){ Vertex v,w; MGraph Graph; Graph=(MGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv=VertexNum; Graph-&gt;Ne=0; for(v=0;vNv;v++){ for(w=0;wNv;w++){ Graph-&gt;G[v][w]=INFNITY; } } return Graph;}void InsertEdge(MGraph Graph,Edge E){ Graph-&gt;G[E-&gt;v1][E-&gt;v2]=E-&gt;Weight; Graph-&gt;G[E-&gt;v2][E-&gt;v1]=E-&gt;Weight;}MGraph BuildGraph(){ MGraph Graph; Edge E; Vertex v; int Nv,i; scanf(“%d”,&amp;Nv); Graph=CreateGraph(Nv); scanf(“%d”,&amp;(Graph-&gt;Ne)); if(Graph-&gt;Ne!=0){ E=(Edge)malloc(sizeof(struct ENode)); for(i=0;iNe;i++){ scanf(“%d%d%d”,&amp;E-&gt;v1,&amp;E-&gt;v2,&amp;E-&gt;Weight); InsertEdge(Graph,E); } } for(v=0;vNv;v++){ scanf(“ %c”,&amp;(Graph-&gt;Data[v])); } return Graph;}int main(){ MGraph Graph; Graph=BuildGraph(); int n=0; int v=-1; printf(“请输入你要查询的顶点编号:”); scanf(“%d”,&amp;v); printf(“你查询的顶点%c的邻接点:\\n”,Graph-&gt;Data[v]); for(n=0;nNv;n++){ if(Graph-&gt;G[v][n]&lt;INFNITY&amp;&amp;Graph-&gt;G[v][n]&gt;0){ printf(“%c “,Graph-&gt;Data[n]); } } printf(“\\n”); for(int i=0;iNv;i++){ for(int j=0;jNv;j++){ printf(“%d “,Graph-&gt;G[i][j]); } printf(“\\n”); } /* 5 5 0 1 2 0 3 10 0 4 13 1 2 4 2 4 9 a e d c b */ return 0;} 邻接表表示#include#includeusing namespace std; #define MaxVertexNum 100typedef int Vertex;typedef int WeightType;typedef char DataType; typedef struct ENode{ Vertex v1,v2; WeightType Weight;}*PtrToENode;typedef PtrToENode Edge; typedef struct AdjVNode{ Vertex Adjv; WeightType Weight; AdjVNode Next;}ProToAdjVNode; typedef struct VNode{ ProToAdjVNode FitstEdge; DataType Data;}AdjList[MaxVertexNum]; typedef struct GNode{ int Nv; int Ne; AdjList G;}*PtrToGNode;typedef PtrToGNode LGraph; LGraph CreateGraph(int VertexNum){ Vertex v; LGraph Graph; Graph=(LGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv=VertexNum; Graph-&gt;Ne=0; for(v=0;vNv;v++){ Graph-&gt;G[v].FitstEdge=NULL; } return Graph;} void InsertEdge(LGraph Graph,Edge E){ ProToAdjVNode NewNode; NewNode=(ProToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;Adjv=E-&gt;v2; NewNode-&gt;Weight=E-&gt;Weight; NewNode-&gt;Next=Graph-&gt;G[E-&gt;v2].FitstEdge; Graph-&gt;G[E-&gt;v1].FitstEdge=NewNode; NewNode=(ProToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;Adjv=E-&gt;v1; NewNode-&gt;Weight=E-&gt;Weight; NewNode-&gt;Next=Graph-&gt;G[E-&gt;v2].FitstEdge; Graph-&gt;G[E-&gt;v2].FitstEdge=NewNode;}LGraph BuildGraph(){ LGraph Graph; Edge E; Vertex v; int Nv,i; scanf(“%d”,&amp;Nv); Graph=CreateGraph(Nv); scanf(“%d”,&amp;(Graph-&gt;Ne)); if(Graph-&gt;Ne!=0){ E=(Edge)malloc(sizeof(ENode)); for(i=0;iNe;i++){ scanf(“%d %d %d”,&amp;E-&gt;v1,&amp;E-&gt;v2,&amp;E-&gt;Weight); InsertEdge(Graph,E); } } for(v=0;vNv;v++){ scanf(“ %c”,&amp;(Graph-&gt;G[v].Data)); } return Graph;}int main(){ LGraph Graph; Graph=BuildGraph(); int n=0; int v=-1; printf(“请输入你要查询的顶点编号:”); scanf(“%d”,&amp;v); printf(“你查询的顶点%c的邻接点:”,Graph-&gt;G[v].Data); AdjVNode M; M=Graph-&gt;G[v].FitstEdge; while(M!=NULL){ printf(“%c “,Graph-&gt;G[M-&gt;Adjv].Data); M=M-&gt;Next; } printf(“\\n”); / 5 5 1 0 2 3 0 10 4 0 13 2 1 4 4 2 9 a e d c b */ return 0;}","categories":[],"tags":[]},{"title":"栈队列二叉树的简单实现","slug":"静态栈和队列以及二叉树","date":"2020-02-03T13:03:14.000Z","updated":"2020-02-03T13:24:29.597Z","comments":true,"path":"2020/02/03/静态栈和队列以及二叉树/","link":"","permalink":"http://xiaojujing.com/2020/02/03/%E9%9D%99%E6%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"#include#includeusing namespace std;typedef char Elemtype;typedef struct BiTNode{ Elemtype data; BiTNode lchild,rchild;}BiTNode,BiTree;int CreatBiTree(BiTree &amp;T){ //建立二叉树 Elemtype ch; cin&gt;&gt;ch; if(ch==’#’) T=NULL; else{ T=(BiTNode)malloc(sizeof(BiTNode)); T-&gt;data=ch; CreatBiTree(T-&gt;lchild); CreatBiTree(T-&gt;rchild); } return 0;}void PreOrder(BiTree &amp;T){ if(T!=NULL){ cout&lt;data&lt;&lt;endl; PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); }}void InOrder(BiTree &amp;T){ if(T!=NULL){ InOrder(T-&gt;lchild); cout&lt;data&lt;&lt;endl; InOrder(T-&gt;rchild); }}void PostOrder(BiTree &amp;T){ if(T!=NULL){ PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); cout&lt;data&lt;&lt;endl; }} int main(){ BiTree T; CreatBiTree(T); printf(“先序遍历:\\n”); // a PreOrder(T); // b c printf(“中序遍历:\\n”); //d e InOrder(T); // f g printf(“后序遍历:\\n”); PostOrder(T); return 0;}","categories":[],"tags":[]},{"title":"数据结构几种排序的简单实现","slug":"数据结构内部排序简单实现","date":"2020-02-02T15:16:58.000Z","updated":"2020-02-02T15:46:04.696Z","comments":true,"path":"2020/02/02/数据结构内部排序简单实现/","link":"","permalink":"http://xiaojujing.com/2020/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"源代码如下,亲测可用(基于c语言)#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void swap(int a,int *b){ //交换 int temp; temp=a; a=b; *b=temp;}//直接插入排序void Insert(int a[],int n){ int i=0,j=0,k=0,temp=0; for(i=1;i&lt;n;i++){ for(j=0;j&lt;i;j++){ if(a[i]&lt;a[j]){ temp=a[i]; for(k=i-1;k&gt;=j;k–){ a[k+1]=a[k]; } a[j]=temp; } } }}//希尔排序void Shell(int a[],int n){ int D=5,Dk=0,i=0,j=0,k=0,temp=0; for(D=5;D&gt;=1;D/=2){ //增量 for(Dk=0;Dk&lt;D;Dk++){ //执行增量排序次数 for(i=Dk+D;i&lt;n;i+=D){ //基于增量的直接插入排序 for(j=Dk;j&lt;i;j+=D){ if(a[i]&lt;a[j]){ temp=a[i]; for(k=i-D;k&gt;=j;k-=D){ a[k+D]=a[k]; } a[j]=temp; } } } } }}//简单选择排序void Select(int a[],int n){ int i=0,j=0,min=-1,minIndex,temp=0; for(i=0;i&lt;n-1;i++){ min=a[i]; for(j=i;j&lt;n;j++){ //找出最小元素的下标 if(a[j]&lt;min){ min=a[j]; minIndex=j; } } swap(a+i,a+minIndex); }}//冒泡排序void Bubble(int a[],int n){ int i=0,j=0,temp=0; for(i=n-1;i&gt;0;i–){ for(j=0;j&lt;i;j++){ if(a[j]&gt;a[j+1]){ swap(a+j,a+j+1); } } }}//快速排序void Quick(int a[],int low,int high){ if(low&gt;high) return; int L=low,R=high,pivot=a[low]; while(L&lt;R){ while(L&lt;R&amp;&amp;a[R]&gt;=pivot){ //从右边开始找到比枢纽小的值移到左边 R–; } if(L&lt;R){ a[L]=a[R]; L++; } while(L&lt;R&amp;&amp;a[L]&lt;pivot){ //从左边开始找到比枢纽小的值移到右边 L++; } if(L&lt;R){ a[R]=a[L]; R–; } } Quick(a,low,L-1); Quick(a,L+1,high); }int main(){ int begin=0,end=0; int i=0,a[100]={0}; for(i=0;i&lt;100;i++){ a[i]=rand()%1000; } //Insert(a,100); //Bubble(a,100); //Select(a,100); //Shell(a,100); Quick(a,0,99); for(i=1;i&lt;=100;i++){ printf(“%d “,a[i-1]); if(i%10==0) printf(“\\n”); } return 0;}","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2020-02-01T13:05:40.000Z","updated":"2020-02-01T13:35:05.766Z","comments":true,"path":"2020/02/01/我的第一篇博客文章/","link":"","permalink":"http://xiaojujing.com/2020/02/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"万事开头难–坚持 大四即将工作的老学长即日起更新博客. 励志做一名中级程序员 qaq~~ 座右铭: 我赚钱养家,你拿去花.","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"编译 类加载 双亲委派","slug":"编译-类加载-双亲委派","permalink":"http://xiaojujing.com/tags/%E7%BC%96%E8%AF%91-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"},{"name":"IO流","slug":"IO流","permalink":"http://xiaojujing.com/tags/IO%E6%B5%81/"}]}